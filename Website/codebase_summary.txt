# WEBSITE CODEBASE SUMMARY
-e 
## File Structure

- ./
  - .claude/
  - .sessions/
  - build/
    - tools/
  - css/
    - vendor/
  - icons/
  - includes/
  - js/
    - vendor/
  - models/
  - node_modules/
  - persist/
    - data/
    - img/
    - thumbs/
  - tests/
-e 
## File Contents

-e 
### ./addbook.py

```py
from flask import Flask, request, render_template_string, redirect
import json, os, threading, webbrowser
from datetime import datetime

app = Flask(__name__)
json_file = 'data/books.json'

def load_books():
    if os.path.exists(json_file):
        with open(json_file, 'r') as f:
            return json.load(f)
    return []

def save_books(books):
    with open(json_file, 'w') as f:
        json.dump(books, f, indent=2)

def shutdown_server():
    func = request.environ.get('werkzeug.server.shutdown')
    if func:
        func()
    else:
        # force exit if shutdown function isn't available
        os._exit(0)

form_html = '''
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>add a new book</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; }
    label { display: block; margin-bottom: 0.5rem; }
    input, select, textarea { width: 100%; margin-bottom: 1rem; }
    /* inline styling for checkbox label */
    label.inline { display: inline-flex; align-items: center; }
    /* genre tags styling */
    #genreTags { border: 1px solid #ccc; padding: 5px; min-height: 40px; display: flex; flex-wrap: wrap; gap: 5px; }
    .tag { background: #e0e0e0; padding: 3px 8px; border-radius: 4px; }
    #genreInput { border: none; outline: none; flex-grow: 1; }
    /* manual date inputs on same line */
    #manualDateInputs label { display: inline-block; margin-right: 10px; width: auto; }
  </style>
</head>
<body>
  <h1>add a new book</h1>
  <form method="post">
    <label>title:<br><input type="text" name="title" required></label>
    <label>author:<br><input type="text" name="author" required></label>
    <label>spine color:<br><input type="color" name="spineColor" value="#ffffff" required></label>
    <label>title color:<br><input type="color" name="titleColor" value="#000000" required></label>
    <label>author color:<br><input type="color" name="authorColor" value="#000000" required></label>
    <label>rating (1-5):<br><input type="number" name="rating" min="1" max="5" required></label>
    
    <label>genre (separate multiple genres with commas):</label>
    <div id="genreTags">
      <input type="text" id="genreInput" placeholder="type genre(s) and use commas">
    </div>
    <input type="hidden" name="genre" id="genreHidden" required>
    
    <label class="inline">
      <input type="checkbox" name="use_current_date" id="useCurrentDate" checked>
      use current date
    </label>
    <div id="manualDateInputs" style="display: none;">
      <label>month read: <input type="text" name="month" placeholder="month"></label>
      <label>year read: <input type="text" name="year" placeholder="year"></label>
    </div>
    
    <label>review:<br><textarea name="review" required></textarea></label>
    <button type="submit">add book</button>
  </form>

  <script>
    // handle genre tags input using comma as delimiter
    const genreInput = document.getElementById('genreInput');
    const genreTags = document.getElementById('genreTags');
    const genreHidden = document.getElementById('genreHidden');
    let genres = [];
    
    function updateGenreTags() {
      genreTags.innerHTML = '';
      genres.forEach(tag => {
        const span = document.createElement('span');
        span.className = 'tag';
        span.textContent = tag;
        genreTags.appendChild(span);
      });
      genreTags.appendChild(genreInput);
      genreHidden.value = genres.join(', ');
    }
    
    // on input, if comma is detected, split and add each tag
    genreInput.addEventListener('input', function() {
      if (this.value.includes(',')) {
        const parts = this.value.split(',');
        parts.forEach(part => {
          const trimmed = part.trim();
          if (trimmed && !genres.includes(trimmed)) {
            genres.push(trimmed);
          }
        });
        this.value = '';
        updateGenreTags();
      }
    });
    
    // toggle manual date inputs based on checkbox state
    const useCurrentDateCheckbox = document.getElementById('useCurrentDate');
    const manualDateInputs = document.getElementById('manualDateInputs');
    useCurrentDateCheckbox.addEventListener('change', function() {
      manualDateInputs.style.display = this.checked ? 'none' : 'block';
    });
    
    // on window unload, attempt to shutdown server (best-effort)
    window.addEventListener("unload", function() {
      navigator.sendBeacon("/shutdown");
    });
  </script>
</body>
</html>
'''

@app.route('/', methods=['GET', 'POST'])
def add_book():
    if request.method == 'POST':
        if 'use_current_date' in request.form:
            now = datetime.now()
            month = now.strftime("%B").lower()
            year = now.strftime("%Y")
        else:
            month = request.form.get('month', '')
            year = request.form.get('year', '')
        dates_read = month + " " + year
        new_book = {
            "title": request.form['title'],
            "author": request.form['author'],
            "spineColor": request.form['spineColor'],
            "titleColor": request.form['titleColor'],
            "authorColor": request.form['authorColor'],
            "rating": int(request.form['rating']),
            "genre": request.form['genre'],
            "datesRead": dates_read,
            "review": request.form['review']
        }
        books = load_books()
        books.insert(0, new_book)
        save_books(books)
        shutdown_server()
        return "book added. server shutting down."
    return render_template_string(form_html)

@app.route('/shutdown', methods=['POST'])
def shutdown():
    shutdown_server()
    return "server shutting down..."

if __name__ == '__main__':
    port = 5000
    url = f"http://127.0.0.1:{port}/"
    threading.Timer(1.0, lambda: webbrowser.open(url)).start()
    app.run(debug=True, use_reloader=False, port=port)
-e 
```
-e 
### ./admin.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Website Admin Panel</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/admin.css" />
  <link rel="stylesheet" href="https://unpkg.com/easymde/dist/easymde.min.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
  <div id="loginSection">
    <h1>Admin Login</h1>
    <p style="color: red;">Note: This is basic protection for local use ONLY. Do not rely on this for security on a live server.</p>
    <label for="password">Password:</label>
    <input type="password" id="password">
    <button id="loginButton">Login</button>
    <p id="loginError" style="color: red; display: none;">Incorrect password.</p>
  </div>

  <div id="adminContent" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <h1>Website Administration</h1>
      <button id="logoutButton" style="height: 36px; margin-right: 20px;">Logout</button>
    </div>
    
    <!-- Notification area for success/error messages -->
    <div id="adminNotifications" style="position: fixed; top: 10px; right: 10px; z-index: 1050; max-width: 300px;"></div>
    
    <!-- Loading indicator -->
    <div id="loadingIndicator" style="display: none; padding: 10px; background-color: #f8f9fa; border: 1px solid #ddd; margin-bottom: 15px; text-align: center;">
      <div style="display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(0, 123, 255, 0.3); border-radius: 50%; border-top-color: #007bff; animation: spin 1s linear infinite; margin-right: 10px;"></div>
      <span>Loading data...</span>
    </div>
    
    <div class="admin-warning">
      <h3>⚠️ Admin Panel</h3>
      <p>Changes made here will be saved directly to the server.</p>
    </div>

    <!-- Tab Navigation -->
    <div class="admin-tabs">
      <ul class="tab-nav">
        <li><a href="#books" data-tab-target="#bookManagementSection" class="tab-link active">Books</a></li>
        <li><a href="#photos" data-tab-target="#photoManagementSection" class="tab-link">Photos</a></li>
        <li><a href="#projects" data-tab-target="#projectManagementSection" class="tab-link">Projects</a></li>
        <li><a href="#trips" data-tab-target="#tripManagementSection" class="tab-link">Manage Trips</a></li>
        <li><a href="#cv-content" data-tab-target="#cvContentSection" class="tab-link">CV Content</a></li>
        <li><a href="#research-content" data-tab-target="#researchContentSection" class="tab-link">Edit Research</a></li>
        <li><a href="#contact-details" data-tab-target="#contactDetailsSection" class="tab-link">Contact Details</a></li>
        <li><a href="#homepage" data-tab-target="#homepageSection" class="tab-link">Homepage Content</a></li>
        <!-- Add future tabs here -->
      </ul>
    </div>

    <!-- Tab Content -->
    <div class="tab-content">
      <!-- Books Management Tab -->
      <section id="bookManagementSection" class="tab-pane active">
        <h2>Manage Books</h2>
        <div id="bookListSection">
          <table>
            <thead>
              <tr>
                <th>Title</th>
                <th>Author</th>
                <th>Rating</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="bookTableBody">
              <!-- Book rows will be inserted here -->
            </tbody>
          </table>
        </div>
        
        <div id="bookFormSection">
          <form id="bookForm" style="border: 1px solid #ddd; padding: 15px; margin-top: 20px;">
            <h3 id="formTitle">Add New Book</h3>
            <input type="hidden" id="bookIndex" value="">
            
            <label for="title">Title:</label>
            <input type="text" id="title" required>
            
            <label for="author">Author:</label>
            <input type="text" id="author" required>
            
            <label for="spineColor">Spine Color:</label>
            <input type="color" id="spineColor" value="#ca0b0b">
            
            <label for="titleColor">Title Text Color:</label>
            <input type="color" id="titleColor" value="#ffffff">
            
            <label for="authorColor">Author Text Color:</label>
            <input type="color" id="authorColor" value="#ffffff">
            
            <label for="rating">Rating (1-5):</label>
            <select id="rating">
              <option value="5">★★★★★</option>
              <option value="4">★★★★☆</option>
              <option value="3">★★★☆☆</option>
              <option value="2">★★☆☆☆</option>
              <option value="1">★☆☆☆☆</option>
            </select>
            
            <label for="genre">Genre(s) (comma-separated):</label>
            <input type="text" id="genre" placeholder="Fiction, Literature, etc.">
            
            <label for="datesRead">Date Read:</label>
            <input type="text" id="datesRead" placeholder="month year">
            
            <label for="review">Review:</label>
            <textarea id="review" rows="6"></textarea>
            
            <div style="margin-top: 15px;">
              <button type="submit" id="saveBookBtn">Save Book</button>
              <button type="button" id="cancelBtn">Cancel</button>
            </div>
          </form>
        </div>
      </section>

      <!-- Photos Management Tab -->
      <section id="photoManagementSection" class="tab-pane">
        <h2>Manage Photos (World Map)</h2>
        <div id="photoListSection">
          <!-- Trip groups will be added here by JS -->
          <div id="photosGroupContainer">
              <p>Loading photo groups...</p>
          </div>
        </div>
        <hr> <!-- Separator -->
        <div id="photoFormSection">
          <!-- Photo add/edit form -->
          <form id="photoForm" enctype="multipart/form-data" style="margin-top: 15px; border: 1px solid #eee; padding: 10px;">
              <h3>Add/Edit Photo</h3>
              <input type="hidden" id="photoEditIndex" value="-1">
              <label for="photoFile">Upload New Image (Optional):</label>
              <input type="file" id="photoFile" name="uploadedImage" accept="image/jpeg, image/png, image/gif, image/webp, image/heic, image/heif, .heic, .heif, image/*">
              <input type="hidden" id="currentPhotoThumbnail">
              <input type="hidden" id="currentPhotoImageFull">
              <p style="font-size: 0.8em; margin-top: -5px;">Leave empty if not changing the image.</p>
              <label for="photoTitle">Title:</label> <input type="text" id="photoTitle"><br>
              <label for="photoDate">Date:</label> <input type="text" id="photoDate" placeholder="YYYY-MM-DD"><br>
              <label for="photoDescription">Description:</label> <textarea id="photoDescription"></textarea><br>
              <label for="photoLat">Latitude:</label> <input type="number" step="any" id="photoLat" required>
              <label for="photoLng">Longitude:</label> <input type="number" step="any" id="photoLng" required>
              
              <div style="margin-top: 5px; margin-bottom: 10px;">
                <button type="button" id="showCoordMapButton">Select on Map</button>
                <span style="font-size:0.9em; color: #555;"> (Attempts auto-fill from EXIF on file select)</span>
              </div>
              <div id="coordMap" style="height: 400px; width: 100%; margin-bottom: 15px; display: none; border: 1px solid #ccc;"></div><br>
              <label for="photoRanking">Ranking (1-10):</label>
              <input type="number" id="photoRanking" min="1" max="10" value="5"><br>
                            <input type="hidden" id="photoFullWidth">
              <input type="hidden" id="photoFullHeight">
              <label for="photoTags">Tags (comma-separated):</label>
              <input type="text" id="photoTags" placeholder="landscape, city, landmark"><br>
              <label for="photoTripIdSelect">Assign to Trip (Optional):</label>
              <select id="photoTripIdSelect">
                <option value="">-- No Trip --</option>
                <!-- Trip options will be added by JS -->
              </select><br>
              <button type="submit" id="photoSubmitButton">Add Photo</button>
              <button type="button" id="photoCancelButton" style="display: none;">Cancel Edit</button>
          </form>
        </div>
      </section>

      <!-- Projects Management Tab -->
      <section id="projectManagementSection" class="tab-pane">
        <h2>Manage Projects</h2>
        <div id="projectListSection">
          <!-- Placeholder for project list -->
           <table class="sortable">
             <thead>
               <tr>
                 <th class="drag-handle"></th>
                 <th>Title</th>
                 <th>Status</th>
                 <th>Actions</th>
               </tr>
             </thead>
             <tbody id="projectTableBody"></tbody>
           </table>
        </div>
        <div id="projectFormSection">
           <form id="projectForm" enctype="multipart/form-data" style="margin-top: 15px; border: 1px solid #eee; padding: 10px;">
               <h3>Add/Edit Project</h3>
               <input type="hidden" id="projectEditIndex" value="-1">
               
               <label for="projectId">Project ID (Unique, for linking, e.g., 'uav-deterrence'):</label>
               <input type="text" id="projectId" required>
               
               <label for="projectTitle">Title:</label>
               <input type="text" id="projectTitle" required>
               
               <label for="projectFile">Upload New Project Image (Optional):</label>
               <input type="file" id="projectFile" name="uploadedImage" accept="image/jpeg, image/png, image/gif, image/webp, image/heic, image/heif, .heic, .heif, image/*">
               <input type="hidden" id="currentProjectImage">
               <input type="hidden" id="projectFullWidth">
               <input type="hidden" id="projectFullHeight">
               <p style="font-size: 0.8em; margin-top: -5px;">Leave empty if not changing the image.</p>
               
               <label for="projectSummary">Summary (Short, for card):</label>
               <textarea id="projectSummary" rows="3"></textarea>
               
               <label for="projectCvSummary">CV Summary (short for CV display):</label>
               <textarea id="projectCvSummary" rows="3" placeholder="Optional: specific summary for CV. If empty, will use general summary."></textarea>
               
               <label for="projectRole">My Role:</label>
               <textarea id="projectRole" rows="3"></textarea>
               
               <label for="projectSkills">Skills (comma-separated):</label>
               <input type="text" id="projectSkills">
               
               <label>Project Links:</label>
               <div id="projectLinksContainer" style="padding: 10px; border: 1px solid #eee; margin-bottom: 10px;">
                 <!-- Link rows will be dynamically added here -->
                 <p id="noLinksMsg" style="color: #888;">No links added yet.</p>
               </div>
               <button type="button" id="addProjectLinkButton" style="margin-bottom: 15px;">+ Add Link</button>
               
               <label for="projectStatus">Status:</label>
               <input type="text" id="projectStatus">
               
               <label>
                 <input type="checkbox" id="projectShowOnCv" checked>
                 Show on CV
               </label>
               
               <label for="projectDetailMarkdown">Detail Page Content (Markdown):</label>
               <textarea id="projectDetailMarkdown"></textarea>
               
               <button type="submit" id="projectSubmitButton">Add Project</button>
               <button type="button" id="projectCancelButton" style="display: none;">Cancel Edit</button>
           </form>
        </div>
      </section>

      <!-- CV Content Section -->
      <section id="cvContentSection" class="tab-pane">
        <h2>CV Content Management</h2>
        
        <!-- Tab Navigation for CV Sections -->
        <div class="cv-section-tabs">
          <ul class="tab-nav cv-tab-nav">
            <li><a href="#" data-cv-tab="education" class="cv-tab-link active">Education</a></li>
            <li><a href="#" data-cv-tab="work" class="cv-tab-link">Work Experience</a></li>
            <li><a href="#" data-cv-tab="research" class="cv-tab-link">Research</a></li>
            <li><a href="#" data-cv-tab="skills" class="cv-tab-link">Skills</a></li>
            <li><a href="#" data-cv-tab="achievements" class="cv-tab-link">Achievements</a></li>
            <li><a href="#" data-cv-tab="positions" class="cv-tab-link">Positions</a></li>
          </ul>
        </div>
        
        <!-- CV Section Content -->
        <div class="cv-tab-content">
          <!-- Education Section -->
          <div id="cvEducationSection" class="cv-tab-pane active">
            <h3>Manage Education</h3>
            <div class="cv-list-container">
              <table>
                <thead>
                  <tr>
                    <th>Institution</th>
                    <th>Degree</th>
                    <th>Dates</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="educationTableBody"></tbody>
              </table>
            </div>
            <div class="cv-form-container">
              <form id="educationForm" class="cv-form">
                <h4>Add/Edit Education</h4>
                <input type="hidden" id="educationEditIndex" value="-1">
                
                <label for="educationInstitution">Institution:</label>
                <input type="text" id="educationInstitution" required>
                
                <label for="educationDegree">Degree:</label>
                <input type="text" id="educationDegree" required>
                
                <label for="educationHonours">Honours:</label>
                <input type="text" id="educationHonours">
                
                <label for="educationDates">Dates:</label>
                <input type="text" id="educationDates" placeholder="Jan 2020 - Dec 2024">
                
                <div class="form-buttons">
                  <button type="submit" id="educationSubmitButton">Add Entry</button>
                  <button type="button" id="educationCancelButton" style="display: none;">Cancel</button>
                </div>
              </form>
            </div>
          </div>
          
          <!-- Work Experience Section -->
          <div id="cvWorkSection" class="cv-tab-pane">
            <h3>Manage Work Experience</h3>
            <div class="cv-list-container">
              <table>
                <thead>
                  <tr>
                    <th>Title</th>
                    <th>Company</th>
                    <th>Dates</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="workTableBody"></tbody>
              </table>
            </div>
            <div class="cv-form-container">
              <form id="workForm" class="cv-form">
                <h4>Add/Edit Work Experience</h4>
                <input type="hidden" id="workEditIndex" value="-1">
                
                <label for="workTitle">Title:</label>
                <input type="text" id="workTitle" required>
                
                <label for="workCompany">Company:</label>
                <input type="text" id="workCompany" required>
                
                <label for="workDates">Dates:</label>
                <input type="text" id="workDates" placeholder="Jan 2020 - Present">
                
                <label for="workDescription">Description:</label>
                <textarea id="workDescription" rows="5"></textarea>
                
                <label for="workSkills">Skills (comma-separated):</label>
                <input type="text" id="workSkills" list="skillsSuggestions" placeholder="e.g., Python, Project Management, Data Analysis">
                
                <div class="form-buttons">
                  <button type="submit" id="workSubmitButton">Add Entry</button>
                  <button type="button" id="workCancelButton" style="display: none;">Cancel</button>
                </div>
              </form>
            </div>
          </div>
          
          <!-- Research Section -->
          <div id="cvResearchSection" class="cv-tab-pane">
            <h3>Manage Research Experience</h3>
            <div class="cv-list-container">
              <table>
                <thead>
                  <tr>
                    <th>Title</th>
                    <th>Organization</th>
                    <th>Dates</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="researchTableBody"></tbody>
              </table>
            </div>
            <div class="cv-form-container">
              <form id="researchForm" class="cv-form">
                <h4>Add/Edit Research Experience</h4>
                <input type="hidden" id="researchEditIndex" value="-1">
                
                <label for="researchTitle">Title:</label>
                <input type="text" id="researchTitle" required>
                
                <label for="researchOrganization">Organization:</label>
                <input type="text" id="researchOrganization" required>
                
                <label for="researchDates">Dates:</label>
                <input type="text" id="researchDates" placeholder="Jan 2020 - Dec 2021">
                
                <label for="researchDescription">Description:</label>
                <textarea id="researchDescription" rows="5"></textarea>
                
                <label for="researchSkills">Skills (comma-separated):</label>
                <input type="text" id="researchSkills" list="skillsSuggestions" placeholder="e.g., Machine Learning, Data Analysis, Python">
                
                <div class="form-buttons">
                  <button type="submit" id="researchSubmitButton">Add Entry</button>
                  <button type="button" id="researchCancelButton" style="display: none;">Cancel</button>
                </div>
              </form>
            </div>
          </div>
          
          <!-- Skills Section -->
          <div id="cvSkillsSection" class="cv-tab-pane">
            <h3>Manage Skills</h3>
            
            <!-- Manual Add Form -->
            <div class="cv-form-container" style="width: 100%; margin-bottom: 20px;">
              <form id="addSkillForm" class="cv-form">
                <h4>Add New Skill</h4>
                
                <label for="newSkillName">Skill Name:</label>
                <input type="text" id="newSkillName" required placeholder="e.g., Python, Docker">
                
                <label for="newSkillCategory">Category:</label>
                <select id="newSkillCategory">
                  <option value="programming">Programming</option>
                  <option value="software">Software</option>
                  <option value="technical">Technical</option>
                  <option value="uncategorized" selected>Uncategorized</option>
                </select>
                
                <label for="newSkillProjects">Related Projects (optional):</label>
                <input type="text" id="newSkillProjects" placeholder="Comma-separated project IDs">
                
                <div class="form-buttons">
                  <button type="submit" id="addSkillButton">Add Skill</button>
                </div>
              </form>
            </div>
            
            <!-- Drag and Drop Zones -->
            <div id="skillsContainers">
              <div id="programmingSkills" class="category-box">
                <h4>Programming</h4>
                <div class="skills-list sortable"></div>
              </div>
              
              <div id="softwareSkills" class="category-box">
                <h4>Software</h4>
                <div class="skills-list sortable"></div>
              </div>
              
              <div id="technicalSkills" class="category-box">
                <h4>Technical</h4>
                <div class="skills-list sortable"></div>
              </div>
              
              <div id="uncategorizedSkills" class="category-box">
                <h4>Uncategorized (Not shown on CV)</h4>
                <div class="skills-list sortable"></div>
              </div>
            </div>
          </div>
          
          <!-- Achievements Section -->
          <div id="cvAchievementsSection" class="cv-tab-pane">
            <h3>Manage Achievements</h3>
            <div class="cv-list-container">
              <table>
                <thead>
                  <tr>
                    <th>Achievement</th>
                    <th>Year</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="achievementsTableBody"></tbody>
              </table>
            </div>
            <div class="cv-form-container">
              <form id="achievementsForm" class="cv-form">
                <h4>Add/Edit Achievement</h4>
                <input type="hidden" id="achievementsEditIndex" value="-1">
                
                <label for="achievementTitle">Achievement:</label>
                <input type="text" id="achievementTitle" required>
                
                <label for="achievementYear">Year:</label>
                <input type="text" id="achievementYear" placeholder="2021">
                
                <div class="form-buttons">
                  <button type="submit" id="achievementsSubmitButton">Add Entry</button>
                  <button type="button" id="achievementsCancelButton" style="display: none;">Cancel</button>
                </div>
              </form>
            </div>
          </div>
          
          <!-- Positions Section -->
          <div id="cvPositionsSection" class="cv-tab-pane">
            <h3>Manage Positions</h3>
            <div class="cv-list-container">
              <table>
                <thead>
                  <tr>
                    <th>Title</th>
                    <th>Organization</th>
                    <th>Dates</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="positionsTableBody"></tbody>
              </table>
            </div>
            <div class="cv-form-container">
              <form id="positionsForm" class="cv-form">
                <h4>Add/Edit Position</h4>
                <input type="hidden" id="positionsEditIndex" value="-1">
                
                <label for="positionTitle">Title:</label>
                <input type="text" id="positionTitle" required>
                
                <label for="positionOrganization">Organization:</label>
                <input type="text" id="positionOrganization" required>
                
                <label for="positionDates">Dates:</label>
                <input type="text" id="positionDates" placeholder="Jan 2020 - Present">
                
                <label for="positionDescription">Description:</label>
                <textarea id="positionDescription" rows="5"></textarea>
                
                <div class="form-buttons">
                  <button type="submit" id="positionsSubmitButton">Add Entry</button>
                  <button type="button" id="positionsCancelButton" style="display: none;">Cancel</button>
                </div>
              </form>
            </div>
          </div>
        </div>
      </section>

      <!-- Trip Management Section -->
      <section id="tripManagementSection" class="tab-pane">
        <h2>Manage Trips</h2>
        <table style="width:100%; margin-bottom:10px;">
          <thead><tr><th>Trip Name</th><th>Date Range</th><th>Trip ID</th><th>Actions</th></tr></thead>
          <tbody id="tripTableBody"></tbody>
        </table>
        <hr>
        <form id="tripForm">
          <h4 id="tripFormTitle">Add New Trip</h4>
          <input type="hidden" id="tripEditIndex" value="-1">

          <label for="tripName">Trip Name:</label>
          <input type="text" id="tripName" required>

          <label for="tripDateRange">Date Range (e.g., Jul 2023):</label>
          <input type="text" id="tripDateRange">

          <label for="tripId">Trip ID (Unique, no spaces/special chars):</label>
          <input type="text" id="tripId" required title="Use only letters, numbers, hyphens, underscores">

          <button type="submit" id="tripSubmitButton">Add Trip</button>
          <button type="button" id="tripCancelButton" style="display: none;">Cancel Edit</button>
        </form>
      </section>

      <!-- Research Content Section -->
      <section id="researchContentSection" class="tab-pane">
        <h2>Edit Research Page Content</h2>
        
        <!-- Journal Articles Subsection -->
        <div class="research-admin-subsection">
          <h3>Journal Articles</h3>
          <table style="width:100%; margin-bottom:10px;">
            <thead>
              <tr>
                <th>Title</th>
                <th>Venue</th>
                <th>Date</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="researchJournalTableBody"></tbody>
          </table>
          <button type="button" class="admin-add-button" onclick="showResearchEntryForm('journal')">+ Add Journal Article</button>
          
          <!-- Journal Article Form (Initially Hidden) -->
          <form id="researchJournalForm" class="admin-entry-form" style="display:none; margin-top: 15px; padding: 15px; border: 1px solid #ddd; background-color: #f9f9f9;">
            <h4>Journal Article Details</h4>
            <input type="hidden" id="journalEditIndex" value="-1">
            
            <label for="journalId">ID (used for anchors, e.g., 'uav-paper'):</label>
            <input type="text" id="journalId" required>
            
            <label for="journalTitle">Title:</label>
            <input type="text" id="journalTitle" required>
            
            <label for="journalAuthors">Authors (use **Finn Wilson** for your name):</label>
            <input type="text" id="journalAuthors" required>
            
            <label for="journalVenue">Venue (journal name):</label>
            <input type="text" id="journalVenue" required>
            
            <label for="journalDate">Date:</label>
            <input type="text" id="journalDate" placeholder="YYYY">
            
            <label for="journalAbstract">Abstract:</label>
            <textarea id="journalAbstract" rows="6"></textarea>
            
            <label>Links:</label>
            <div id="journalLinksContainer" style="padding: 10px; border: 1px solid #eee; margin-bottom: 10px;">
              <!-- Link rows will be dynamically added here -->
              <p id="journalNoLinksMsg" style="color: #888;">No links added yet.</p>
            </div>
            <button type="button" id="addJournalLinkButton" style="margin-bottom: 15px;">+ Add Link</button>
            
            <div style="margin-top: 15px;">
              <button type="submit" id="journalSubmitButton">Save Article</button>
              <button type="button" id="journalCancelButton">Cancel</button>
            </div>
          </form>
        </div>
        
        <!-- Thesis Subsection -->
        <div class="research-admin-subsection" style="margin-top: 20px; padding-top: 15px; border-top: 1px dashed #ccc;">
          <h3>Thesis</h3>
          <form id="researchThesisForm" style="margin-top: 15px; padding: 15px; border: 1px solid #ddd; background-color: #f9f9f9;">
            <h4>Edit Thesis Details</h4>
            
            <label for="thesisTitle">Title:</label>
            <input type="text" id="thesisTitle" required>
            
            <label for="thesisAuthors">Authors (use **Finn Wilson** for your name):</label>
            <input type="text" id="thesisAuthors" required>
            
            <label for="thesisVenue">Venue (degree/institution):</label>
            <input type="text" id="thesisVenue" required>
            
            <label for="thesisDate">Date:</label>
            <input type="text" id="thesisDate" placeholder="YYYY">
            
            <label for="thesisAbstract">Abstract:</label>
            <textarea id="thesisAbstract" rows="6"></textarea>
            
            <label>Links:</label>
            <div id="thesisLinksContainer" style="padding: 10px; border: 1px solid #eee; margin-bottom: 10px;">
              <!-- Link rows will be dynamically added here -->
              <p id="thesisNoLinksMsg" style="color: #888;">No links added yet.</p>
            </div>
            <button type="button" id="addThesisLinkButton" style="margin-bottom: 15px;">+ Add Link</button>
            
            <div style="margin-top: 15px;">
              <button type="button" id="saveThesisButton">Save Thesis</button>
            </div>
          </form>
        </div>
        
        <!-- Conference Papers Subsection -->
        <div class="research-admin-subsection" style="margin-top: 20px; padding-top: 15px; border-top: 1px dashed #ccc;">
          <h3>Conference Papers</h3>
          <table style="width:100%; margin-bottom:10px;">
            <thead>
              <tr>
                <th>Title</th>
                <th>Venue</th>
                <th>Date</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="researchConferenceTableBody"></tbody>
          </table>
          <button type="button" class="admin-add-button" onclick="showResearchEntryForm('conference')">+ Add Conference Paper</button>
          
          <!-- Conference Paper Form (Initially Hidden) -->
          <form id="researchConferenceForm" class="admin-entry-form" style="display:none; margin-top: 15px; padding: 15px; border: 1px solid #ddd; background-color: #f9f9f9;">
            <h4>Conference Paper Details</h4>
            <input type="hidden" id="conferenceEditIndex" value="-1">
            
            <label for="conferenceId">ID (used for anchors, e.g., 'acfr-paper'):</label>
            <input type="text" id="conferenceId" required>
            
            <label for="conferenceTitle">Title:</label>
            <input type="text" id="conferenceTitle" required>
            
            <label for="conferenceAuthors">Authors (use **Finn Wilson** for your name):</label>
            <input type="text" id="conferenceAuthors" required>
            
            <label for="conferenceVenue">Venue (conference name):</label>
            <input type="text" id="conferenceVenue" required>
            
            <label for="conferenceDate">Date:</label>
            <input type="text" id="conferenceDate" placeholder="YYYY">
            
            <label for="conferenceAbstract">Abstract:</label>
            <textarea id="conferenceAbstract" rows="6"></textarea>
            
            <label>Links:</label>
            <div id="conferenceLinksContainer" style="padding: 10px; border: 1px solid #eee; margin-bottom: 10px;">
              <!-- Link rows will be dynamically added here -->
              <p id="conferenceNoLinksMsg" style="color: #888;">No links added yet.</p>
            </div>
            <button type="button" id="addConferenceLinkButton" style="margin-bottom: 15px;">+ Add Link</button>
            
            <div style="margin-top: 15px;">
              <button type="submit" id="conferenceSubmitButton">Save Paper</button>
              <button type="button" id="conferenceCancelButton">Cancel</button>
            </div>
          </form>
        </div>
        
        <!-- Patents Subsection -->
        <div class="research-admin-subsection" style="margin-top: 20px; padding-top: 15px; border-top: 1px dashed #ccc;">
          <h3>Patents</h3>
          <table style="width:100%; margin-bottom:10px;">
            <thead>
              <tr>
                <th>Title</th>
                <th>Status</th>
                <th>Date</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="researchPatentTableBody"></tbody>
          </table>
          <button type="button" class="admin-add-button" onclick="showResearchEntryForm('patent')">+ Add Patent</button>
          
          <!-- Patent Form (Initially Hidden) -->
          <form id="researchPatentForm" class="admin-entry-form" style="display:none; margin-top: 15px; padding: 15px; border: 1px solid #ddd; background-color: #f9f9f9;">
            <h4>Patent Details</h4>
            <input type="hidden" id="patentEditIndex" value="-1">
            
            <label for="patentId">ID (used for anchors, e.g., 'mining-patent'):</label>
            <input type="text" id="patentId" required>
            
            <label for="patentTitle">Title:</label>
            <input type="text" id="patentTitle" required>
            
            <label for="patentAuthors">Authors/Inventors (use **Finn Wilson** for your name):</label>
            <input type="text" id="patentAuthors" required>
            
            <label for="patentVenue">Status (e.g., "Status: Patent Application Filed"):</label>
            <input type="text" id="patentVenue" required>
            
            <label for="patentDate">Date:</label>
            <input type="text" id="patentDate" placeholder="YYYY">
            
            <label for="patentAbstract">Abstract:</label>
            <textarea id="patentAbstract" rows="6"></textarea>
            
            <label>Links:</label>
            <div id="patentLinksContainer" style="padding: 10px; border: 1px solid #eee; margin-bottom: 10px;">
              <!-- Link rows will be dynamically added here -->
              <p id="patentNoLinksMsg" style="color: #888;">No links added yet.</p>
            </div>
            <button type="button" id="addPatentLinkButton" style="margin-bottom: 15px;">+ Add Link</button>
            
            <div style="margin-top: 15px;">
              <button type="submit" id="patentSubmitButton">Save Patent</button>
              <button type="button" id="patentCancelButton">Cancel</button>
            </div>
          </form>
        </div>
      </section>

      <!-- Contact Details Section -->
      <section id="contactDetailsSection" class="tab-pane">
        <h2>Manage Contact Details</h2>
        
        <!-- Header Text Section -->
        <div style="margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9;">
          <h3>Email/Phone Header Text</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 10px;">This text appears above the social media icons in the contact banner.</p>
          
          <label for="contactHeaderText">Header Text:</label>
          <textarea id="contactHeaderText" rows="2" placeholder="Email: example@domain.com | Phone: +1 (555) 123-4567" style="width: 100%; margin-bottom: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px;"></textarea>
          
          <button id="saveHeaderBtn" style="background: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">Save Header</button>
        </div>
        
        <div style="margin-bottom: 20px;">
          <h3>Contact Banner Items</h3>
          <table class="sortable" style="width: 100%; margin-bottom: 20px;">
            <thead>
              <tr>
                <th style="width: 30px;">Drag</th>
                <th style="width: 60px;">Icon</th>
                <th>Link</th>
                <th style="width: 120px;">Actions</th>
              </tr>
            </thead>
            <tbody id="contactTableBody">
              <!-- Contact items will be loaded here -->
            </tbody>
          </table>
        </div>
        
        <div class="cv-form-container">
          <form id="contactForm" class="cv-form">
            <h4>Add/Edit Contact Item</h4>
            <input type="hidden" id="contactEditIndex" value="-1">
            
            <label for="contactIconUpload">Icon (SVG/PNG recommended):</label>
            <input type="file" id="contactIconUpload" accept="image/*,.svg">
            
            <label for="contactLink">Link URL:</label>
            <input type="text" id="contactLink" placeholder="https://example.com" required>
            
            <label for="contactLabel">Label (optional):</label>
            <input type="text" id="contactLabel" placeholder="e.g., LinkedIn, GitHub">
            
            <div class="form-buttons">
              <button type="submit" id="contactSubmitButton">Add Contact Item</button>
              <button type="button" id="contactCancelButton" style="display: none;">Cancel</button>
            </div>
          </form>
        </div>
      </section>

      <!-- Homepage Content Section -->
      <section id="homepageSection" class="tab-pane">
        <h2>Edit Homepage</h2>
        
        <!-- Homepage Image Section -->
        <div style="margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9;">
          <h3>Homepage Image</h3>
          <p style="font-size: 0.9rem; color: #666; margin-bottom: 10px;">Upload an image to display at the top of the homepage (above the content).</p>
          
          <div style="margin-bottom: 15px;">
            <label for="homepageImageUpload">Choose Image:</label>
            <input type="file" id="homepageImageUpload" accept="image/*" style="margin-bottom: 10px;">
            <button id="uploadImageBtn" style="background: #17a2b8; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">Upload Image</button>
          </div>
          
          <div id="currentImageContainer" style="margin-top: 15px;">
            <label>Current Image:</label>
            <div id="currentImagePreview" style="margin-top: 5px;">
              <img id="currentImage" src="" style="max-width: 200px; max-height: 150px; border: 1px solid #ddd; border-radius: 4px; display: none;">
              <p id="noImageText" style="color: #666; font-style: italic;">No image uploaded</p>
            </div>
          </div>
        </div>

        <!-- Homepage Content Section -->
        <div style="margin-bottom: 20px;">
          <h3>Homepage Content (Markdown)</h3>
          <p>Edit the homepage content using Markdown syntax. Changes will be reflected on the main homepage.</p>
          
          <div style="margin-bottom: 15px;">
            <label for="homepageContent">Homepage Content:</label>
            <textarea id="homepageContent" rows="20" style="width: 100%; font-family: monospace; padding: 10px; border: 1px solid #ddd; border-radius: 4px;" placeholder="Enter Markdown content here..."></textarea>
          </div>
          
          <div style="margin-bottom: 15px;">
            <button id="saveHomepage" style="background: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 4px; margin-right: 10px; cursor: pointer;">Save Content</button>
            <button id="previewHomepage" style="background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">Preview</button>
          </div>
          
          <div id="homepagePreview" style="border: 1px solid #ddd; padding: 15px; background: #f9f9f9; border-radius: 4px; min-height: 100px; display: none;">
            <h4>Preview:</h4>
            <div id="homepagePreviewContent"></div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- Datalist for skills autocomplete -->
  <datalist id="skillsSuggestions"></datalist>

  <script src="https://unpkg.com/easymde/dist/easymde.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
  <script src="js/admin.js"></script>
</body>
</html>-e 
```
-e 
### ./bookshelf.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Finn Wilson - Bookshelf</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/bookshelf.css" />
</head>
<body>
  <header></header>

  <main class="container">
    <section id="bookshelf-section">
      <h2>bookshelf</h2>
      <div id="filters">
        <select id="genreFilter">
          <option value="all">all genres</option>
        </select>
        <select id="ratingFilter">
          <option value="all">all ratings</option>
          <option value="5">★★★★★</option>
          <option value="4">★★★★☆</option>
          <option value="3">★★★☆☆</option>
          <option value="2">★★☆☆☆</option>
          <option value="1">★☆☆☆☆</option>
        </select>
        <select id="sortOrder">
          <option value="date-desc">newest first</option>
          <option value="date-asc">oldest first</option>
          <option value="rating-desc">highest rated</option>
          <option value="rating-asc">lowest rated</option>
        </select>
      </div>
      <div id="books-row" class="books-row"></div>
      <div id="bookshelf"></div>
    </section>
  </main>

  <footer id="footer"></footer>

  <div id="reviewOverlay">
    <div id="overlayContent">
      <button id="closeOverlay">&times;</button>
      <h2 id="overlayTitle"></h2>
      <h3 id="overlayAuthor"></h3>
      <p id="overlayDetails"></p>
      <div id="overlayReviewText"></div>
    </div>
  </div>

  <script src="js/script.js"></script>
  <script src="js/bookshelf.js"></script>
</body>
</html>
-e 
```
-e 
### ./build/tools/gen_thumbs.js

```js
// build/tools/gen_thumbs.js
const fs    = require('fs').promises;
const path  = require('path');
const sharp = require('sharp');

// Configure persistent storage paths
const persistPath = process.env.PERSIST_PATH || path.resolve(__dirname, '../..');  // Fallback for local dev
const IMG_DIR   = path.join(persistPath, 'img');
const THUMB_DIR = path.join(persistPath, 'thumbs');
const SIZE      = 96;            // px

(async () => {
  await fs.mkdir(THUMB_DIR, {recursive: true});
  const files = await fs.readdir(IMG_DIR);

  let created = 0;
  for (const f of files) {
    // Skip non-image files and Zone.Identifier files
    if (f.includes('Zone.Identifier') || f.includes('.attrs')) {
      continue;
    }

    const src = path.join(IMG_DIR, f);
    const dst = path.join(THUMB_DIR, f);
    try {
      await fs.access(dst);          // exists → skip
      process.stdout.write('s');     // skipped (thumbnail exists)
    } catch (_) {
      try {
        // Get file stats to ensure it's a regular file
        const stats = await fs.stat(src);
        if (!stats.isFile()) {
          continue; // Skip directories or special files
        }

        await sharp(src).resize(SIZE, SIZE, {fit:'inside'}).toFile(dst);
        created++;
        process.stdout.write('.');   // progress dot
      } catch (err) {
        // Skip files that cause errors (e.g., non-image files)
        process.stdout.write('e');   // error indicator
        console.error(`\nError processing ${f}: ${err.message}`);
      }
    }
  }
  console.log(`\n${created} thumbnails created (out of ${files.length} files).`);
})().catch(e => { console.error(e); process.exit(1); });-e 
```
-e 
### ./css/admin.css

```css
/* admin.css */

/* Rotate buttons */
.rotL,.rotR{
    border: none;
    background: #3a7bd5;
    color: white;
    cursor: pointer;
    font-size: 1.2em;
    padding: 3px 8px;
    margin-right: 5px;
    border-radius: 3px;
}

.rotL:hover,.rotR:hover{
    background: #2a6bc5;
}

/* Drag and drop styling for photo reordering */
.photo-list-row {
    cursor: grab; /* Indicate draggable */
}

.photo-list-row:active {
    cursor: grabbing; /* Indicate dragging */
}

.photo-list-row.dragging {
    opacity: 0.6; /* Make the dragged element semi-transparent */
}

.photo-list-row.dragging-over {
    background-color: #e0f0ff; /* Highlight drop target */
    border-top: 2px solid #99caff;
}

/* General sortable row styling */
.sortable-row {
    cursor: grab;
}

.sortable-row:active {
    cursor: grabbing;
    opacity: 0.6;
}

.sortable-row.dragging-over {
    background-color: #e0f0ff;
    border-top: 2px solid #99caff;
}

/* Drag handle styling */
.drag-handle {
    cursor: move;
    width: 20px;
    text-align: center;
    color: #666;
    font-size: 1.2em;
    padding: 5px;
}

.drag-handle:hover {
    color: #333;
}

/* Small button styling for admin interface */
.admin-small-button {
    margin-left: 15px;
    padding: 2px 6px;
    font-size: 0.8em;
    cursor: pointer;
}

/* General styles */
body {
  padding: 20px;
  font-family: Arial, sans-serif;
}

h1, h2, h3, h4 {
  margin-top: 1em;
  color: #333;
}

/* Admin warning box */
.admin-warning {
  background-color: #ffeeee;
  border: 1px solid #ffaaaa;
  padding: 15px;
  margin-bottom: 20px;
  border-radius: 4px;
}

/* Table styles */
table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 20px;
}

table, th, td {
  border: 1px solid #ddd;
}

th, td {
  padding: 10px;
  text-align: left;
}

th {
  background-color: #f0f0f0;
}

/* Form styles */
input, textarea, select {
  display: block;
  width: 100%;
  margin-bottom: 10px;
  padding: 8px;
  box-sizing: border-box;
  border: 1px solid #ddd;
}

button {
  padding: 8px 15px;
  background-color: #3a7bd5;
  color: white;
  border: none;
  cursor: pointer;
  margin-right: 5px;
  margin-bottom: 5px;
  border-radius: 3px;
}

button:hover {
  background-color: #2a6bc5;
}

button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

/* Login section */
#loginSection {
  max-width: 400px;
  margin: 0 auto;
  padding: 20px;
  background-color: #f9f9f9;
  border-radius: 5px;
  border: 1px solid #ddd;
}

/* Tab styles */
.admin-tabs {
  position: relative;
  border: none;
  margin-bottom: 0;
}

/* Create the horizontal line that goes under tabs */
.admin-tabs::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  height: 1px;
  background: #ccc;
  z-index: 1;
}

ul.tab-nav {
  list-style: none;
  padding: 0;
  margin: 0;
  margin-bottom: 0;
  display: flex; /* Arrange tabs horizontally */
  flex-wrap: nowrap; /* Prevent wrapping */
  overflow-x: auto; /* Add horizontal scroll when needed */
  white-space: nowrap; /* Keep tabs on single line */
}

ul.tab-nav li {
  margin-right: 5px;
  margin-bottom: -1px; /* Overlap with the border line */
  flex: 0 0 auto; /* Prevent shrinking and maintain size */
}

a.tab-link {
  display: inline-block;
  position: relative;
  padding: 10px 15px;
  text-decoration: none;
  color: #007bff;
  border: 1px solid transparent;
  border-bottom: none;
  border-radius: 4px 4px 0 0; /* Rounded top corners */
  background-color: #f8f9fa; /* Light background for inactive tabs */
  z-index: 1; /* Below active tab but above line */
}

a.tab-link:hover {
  background-color: #e9ecef; /* Slightly darker on hover */
  color: #0056b3;
}

/* Active tab styling */
a.tab-link.active {
  background-color: #fff; /* White background for active tab */
  border: 1px solid #ccc; /* Full border */
  border-bottom: 1px solid #fff; /* White bottom border to cover the line */
  color: #495057;
  font-weight: bold;
  z-index: 2; /* Above the line and other tabs */
  bottom: -1px; /* Move down to overlap the line */
}

/* Content pane visibility */
.tab-content {
  padding: 20px;
  border: 1px solid #ccc;
  border-top: none; /* Remove top border to avoid double line */
  background-color: #fff;
}

.tab-pane {
  display: none; /* Hide inactive panes by default */
}

.tab-pane.active {
  display: block; /* Show the active pane */
}

/* Section styling (no longer needed as separators) */
section {
  margin-top: 0;
  padding-top: 0;
  border-top: none;
}

/* Form containers */
#bookForm, #photoForm, #projectForm {
  background-color: #f9f9f9;
  padding: 15px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-top: 20px;
}

/* Output JSON area */
.output-json {
  width: 100%;
  min-height: 150px;
  margin-top: 10px;
  display: none; /* Hide initially */
  background-color: #e9e9e9;
  font-family: monospace;
  font-size: 0.9em;
  box-sizing: border-box;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

/* Readonly input styling */
input[readonly], textarea[readonly] {
  background-color: #eee;
  cursor: not-allowed;
}

/* Save blocks */
.save-block {
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px dashed #ccc;
}

.save-block:last-child {
  border-bottom: none;
}

/* CV Content Section Styles */
.cv-section-tabs {
  position: relative;
  margin: 15px 0 0 0;
}

/* Create the horizontal line that goes under CV tabs */
.cv-section-tabs::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  height: 1px;
  background: #ddd;
  z-index: 1;
}

ul.cv-tab-nav {
  margin: 0;
  padding: 0;
  margin-bottom: 0;
  list-style: none;
  display: flex;
  flex-wrap: wrap;
}

ul.cv-tab-nav li {
  margin-right: 2px;
  margin-bottom: -1px; /* Overlap with the border line */
}

a.cv-tab-link {
  display: inline-block;
  position: relative;
  padding: 8px 12px;
  text-decoration: none;
  color: #007bff;
  border: 1px solid transparent;
  border-bottom: none;
  border-radius: 4px 4px 0 0;
  background-color: #f8f9fa;
  font-size: 0.9em;
  z-index: 1; /* Below active tab but above line */
}

a.cv-tab-link:hover {
  background-color: #e9ecef;
  color: #0056b3;
}

a.cv-tab-link.active {
  background-color: #fff;
  border: 1px solid #ddd; /* Full border */
  border-bottom: 1px solid #fff; /* White bottom border to cover the line */
  color: #495057;
  font-weight: bold;
  z-index: 2; /* Above the line and other tabs */
  bottom: -1px; /* Move down to overlap the line */
}

.cv-tab-pane {
  display: none;
  padding: 15px;
  border: 1px solid #ddd;
  border-top: none; /* Remove top border to avoid double line */
  margin-bottom: 20px;
}

.cv-tab-pane.active {
  display: block;
}

.cv-list-container {
  margin-bottom: 20px;
}

.cv-form-container {
  width: 100%;
}

.cv-form {
  background-color: #f9f9f9;
  padding: 15px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.form-buttons {
  margin-top: 15px;
}

/* Responsive adjustments for CV tabs */
@media (max-width: 768px) {
  ul.cv-tab-nav {
    flex-direction: column;
  }
  
  ul.cv-tab-nav li {
    margin-bottom: 2px;
    margin-right: 0;
  }
  
  a.cv-tab-link {
    width: 100%;
    box-sizing: border-box;
    border-radius: 4px;
    margin-bottom: 5px;
  }
  
  a.cv-tab-link.active {
    bottom: 0; /* Reset overlap on mobile */
    border-bottom-color: #ddd; /* Show full border on mobile */
  }
  
  /* Hide the pseudo-element line on mobile */
  .cv-section-tabs::after {
    display: none;
  }
  
  .cv-tab-pane {
    border-top: 1px solid #ddd; /* Add top border back on mobile */
  }
}

/* EasyMDE Toolbar Visibility Fix */
.editor-toolbar button,
.editor-toolbar a {
    color: #333 !important;
    opacity: 1 !important;
}

.editor-toolbar button:hover,
.editor-toolbar a:hover,
.editor-toolbar a.active {
    color: #000 !important;
    background-color: #e9ecef !important;
    border-color: #ccc !important;
}

/* Target FontAwesome icons used within buttons */
.editor-toolbar button i.fa,
.editor-toolbar a i.fa {
    color: #333 !important;
    opacity: 1 !important;
}

/* Style for separator */
.editor-toolbar i.separator {
    border-left: 1px solid #ddd !important;
    border-right: 1px solid #f9f9f9 !important;
}

/* Loading Indicator Styles */
#loadingIndicator {
    display: none; 
    align-items: center;
    justify-content: center;
    padding: 15px;
    background-color: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-bottom: 15px;
    text-align: center;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

#loadingIndicator div {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(0, 123, 255, 0.3);
    border-radius: 50%;
    border-top-color: #007bff;
    animation: spin 1s linear infinite;
    margin-right: 10px;
}

/* Notification Styles */
#adminNotifications {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 1050;
    max-width: 300px;
}

.notification {
    padding: 10px 30px 10px 15px;
    margin-bottom: 10px;
    border-radius: 4px;
    position: relative;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.notification.success {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.notification.error {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
}

.notification.info {
    background-color: #d1ecf1;
    color: #0c5460;
    border: 1px solid #bee5eb;
}

.notification.warning {
    background-color: #fff3cd;
    color: #856404;
    border: 1px solid #ffeeba;
}

/* Research Admin Subsection Styles */
.research-admin-subsection {
    margin: 20px 0;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #fafafa;
}

.research-admin-subsection h3 {
    margin-top: 0;
    color: #333;
    border-bottom: 1px solid #ddd;
    padding-bottom: 10px;
}

.admin-entry-form {
    margin-top: 15px;
    padding: 15px;
    border: 1px solid #ddd;
    background-color: #f9f9f9;
    border-radius: 4px;
}

.admin-add-button {
    background-color: #28a745;
    color: white;
    border: none;
    padding: 8px 15px;
    cursor: pointer;
    border-radius: 3px;
    margin-bottom: 10px;
}

.admin-add-button:hover {
    background-color: #218838;
}

/* Skill Box Styles */
.category-box {
    border: 1px dashed #ccc;
    padding: 10px;
    margin: 10px;
    min-height: 100px;
    border-radius: 4px;
    background-color: #fafafa;
}

.category-box h4 {
    margin-top: 0;
    margin-bottom: 10px;
    color: #333;
}

.skills-list {
    min-height: 60px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.skill-box {
    background: #f0f0f0;
    padding: 5px 10px;
    margin: 5px;
    cursor: grab;
    border-radius: 3px;
    border: 1px solid #ddd;
    display: inline-block;
    font-size: 0.9em;
}

.skill-box:hover {
    background: #e8e8e8;
    border-color: #999;
}

.skill-box:active {
    cursor: grabbing;
    opacity: 0.6;
}

.skill-box.sortable-ghost {
    opacity: 0.4;
}

.skill-box.sortable-chosen {
    background: #d0e0f0;
}

/* Skills container layout */
#skillsContainers {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
}

@media (max-width: 768px) {
    #skillsContainers {
        grid-template-columns: 1fr;
    }
}

/* Color-coded skill boxes */
.skill-derived {
    background: #d0eaff;
    border-color: #9ec8ff;
}

.skill-derived:hover {
    background: #b5deff;
    border-color: #7ab8ff;
}

.skill-manual {
    background: #d4edda;
    border-color: #b1dfbb;
}

.skill-manual:hover {
    background: #c1e9cc;
    border-color: #95d4a4;
}

/* Role-only skills (from work/research) */
.skill-role-only {
    background: #ffd0d0;
    border-color: #ffb0b0;
}

.skill-role-only:hover {
    background: #ffb5b5;
    border-color: #ff9595;
}

/* Responsive adjustments for admin tabs on narrow screens */
@media (max-width: 768px) {
  ul.tab-nav {
    padding: 0;
    margin: 0;
    margin-bottom: 0;
  }
  
  ul.tab-nav li {
    flex: 0 0 auto;
    margin-right: 2px;
  }
  
  a.tab-link {
    padding: 8px 12px;
    font-size: 0.9em;
    border-radius: 4px 4px 0 0;
  }
  
  a.tab-link.active {
    border-radius: 4px 4px 0 0;
  }
}-e 
```
-e 
### ./css/bookshelf.css

```css
/* bookshelf.css */

/* bookshelf container with extra bottom padding so books don't overlap footer */
#bookshelf {
    padding: 2rem 0 100px;
  }
  
  /* container for each row of books */
  .books-row {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-bottom: 2rem;
  }

  /* book card styles for new card layout */
  .book-card {
    width: 250px;
    min-height: 320px;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 15px;
    background: white;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
  }

  .book-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-color: #007bff;
  }

  .book-card-content {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  .book-card .book-title {
    font-size: 1.2rem;
    font-weight: bold;
    margin: 0 0 0.5rem 0;
    color: #333;
    line-height: 1.3;
    min-height: 2.6rem;
  }

  .book-card .book-author {
    font-size: 1rem;
    color: #666;
    margin: 0 0 1rem 0;
    font-style: italic;
  }

  .book-card .book-rating {
    font-size: 1.1rem;
    color: #ffa500;
    margin: 0.5rem 0;
  }

  .book-card .book-genre {
    font-size: 0.9rem;
    color: #888;
    margin: 0.5rem 0 0 0;
    flex: 1;
    display: flex;
    align-items: flex-end;
  }

  /* Filter styles */
  #filters {
    margin-bottom: 2rem;
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    align-items: center;
  }

  #filters select {
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
    font-size: 1rem;
    min-width: 120px;
  }
  
  /* shelf bar for a realistic wood shelf */
  .shelf-bar {
    height: 10px;
    background: #8b5a2b;
    margin-bottom: 20px;
  }
  
  /* book dimensions (doubled) */
  .book {
    width: 80px;
    height: 240px;
    background-color: #ddd;
    position: relative;
    cursor: pointer;
    flex-shrink: 0;
    overflow: hidden;
  }
  
  /* rotated spine text, centered in the book frame */
  .book-spine {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-90deg);
    width: 240px; /* equal to book height */
    padding: 5px; /* increased padding */
    box-sizing: border-box; /* include padding in width */
    text-align: center;
    white-space: normal;
    font-size: 1rem;
    line-height: 1.2;
  }
  
  
  /* review overlay (unchanged) */
  #reviewOverlay {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: #fff !important;
    opacity: 0 !important;
    visibility: hidden !important;
    transition: opacity 0.5s ease !important;
    overflow: auto !important;
    z-index: 999 !important;
  }
  #reviewOverlay.open {
    opacity: 1 !important;
    visibility: visible !important;
  }
  
  #reviewOverlay.open {
    opacity: 1;
    visibility: visible;
  }
  #overlayContent {
    max-width: 600px;
    margin: 3rem auto;
    padding: 1.5rem;
    position: relative;
  }
  #closeOverlay {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: none;
    border: none;
    font-size: 2rem;
    line-height: 1;
    cursor: pointer;
    color: #333;
  }
  #overlayReviewText {
    white-space: pre-line;
  }

  /* Updated overlay styles for card layout */
  #reviewOverlay {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: rgba(0, 0, 0, 0.7) !important;
    display: none !important;
    z-index: 1000 !important;
    overflow: auto !important;
  }

  #overlayContent {
    max-width: 700px !important;
    margin: 3rem auto !important;
    padding: 2rem !important;
    background: white !important;
    border-radius: 8px !important;
    position: relative !important;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3) !important;
  }

  #closeOverlay {
    position: absolute !important;
    top: 1rem !important;
    right: 1rem !important;
    background: none !important;
    border: none !important;
    font-size: 2rem !important;
    line-height: 1 !important;
    cursor: pointer !important;
    color: #333 !important;
    padding: 0 !important;
    width: 2rem !important;
    height: 2rem !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }

  #closeOverlay:hover {
    background: #f0f0f0 !important;
    border-radius: 50% !important;
  }

  #overlayTitle {
    margin: 0 0 0.5rem 0 !important;
    font-size: 1.8rem !important;
    color: #333 !important;
  }

  #overlayAuthor {
    margin: 0 0 1rem 0 !important;
    font-size: 1.2rem !important;
    color: #666 !important;
    font-style: italic !important;
  }

  #overlayDetails {
    margin: 0 0 1.5rem 0 !important;
    font-size: 1rem !important;
    color: #555 !important;
    padding: 1rem !important;
    background: #f8f9fa !important;
    border-radius: 4px !important;
  }

  #overlayReviewText {
    white-space: pre-line !important;
    line-height: 1.6 !important;
    font-size: 1rem !important;
    color: #333 !important;
  }
  -e 
```
-e 
### ./css/photography.css

```css
/* Photography Page Styles */

/* View Toggle Button Styles */
.toggle-button {
  position: fixed;
  top: 80px;
  right: 10px;
  background: #f8f9fa;
  padding: 8px 12px;
  border-radius: 5px;
  border: 1px solid #ccc;
  font-family: Arial, sans-serif;
  font-size: 14px;
  z-index: 10000;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  backdrop-filter: blur(5px);
}

.toggle-button span {
  cursor: pointer;
  padding: 5px;
  transition: all 0.2s ease;
  border-radius: 3px;
}

.toggle-button span:hover {
  background: #e9ecef;
}

.toggle-button .active {
  background: #007bff;
  color: white;
  border-radius: 3px;
}

.toggle-button .active:hover {
  background: #0056b3;
}

/* Container Styles */
#globeContainer,
#mapContainer {
  width: 100%;
  position: relative;
}

/* Ensure map controls are positioned correctly */
#mapControls {
  display: flex;
  position: relative;
  z-index: 100;
}

/* Responsive design */
@media (max-width: 768px) {
  .toggle-button {
    top: 5px;
    right: 5px;
    font-size: 12px;
    padding: 3px 8px;
  }
  
  .toggle-button span {
    padding: 3px;
  }
}

/* Hide footer for immersive view */
.photography-page footer {
  display: none;
}

/* Fullscreen adjustments */
@media (max-height: 600px) {
  #globeContainer,
  #mapContainer {
    height: calc(100vh - 80px) !important;
  }
}-e 
```
-e 
### ./css/project-detail.css

```css
/* Project detail page styling */

.project-detail-content {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px 0;
}

.project-meta {
  margin-bottom: 20px;
  color: #666;
}

.project-banner-image {
  width: 100%;
  max-height: 400px;
  object-fit: cover;
  margin: 20px 0;
  border-radius: 5px;
}

.project-body-content {
  line-height: 1.6;
}

.back-link {
  margin-top: 40px;
  padding-top: 20px;
  border-top: 1px solid #eee;
}

.back-link a {
  text-decoration: none;
  color: #3a7bd5;
  font-weight: 500;
}

.back-link a:hover {
  text-decoration: underline;
}

/* Markdown rendering styles */
.project-body-content h2 {
  margin-top: 2em;
  color: #1a5276;
  border-bottom: 1px solid #eee;
  padding-bottom: 0.3em;
}

.project-body-content h3 {
  margin-top: 1.5em;
  color: #2c3e50;
}

.project-body-content ul,
.project-body-content ol {
  padding-left: 2em;
  margin-bottom: 1em;
}

.project-body-content pre {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
  padding: 1em;
  overflow-x: auto; /* Handle long code lines */
  border-radius: 4px;
  margin: 1em 0;
}

.project-body-content code {
  font-family: monospace;
  background-color: #f0f0f0; /* Subtle background for inline code */
  padding: 0.1em 0.3em;
  border-radius: 3px;
}

.project-body-content pre code {
  background-color: transparent; /* Code inside pre doesn't need its own background */
  padding: 0;
}

.project-body-content img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 1em auto; /* Center images */
  border: 1px solid #eee;
  border-radius: 4px;
}

.project-body-content blockquote {
  border-left: 4px solid #ccc;
  padding-left: 1em;
  margin-left: 0;
  font-style: italic;
  color: #555;
  background-color: #f9f9f9;
  padding: 0.5em 1em;
}

.project-body-content table {
  border-collapse: collapse;
  width: 100%;
  margin: 1em 0;
}

.project-body-content th,
.project-body-content td {
  padding: 8px;
  text-align: left;
  border-bottom: 1px solid #ddd;
}

.project-body-content th {
  background-color: #f2f2f2;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .project-detail-content {
    padding: 10px;
  }
  
  .project-banner-image {
    max-height: 300px;
  }
}-e 
```
-e 
### ./css/projects.css

```css
/* css/projects.css */
/* Enhanced styling for projects page */

.projects-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 2rem;
  margin-top: 2rem;
}

.project-card {
  border: 1px solid #ddd;
  border-radius: 10px;
  overflow: hidden;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
}

.project-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
}

.project-image {
  width: 100%;
  height: 220px;
  object-fit: cover;
  display: block;
  border-bottom: 1px solid #eee;
}

.project-content {
  padding: 1.5rem;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
}

.project-title {
  margin-top: 0;
  margin-bottom: 0.8rem;
  font-size: 1.3em;
  color: #1a5276;
  position: relative;
}

.project-title::after {
  content: '';
  position: absolute;
  bottom: -0.3rem;
  left: 0;
  width: 40px;
  height: 3px;
  background-color: #3a7bd5;
}

.project-summary {
  font-size: 0.95em;
  margin-bottom: 1rem;
  color: #333;
  line-height: 1.5;
}

.project-role {
  font-size: 0.9em;
  margin-bottom: 1rem;
  color: #555;
  line-height: 1.4;
}

.project-role strong {
  color: #333;
  font-weight: 600;
}

.project-skills {
  margin-top: auto;
  margin-bottom: 1rem;
}

.project-skills h4 {
  margin-bottom: 0.5rem;
  font-size: 0.9em;
  color: #444;
  font-weight: 600;
}

.project-skills ul {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.project-skills li {
  background-color: #f0f3f7;
  padding: 0.3rem 0.6rem;
  border-radius: 4px;
  font-size: 0.8em;
  color: #555;
  border: 1px solid #e1e8f2;
  transition: all 0.2s ease;
}

.project-skills li:hover {
  background-color: #e1e8f2;
  color: #333;
}

.project-links {
  margin-top: 1rem;
  margin-bottom: 0.8rem;
}

.project-links a {
  display: inline-block;
  margin-right: 1em;
  margin-bottom: 0.5em;
  padding: 0.3em 0.8em;
  background-color: #f0f3f7;
  border-radius: 4px;
  text-decoration: none;
  color: #3a7bd5;
  font-size: 0.85em;
  font-weight: 600;
  transition: all 0.2s ease;
  border: 1px solid #dde4ee;
}

.project-links a:hover {
  background-color: #e1e8f2;
  transform: translateY(-2px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.project-status {
  font-size: 0.85em;
  margin-top: 0.5rem;
  margin-bottom: 0;
  color: #666;
  font-style: italic;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .projects-grid {
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1.5rem;
  }
  
  .project-image {
    height: 180px;
  }
  
  .project-content {
    padding: 1.2rem;
  }
  
  .project-title {
    font-size: 1.2em;
  }
}

@media (max-width: 480px) {
  .projects-grid {
    grid-template-columns: 1fr;
    gap: 1.2rem;
  }
}-e 
```
-e 
### ./css/research.css

```css
/* css/research.css */
/* Enhanced styling for research page */

/* Section styling */
section {
  margin-bottom: 3rem;
}

section h2 {
  border-bottom: 2px solid #3a7bd5;
  padding-bottom: 0.5rem;
  margin-bottom: 1.5rem;
  color: #2c3e50;
}

/* Entry styling */
.research-entry {
  margin-bottom: 2.5em;
  padding-bottom: 1.5em;
  border-bottom: 1px solid #eee;
  transition: transform 0.2s ease;
}

.research-entry:hover {
  transform: translateX(3px);
}

.research-entry:last-child {
  border-bottom: none;
}

/* Title styling */
.entry-title {
  margin-bottom: 0.3em;
  font-size: 1.3em;
  color: #1a5276;
}

/* Meta information styling */
.entry-authors, .entry-venue, .entry-date {
  margin: 0.2em 0;
  font-size: 0.9em;
  color: #555;
}

.entry-authors {
  font-style: italic;
}

.entry-authors strong {
  font-weight: 600;
  color: #000;
  font-style: normal;
}

.entry-venue {
  color: #666;
}

.entry-date {
  color: #777;
}

/* Abstract styling */
.entry-abstract {
  margin: 1em 0;
  font-size: 0.95em;
  padding: 0.8em 1.2em;
  border-left: 3px solid #3a7bd5;
  background-color: #f7f9fc;
  border-radius: 0 4px 4px 0;
}

.entry-abstract p {
  margin: 0.5em 0;
  line-height: 1.5;
}

.entry-abstract p:first-child {
  margin-top: 0;
}

.entry-abstract p:last-child {
  margin-bottom: 0;
}

/* Links styling */
.entry-links {
  margin-top: 1em;
}

.entry-links a {
  display: inline-block;
  margin-right: 1em;
  margin-bottom: 0.5em;
  padding: 0.3em 0.8em;
  background-color: #f0f3f7;
  border-radius: 4px;
  text-decoration: none;
  color: #3a7bd5;
  font-size: 0.85em;
  font-weight: 600;
  transition: all 0.2s ease;
  border: 1px solid #dde4ee;
}

.entry-links a:hover {
  background-color: #e1e8f2;
  transform: translateY(-2px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .entry-title {
    font-size: 1.2em;
  }
  
  .entry-abstract {
    padding: 0.6em 1em;
  }
  
  .entry-links a {
    margin-bottom: 0.7em;
  }
}-e 
```
-e 
### ./css/style.css

```css
/* Base styles */
body {
    margin: 0;
    font-family: Arial, sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #fff;
  }
  h1, h2, h3, h4 {
    margin-top: 1em;
  }
  h1 {
    font-size: 2em;
  }
  .container {
    max-width: 900px;
    margin: 0 auto;
    padding: 0 1rem;
  }
  header {
    background: #f8f8f8;
    padding: 0.5rem 0;
  }
  header .container {
    display: flex;
    align-items: center;
  }
  header h1 {
    margin: 0;
    font-size: 1.5em;
  }
  #main-nav {
    margin-left: auto;
  }
  #main-nav a {
    text-decoration: none;
    color: #333;
    margin-left: 1rem;
    font-weight: 500;
  }
  #main-nav a:hover {
    text-decoration: underline;
  }
  #main-nav a.active {
    font-weight: 700;
  }
  #nav-toggle {
    display: none;
    background: none;
    border: none;
    font-size: 1.5em;
    cursor: pointer;
  }
  .profile-pic {
    max-width: 300px;
    border-radius: 0%;
    display: block;
    margin: 1rem auto;
  }
  /* Footer styles */
  footer {
    background: #f0f0f0;
    padding: 1rem 0;
    margin-top: 2rem;
  }
  footer h2 {
    margin-top: 0;
  }
  footer p {
    margin: 0.2rem 0;
  }
  /* Responsive layout */
  @media (max-width: 600px) {
    header .container {
      flex-wrap: wrap;
    }
    #nav-toggle {
      display: block;
      margin-left: auto;
    }
    #main-nav {
      display: none;
      flex-direction: column;
      width: 100%;
      margin-top: 0.5rem;
    }
    #main-nav a {
      margin: 0.5rem 0;
    }
    #main-nav.open {
      display: flex;
    }
  }
  
  footer {
    background: #f0f0f0;
    padding: 20px 0;
    text-align: center;
  }
  footer .container {
    max-width: 900px;
    margin: auto;
    padding: 0 15px;
  }
  footer h2 {
    margin-bottom: 15px;
  }
  footer ul {
    list-style: none;
    padding: 0;
    margin-top: 5px;
    text-align: center;
  }
  footer p {
    margin: 5px 0;
  }
  footer ul li {
    margin: 5px 0;
  }
  footer a {
    text-decoration: none;
    color: #333;
    font-weight: 500;
  }
  footer a:hover {
    text-decoration: underline;
  }
  .social-links {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 15px;
    margin-top: 10px;
  }
  .social-links a {
    display: inline-block;
  }
  .social-links img {
    width: 32px;
    height: 32px;
    transition: transform 0.2s ease-in-out;
  }
  .social-links img:hover {
    transform: scale(1.1);
  }
  
/* Small links for CV page */
.small-link {
  display: inline-block;
  font-size: 0.7em;
  margin-left: 0.5em;
  padding: 0.1em 0.4em;
  background-color: #f0f3f7;
  border-radius: 3px;
  text-decoration: none;
  color: #3a7bd5;
  font-weight: normal;
  transition: all 0.2s ease;
  border: 1px solid #dde4ee;
  vertical-align: middle;
}

.small-link:hover {
  background-color: #e1e8f2;
  transform: translateY(-1px);
}

/* Skill item styles */
.skill-item {
  transition: color 0.2s ease;
  text-decoration: none;
}

.linked-skill {
  cursor: pointer;
  text-decoration: underline;
}

.linked-skill:hover {
  color: #3a7bd5;
}

/* Skill tooltip styles */
.skill-tooltip {
  position: absolute;
  background: #333;
  color: #fff;
  padding: 5px 10px;
  border-radius: 3px;
  font-size: 0.9em;
  z-index: 1000;
  white-space: nowrap;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

.skill-tooltip::before {
  content: '';
  position: absolute;
  top: -5px;
  left: 10px;
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-bottom: 5px solid #333;
}

/* Modal styles */
.modal {
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 5px;
  max-width: 400px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  position: relative;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

.modal-content h3 {
  margin-top: 0;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px solid #eee;
}

.modal-content ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.modal-content ul li {
  margin: 10px 0;
}

.modal-content ul li a {
  color: #3a7bd5;
  text-decoration: none;
  display: inline-block;
  padding: 5px 10px;
  background: #f0f3f7;
  border-radius: 3px;
  transition: all 0.2s ease;
}

.modal-content ul li a:hover {
  background: #e1e8f2;
  transform: translateX(5px);
}

.close {
  position: absolute;
  right: 15px;
  top: 15px;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  color: #aaa;
  transition: color 0.2s ease;
}

.close:hover,
.close:focus {
  color: #000;
}

/* Contact Banner Styles */
.contact-banner {
  text-align: center;
  padding: 20px;
  background-color: #333; /* A consistent, modern dark grey */
  border: none;
}

/* Force all children to inherit the background color to fix the "stripes" bug */
.contact-banner,
.contact-banner *,
.contact-banner > div,
.contact-banner ul,
.contact-banner ol,
.contact-banner li,
.contact-banner a {
  background: inherit !important;
  border: none !important;
  list-style: none !important;
  padding: 0 !important;
  margin: 0 !important;
}

.banner-header {
  font-size: 14px;
  color: #000;
  margin-bottom: 23px !important; /* Increased spacing by ~50% */
  font-weight: 500;
}

.social-icons {
  display: flex;
  justify-content: center;
  gap: 15px;
  flex-wrap: wrap;
}

.social-icon {
  width: 24px;
  height: 24px;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

.social-icons a {
  display: inline-block !important; /* Restore display property */
  padding: 4px !important; /* Restore padding */
  border-radius: 4px;
  transition: transform 0.2s ease;
}

.social-icons a:hover {
  transform: scale(1.1);
}

.social-icons a:hover .social-icon {
  transform: scale(1.1);
}

/* Responsive design for contact banner */
@media (max-width: 768px) {
  .banner-header {
    font-size: 12px;
    margin-bottom: 15px !important; /* Increased spacing by ~50% */
  }
  
  .social-icons {
    gap: 10px;
  }
  
  .social-icon {
    width: 20px;
    height: 20px;
  }
  
  .social-icons a {
    padding: 6px !important; /* Restore padding */
  }
}
  -e 
```
-e 
### ./css/vendor/photoswipe.css

```css
/*\! PhotoSwipe 5.4.0 - https://photoswipe.com - MIT License */
.pswp {
  --pswp-bg: #000;
  --pswp-placeholder-bg: #222;
  --pswp-error-text-color: #f7f7f7;
  --pswp-root-z-index: 100000;
  --pswp-preloader-color: rgba(79, 79, 79, 0.4);
  --pswp-preloader-color-active: rgba(255, 255, 255, 0.9);
  --pswp-icon-color: #fff;
  --pswp-icon-color-secondary: #4f4f4f;
  --pswp-icon-stroke-color: #4f4f4f;
  --pswp-icon-stroke-width: 2px;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: var(--pswp-root-z-index);
  display: none;
  touch-action: none;
  outline: 0;
  opacity: 0.003;
  contain: layout style size;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-overflow-scrolling: touch
}
.pswp:focus {
  outline: 0
}
.pswp * {
  box-sizing: border-box
}
.pswp img {
  max-width: none
}
.pswp--open {
  display: block
}
.pswp,
.pswp__bg,
.pswp__container {
  will-change: opacity
}
.pswp__bg {
  opacity: 0.005;
  background: var(--pswp-bg)
}
.pswp,
.pswp__scroll-wrap {
  overflow: hidden
}
.pswp__scroll-wrap,
.pswp__bg,
.pswp__container,
.pswp__item,
.pswp__zoom-wrap,
.pswp__img {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%
}
.pswp__img {
  object-fit: contain
}
.pswp__zoom-wrap,
.pswp__img {
  will-change: transform
}
.pswp__container {
  display: flex;
  flex-direction: row;
  transform: translate3d(0, 0, 0);
  transition: transform 333ms cubic-bezier(.4, 0, .22, 1);
  z-index: 1
}
.pswp__img {
  will-change: transform, opacity;
  backface-visibility: hidden;
  transition: all 333ms cubic-bezier(.4, 0, .22, 1);
}
.pswp__item {
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
.pswp__error-msg {
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  transform: translateY(-50%);
  padding: 0 10px;
  color: var(--pswp-error-text-color);
  font-size: 14px;
  text-align: center
}
.pswp__error-img {
  background-color: var(--pswp-placeholder-bg);
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 14H4V7h16v12zM12 9c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"/></svg>');
  background-position: center;
  background-repeat: no-repeat;
  background-size: 40%;
  width: 60%;
  min-width: 100px;
  max-width: 150px;
  aspect-ratio: 1/1;
  border-radius: 4px;
  margin-bottom: 18px
}
.pswp__preloader {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  will-change: opacity;
  transition: opacity .3s ease;
  pointer-events: none;
  width: 60px;
  height: 60px;
  margin-bottom: 18px
}
.pswp__preloader--active {
  opacity: 1
}
.pswp__preloader-icn {
  opacity: 0;
  transform: rotateZ(0deg);
  border-radius: 100%;
  animation: pswp-preloader-spin 750ms infinite linear;
  width: 32px;
  height: 32px;
  box-sizing: border-box;
  border: 4px solid var(--pswp-preloader-color);
  border-bottom-color: var(--pswp-preloader-color-active);
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%)
}
@keyframes pswp-preloader-spin {
  0% {
    transform: rotateZ(0deg)
  }
  100% {
    transform: rotateZ(360deg)
  }
}
.pswp__ui {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
  pointer-events: none
}
.pswp__ui--visible {
  visibility: visible
}
.pswp__button {
  position: relative;
  display: block;
  width: 50px;
  height: 60px;
  padding: 0;
  margin: 0;
  overflow: hidden;
  cursor: pointer;
  background-color: transparent;
  border: 0;
  opacity: .85;
  transition: opacity .3s;
  -webkit-appearance: none;
  -webkit-touch-callout: none
}
.pswp__button:hover,
.pswp__button:active,
.pswp__button:focus {
  transition: none;
  opacity: 1;
  cursor: pointer
}
.pswp__button:disabled {
  opacity: .3 \!important;
  cursor: auto
}
.pswp__icon {
  display: block;
  width: 20px;
  height: 20px;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  fill: var(--pswp-icon-color);
  stroke: var(--pswp-icon-stroke-color);
  stroke-width: var(--pswp-icon-stroke-width);
  overflow: hidden;
  pointer-events: none
}
.pswp__top-bar {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 60px;
  display: flex;
  flex-direction: row;
  justify-content: flex-end;
  z-index: 1;
  pointer-events: none
}
.pswp__top-bar>* {
  pointer-events: auto
}
.pswp__button--close {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>');
  background-position: center;
  background-repeat: no-repeat;
  background-size: 20px;
}
.pswp__counter {
  height: 30px;
  line-height: 30px;
  margin: 15px 0;
  margin-left: 20px;
  padding: 0 10px;
  min-width: 16px;
  font-size: 13px;
  text-align: center;
  letter-spacing: 1px;
  color: #fff;
  pointer-events: none
}
-e 
```
-e 
### ./css/worldmap.css

```css
.photo-marker {
    background: transparent;
    border: none;
}
  
.photo-pin {
    border-radius: 15%;
    border: 2px solid white;
    box-shadow: 0 0 4px rgba(0,0,0,0.5);
    width: 75px;
    height: 75px;
    object-fit: cover;
}

/* Simple marker style for low zoom levels */
.simple-marker {
    background: transparent;
    border: none;
}

.simple-map-pin {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: #e74c3c;
    border: 2px solid white;
    box-shadow: 0 0 4px rgba(0,0,0,0.5);
}

/* Simple cluster icon style for low zoom levels */
.simple-cluster-icon {
    background: transparent;
    border: none;
}

.simple-cluster {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background-color: rgba(231, 76, 60, 0.8);
    color: white;
    font-weight: bold;
    border: 2px solid white;
    box-shadow: 0 0 4px rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
}

/* Tag Autocomplete Styles */
.autocomplete-suggestions {
    position: absolute;
    top: 100%;
    left: 0;
    border: 1px solid #ccc;
    border-top: none;
    max-height: 150px;
    overflow-y: auto;
    background-color: white;
    z-index: 1000;
    display: none;
    width: 200px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.autocomplete-suggestions div {
    padding: 8px;
    cursor: pointer;
}

.autocomplete-suggestions div:hover {
    background-color: #eee;
}
  
.custom-cluster-icon {
    background: transparent;
    border: none;
}
  
.cluster-stack {
    position: relative;
    width: 50px;
    height: 50px;
}
  
.cluster-stack img {
    position: absolute;
    width: 50px;
    height: 50px;
    border-radius: 15%;
    border: 2px solid white;
    box-shadow: 0 0 4px rgba(0,0,0,0.5);
}
  
.cluster-photo-0 {
    z-index: 3;
    top: 0;
    left: 0;
}
.cluster-photo-1 {
    z-index: 2;
    top: 5px;
    left: 5px;
}
.cluster-photo-2 {
    z-index: 1;
    top: 10px;
    left: 10px;
}

/* Map Control Styles */
#mapControls {
    background-color: #f8f8f8;
    padding: 10px;
    border-bottom: 1px solid #ddd;
}

#mapControls h3 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 16px;
}

#filterSection, #viewSection {
    margin-bottom: 10px;
}

#filterSection div, #viewSection div {
    margin-bottom: 8px;
}

#filterSection label, #viewSection label {
    margin-right: 10px;
}

#filterDateStart, #filterDateEnd {
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin-right: 5px;
}

#filterTagsInput {
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 200px;
}

#applyFiltersButton, #clearFiltersButton {
    padding: 5px 10px;
    margin-right: 5px;
    background-color: #4285F4;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

#clearFiltersButton {
    background-color: #f44336;
}

#tripSelector {
    width: 100%;
    max-width: 300px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

#locationListContainer {
    background-color: #f8f8f8;
    padding: 10px;
    border-top: 1px solid #ddd;
}

#locationList {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

.location-item {
    padding: 5px 10px;
    background-color: #e0e0e0;
    border-radius: 4px;
    cursor: pointer;
}

.location-item:hover {
    background-color: #d0d0d0;
}

.location-item.active {
    background-color: #4285F4;
    color: white;
}

/* Active Filters Display */
#activeFiltersList span.filter-badge {
    display: inline-block;
    background-color: #e0e0e0; /* Light grey background */
    color: #333;
    padding: 3px 8px;
    border-radius: 12px; /* Pill shape */
    margin-right: 5px;
    margin-bottom: 5px; /* Allow wrapping */
    font-size: 0.9em;
    white-space: nowrap;
}

#activeFiltersList span.filter-badge button.remove-filter {
    background: none;
    border: none;
    color: #888; /* Lighter color for X */
    margin-left: 5px;
    padding: 0;
    cursor: pointer;
    font-weight: bold;
    font-size: 1.1em; /* Make X slightly larger */
    line-height: 1; /* Align X better */
}

#activeFiltersList span.filter-badge button.remove-filter:hover {
    color: #d33; /* Red on hover */
}

#activeFiltersList span.no-filters {
    /* Style for the 'None' text */
    font-style: italic;
    color: #888;
}-e 
```
-e 
### ./cv.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Finn Wilson - CV</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <header></header>
  <main class="container">
    <section id="education">
      <h2>Education</h2>
      <ul>
        <li>Loading...</li>
      </ul>
    </section>
    <section id="research">
      <h2>Research Experience</h2>
      <!-- Research entries will be dynamically populated by JavaScript -->
    </section>
    <section id="work">
      <h2>Work Experience</h2>
      <!-- Work entries will be dynamically populated by JavaScript -->
    </section>
    <section id="projects">
      <h2>Projects</h2>
      <div class="project-list">
        <!-- Project entries will be dynamically populated by JavaScript -->
      </div>
    </section>
    <section id="skills">
      <h2>Skills</h2>
      <ul>
        <!-- Skills will be dynamically populated by JavaScript -->
      </ul>
    </section>
    <section id="achievements">
      <h2>Achievements</h2>
      <ul>
        <!-- Achievements will be dynamically populated by JavaScript -->
      </ul>
    </section>
    <section id="positions">
      <h2>Positions of Responsibility</h2>
      <ul>
        <!-- Positions will be dynamically populated by JavaScript -->
      </ul>
    </section>
    <!-- Download CV link -->
    <p><a href="FinnWilsonCV.pdf" download>Download PDF Version of CV</a></p>
  </main>
  <footer id="footer"></footer>
  
  <!-- Skill Modal -->
  <div id="skillModal" class="modal" style="display:none;">
    <div class="modal-content">
      <span class="close">&times;</span>
      <h3 id="modalTitle"></h3>
      <ul id="modalList"></ul>
    </div>
  </div>
  
  <script src="js/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="js/cv.js" defer></script>
</body>
</html>-e 
```
-e 
### ./footer.html

```html
<div class="container">
    <h2>Contact</h2>
  
    <p><strong>Phone:</strong> <a href="tel:+61475066890">+61 475 066 890</a></p>
  
    <p><strong>Email:</strong></p>
    <ul>
      <li><a href="mailto:contact@finnwilson.me">contact@finnwilson.me</a> (Primary)</li>
      <li><a href="mailto:fwil7293@uni.sydney.edu.au">fwil7293@uni.sydney.edu.au</a> (University, may expire)</li>
      <li><a href="mailto:finnwilson98@gmail.com">finnwilson98@gmail.com</a> (Secondary)</li>
    </ul>
  
    <div class="social-links">
      <a href="https://www.linkedin.com/in/finn-wilson-73a162177/" target="_blank">
        <img src="icons/linkedin.svg" alt="LinkedIn" />
      </a>
      <a href="https://github.com/finnwilson02" target="_blank">
        <img src="icons/github.svg" alt="GitHub" />
      </a>
      <a href="https://twitter.com/YOURHANDLE" target="_blank">
        <img src="icons/twitter.svg" alt="Twitter" />
      </a>
      <a href="https://medium.com/@YOURHANDLE" target="_blank">
        <img src="icons/medium.svg" alt="Medium" />
      </a>
      <a href="https://www.youtube.com/@YOURHANDLE" target="_blank">
        <img src="icons/youtube.svg" alt="YouTube" />
      </a>
    </div>
  </div>
  -e 
```
-e 
### ./gen_hash.js

```js
const bcrypt = require('bcrypt');
const saltRounds = 10; // Matches your $2b$10$ (cost factor 10)
const myPassword = 'Pegasus2015'; // Change this

bcrypt.hash(myPassword, saltRounds, (err, hash) => {
  if (err) console.error(err);
  console.log('New Hash:', hash);
});
-e 
```
-e 
### ./globe.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Finn Wilson - Photo Globe</title>
    <!-- Include base styles if needed for header/footer -->
    <link rel="stylesheet" href="css/style.css">
    <!-- Include CesiumJS CSS -->
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        /* Basic styling to make viewer fill page */
        html, body, #cesiumContainer {
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
        }
        /* Ensure header doesn't overlap or viewer adjusts */
        body { display: flex; flex-direction: column; }
        #header-placeholder { flex-shrink: 0; /* Prevent header from shrinking */ }
        #cesiumContainer { flex-grow: 1; /* Allow viewer to take remaining space */ }
        /* Footer might be hidden or overlaid depending on layout */
        footer { display: none; /* Hide footer on globe view initially */ }
    </style>
</head>
<body>
    <!-- Include header -->
    <div id="header-placeholder"></div>
    <script>
        fetch('includes/header.html')
            .then(response => response.text())
            .then(html => {
                document.getElementById('header-placeholder').innerHTML = html;
                // Highlight the current page in navigation
                document.getElementById('nav-globe').classList.add('active');
            });
    </script>

    <!-- Container for the Cesium Viewer -->
    <div id="cesiumContainer"></div>

    <!-- Footer (hidden by CSS) -->
    <footer id="footer"></footer>

    <!-- Include CesiumJS library -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js"></script>
    <!-- Include GLightbox library -->
    <script src="https://cdn.jsdelivr.net/npm/glightbox/dist/js/glightbox.min.js"></script>
    <!-- Include GLightbox CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox/dist/css/glightbox.min.css">
    <!-- Include your common script AFTER Cesium -->
    <script src="js/script.js"></script>
    <!-- Include specific script for this page -->
    <script src="js/globe.js"></script>
</body>
</html>-e 
```
-e 
### ./hash-password.js

```js
const bcrypt = require('bcrypt');
const saltRounds = 10; // Recommended salt rounds
const plainPassword = 'finnwilson'; // Using the same password from before for simplicity

bcrypt.hash(plainPassword, saltRounds, function(err, hash) {
    if (err) {
        console.error("Error hashing password:", err);
        return;
    }
    console.log("Plain Password:", plainPassword);
    console.log("Hashed Password:", hash);
    console.log("\nCopy the 'Hashed Password' value and store it securely.");
});-e 
```
-e 
### ./includes/header.html

```html
<header>
  <div class="container">
    <h1>Finn Wilson</h1>
    <nav id="main-nav">
      <a href="index.html" id="nav-home">Home</a>
      <a href="cv.html" id="nav-cv">CV</a>
      <a href="research.html" id="nav-research">Research</a>
      <a href="projects.html" id="nav-projects">Projects</a>
      <a href="bookshelf.html" id="nav-bookshelf">Bookshelf</a>
      <a href="photography.html" id="nav-photography">Photography</a>
    </nav>
    <button id="nav-toggle">☰</button>
  </div>
</header>-e 
```
-e 
### ./index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Finn Wilson - Home</title>
  <link rel="stylesheet" href="css/style.css" />
</head>
<body>
  <header></header>

  <main class="container">
    <!-- Dynamic content loaded from homepage.json -->
    <section id="homeContent">
      <!-- Content will be loaded here by homeContentLoader.js -->
    </section>
  </main>

  <footer id="footer"></footer>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="js/script.js"></script>
  <script src="js/homeContentLoader.js"></script>
  
</body>
</html>
-e 
```
-e 
### ./js/admin.js

```js
// js/admin.js

// EasyMDE instance
let easyMDEInstance = null;

// Coordinate map variables
let coordMap = null;
let coordMarker = null;

// Selectors for login and content
const loginSection = document.getElementById('loginSection');
const adminContent = document.getElementById('adminContent');
const passwordInput = document.getElementById('password');
const loginButton = document.getElementById('loginButton');
const loginError = document.getElementById('loginError');
const logoutButton = document.getElementById('logoutButton');
const loadingIndicator = document.getElementById('loadingIndicator');
const notificationArea = document.getElementById('adminNotifications');

// Book management selectors
const bookTableBody = document.getElementById('bookTableBody');
const bookForm = document.getElementById('bookForm');
const formTitle = document.getElementById('formTitle');
const bookIndex = document.getElementById('bookIndex');
const titleInput = document.getElementById('title');
const authorInput = document.getElementById('author');
const spineColorInput = document.getElementById('spineColor');
const titleColorInput = document.getElementById('titleColor');
const authorColorInput = document.getElementById('authorColor');
const ratingInput = document.getElementById('rating');
const genreInput = document.getElementById('genre');
const datesReadInput = document.getElementById('datesRead');
const reviewInput = document.getElementById('review');
const saveBookBtn = document.getElementById('saveBookBtn');
const cancelBtn = document.getElementById('cancelBtn');

// Photo management selectors
const photoTableBody = document.getElementById('photoTableBody');
const photoForm = document.getElementById('photoForm');
const photoEditIndex = document.getElementById('photoEditIndex');
const photoThumbnailInput = document.getElementById('photoThumbnail');
const photoTitleInput = document.getElementById('photoTitle');
const photoDateInput = document.getElementById('photoDate');
const photoDescriptionInput = document.getElementById('photoDescription');
const photoLatInput = document.getElementById('photoLat');
const photoLngInput = document.getElementById('photoLng');
const photoRankingInput = document.getElementById('photoRanking');
const photoTagsInput = document.getElementById('photoTags');
const photoTripIdSelect = document.getElementById('photoTripIdSelect');
// Country field removed - will be auto-determined by server
const photoSubmitButton = document.getElementById('photoSubmitButton');
const photoCancelButton = document.getElementById('photoCancelButton');

// Project management selectors
const projectTableBody = document.getElementById('projectTableBody');
const projectForm = document.getElementById('projectForm');
const projectEditIndex = document.getElementById('projectEditIndex');
const projectIdInput = document.getElementById('projectId');
const projectTitleInput = document.getElementById('projectTitle');
const projectImageInput = document.getElementById('projectImage');
const projectSummaryInput = document.getElementById('projectSummary');
const projectRoleInput = document.getElementById('projectRole');
const projectSkillsInput = document.getElementById('projectSkills');
const projectLinksContainer = document.getElementById('projectLinksContainer');
const addProjectLinkButton = document.getElementById('addProjectLinkButton');
const noLinksMsg = document.getElementById('noLinksMsg');
const projectStatusInput = document.getElementById('projectStatus');
const projectDetailMarkdownInput = document.getElementById('projectDetailMarkdown');
const projectSubmitButton = document.getElementById('projectSubmitButton');
const projectCancelButton = document.getElementById('projectCancelButton');

// Function to create a new link row
function createLinkRow(linkType = '', linkUrl = '') {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'project-link-row';
    rowDiv.style.display = 'flex';
    rowDiv.style.marginBottom = '5px';
    rowDiv.style.gap = '5px'; // Add spacing between elements

    // Select dropdown for link type
    const typeSelect = document.createElement('select');
    typeSelect.className = 'project-link-type';
    const types = ['GitHub', 'Demo', 'Research', 'Website', 'Other']; // Define link types
    types.forEach(type => {
        const option = document.createElement('option');
        option.value = type.toLowerCase(); // Use lowercase for consistency
        option.textContent = type;
        if (type.toLowerCase() === linkType.toLowerCase()) {
            option.selected = true;
        }
        typeSelect.appendChild(option);
    });

    // Input for URL
    const urlInput = document.createElement('input');
    urlInput.type = 'text';
    urlInput.className = 'project-link-url';
    urlInput.placeholder = 'Link URL (e.g., https://...)';
    urlInput.value = linkUrl;
    urlInput.style.flexGrow = '1'; // Allow URL input to take available space

    // Remove button
    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.textContent = 'Remove';
    removeButton.className = 'remove-link-button';
    removeButton.onclick = function() { // Attach onclick handler directly
        rowDiv.remove(); // Remove this row div
        // Check if container is empty and show message
        if (projectLinksContainer && projectLinksContainer.querySelectorAll('.project-link-row').length === 0) {
            if(noLinksMsg) noLinksMsg.style.display = 'block';
        }
    };

    rowDiv.appendChild(typeSelect);
    rowDiv.appendChild(urlInput);
    rowDiv.appendChild(removeButton);

    return rowDiv;
}

// Add link button listener
if (addProjectLinkButton && projectLinksContainer) {
    addProjectLinkButton.addEventListener('click', () => {
        const newRow = createLinkRow(); // Create a new blank row
        projectLinksContainer.appendChild(newRow);
        if(noLinksMsg) noLinksMsg.style.display = 'none'; // Hide the 'no links' message
    });
}

// Store data arrays globally
let books = [];
let photos = [];
let projects = [];
let trips = [];
let pageContent = {}; // Global variable to hold loaded page content
let pageContentEditors = {}; // To hold EasyMDE instances for page content

// Helper to upload a file and get the server path
async function uploadFile(fileInputId) {
    const fileInput = document.getElementById(fileInputId);
    console.log(`DEBUG uploadFile: checking for files in ${fileInputId}`);
    
    if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
        console.log(`DEBUG uploadFile: No file selected, returning success with null filePath`);
        return { success: true, filePath: null }; // No file selected, treat as success
    }

    const file = fileInput.files[0];
    const formData = new FormData();
    // 'uploadedImage' MUST match the name expected by multer.single() on the backend
    formData.append('uploadedImage', file);

    console.log(`DEBUG uploadFile: Uploading ${file.name}, size: ${file.size}, type: ${file.type}`);
    // Show uploading indicator to user
    showNotification(`Uploading ${file.name}...`, 'info');

    try {
        console.log(`DEBUG uploadFile: Sending fetch request to /api/upload/image`);
        const response = await fetch('/api/upload/image', {
            method: 'POST',
            body: formData,
            // DO NOT set Content-Type header, browser does it for FormData
            credentials: 'include'  // Sends/receives cookies
        });
        
        console.log(`DEBUG uploadFile: Response received - status: ${response.status}, ok: ${response.ok}`);
        
        const result = await response.json(); // Always try to parse JSON
        console.log(`DEBUG uploadFile: Parsed response:`, result);

        if (!response.ok) {
            // Handle specific errors like 401 (auth) or 400 (validation)
            if (response.status === 401) {
                console.warn("Session expired or invalid during upload. Redirecting to login.");
                showNotification("Your session has expired. Please log in again.", 'error');
                if(adminContent) adminContent.style.display = 'none';
                if(loginSection) loginSection.style.display = 'block';
                if(passwordInput) passwordInput.value = '';
                const returnValue = { success: false, error: 'Unauthorized' };
                console.log(`DEBUG uploadFile: Returning due to unauthorized:`, returnValue);
                return returnValue;
            }
            throw new Error(result.error || `Upload failed with status ${response.status}`);
        }

        if (!result.success || !result.filename) {
            throw new Error(result.error || 'Upload succeeded but no filename returned.');
        }

        console.log('Upload successful, filename:', result.filename);
        const returnValue = { success: true, filename: result.filename };
        console.log(`DEBUG uploadFile: Returning success:`, returnValue);
        showNotification(`File ${file.name} uploaded successfully!`, 'success');
        return returnValue; // Return the filename from server

    } catch (error) {
        console.error('File upload failed:', error);
        showNotification(`Error uploading file: ${error.message}`, 'error');
        const returnValue = { success: false, error: error.message };
        console.log(`DEBUG uploadFile: Returning error:`, returnValue);
        return returnValue;
    } finally {
        console.log(`DEBUG uploadFile: Function completed`);
    }
}

/**
 * Shows a notification message to the user
 * @param {string} message - The message to display
 * @param {string} type - Type of notification: 'success', 'error', 'warning', or 'info'
 */
function showNotification(message, type = 'info') {
  if (!notificationArea) return;
  
  // Create notification element
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.style.padding = '10px 15px';
  notification.style.marginBottom = '10px';
  notification.style.borderRadius = '4px';
  notification.style.fontSize = '14px';
  notification.style.position = 'relative';
  
  // Set color based on type
  switch(type) {
    case 'success':
      notification.style.backgroundColor = '#d4edda';
      notification.style.color = '#155724';
      notification.style.border = '1px solid #c3e6cb';
      break;
    case 'error':
      notification.style.backgroundColor = '#f8d7da';
      notification.style.color = '#721c24';
      notification.style.border = '1px solid #f5c6cb';
      break;
    case 'warning':
      notification.style.backgroundColor = '#fff3cd';
      notification.style.color = '#856404';
      notification.style.border = '1px solid #ffeeba';
      break;
    case 'info':
    default:
      notification.style.backgroundColor = '#d1ecf1';
      notification.style.color = '#0c5460';
      notification.style.border = '1px solid #bee5eb';
  }
  
  // Add close button
  const closeBtn = document.createElement('span');
  closeBtn.innerHTML = '&times;';
  closeBtn.style.position = 'absolute';
  closeBtn.style.right = '10px';
  closeBtn.style.top = '5px';
  closeBtn.style.cursor = 'pointer';
  closeBtn.style.fontWeight = 'bold';
  closeBtn.onclick = function() {
    notification.remove();
  };
  
  // Add message
  notification.textContent = message;
  notification.appendChild(closeBtn);
  
  // Add to notification area
  notificationArea.appendChild(notification);
  
  // Auto-remove after 5 seconds for success messages
  if (type === 'success') {
    setTimeout(() => {
      // Fade out effect
      notification.style.opacity = '0';
      notification.style.transition = 'opacity 0.5s ease';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 500); // Remove after fade out
    }, 5000); // Back to 5 seconds with fade effect
  }
}

/**
 * Shows or hides the loading indicator
 * @param {boolean} show - Whether to show (true) or hide (false) the loading indicator
 */
function toggleLoading(show) {
  if (loadingIndicator) {
    loadingIndicator.style.display = show ? 'flex' : 'none';
  }
}

// CV data objects
let cvEducation = [];
let cvWork = [];
let cvResearch = [];
let cvProjects = [];
let cvSkills = { programming: [], software: [], technical: [] };
let cvAchievements = [];
let cvPositions = [];

// Research data objects
let researchJournal = [];
let researchThesis = {};
let researchConference = [];
let researchPatent = [];
let researchEditors = {}; // For storing EasyMDE instances

// Flag to prevent multiple initializations
let isInitialized = false;

// Common function to save data to the API
async function saveData(dataType, data, buttonElement = null) {
  console.log(`DEBUG saveData: Function called with dataType = ${dataType}`);
  console.log(`DEBUG saveData: Data structure:`, data);
  console.log(`DEBUG saveData: ButtonElement provided:`, buttonElement ? true : false);

  const endpointMap = {
    books: '/api/save/books',
    images: '/api/save/images',
    projects: '/api/save/projects',
    page_content: '/api/save/page_content',
    'cv/education': '/api/save/cv/education',
    'cv/work': '/api/save/cv/work',
    'cv/research': '/api/save/cv/research',
    'cv/projects': '/api/save/cv/projects',
    'cv/skills': '/api/save/cv/skills',
    'cv/achievements': '/api/save/cv/achievements',
    'cv/positions': '/api/save/cv/positions',
    'research/journal': '/api/save/research/journal',
    'research/thesis': '/api/save/research/thesis',
    'research/conference': '/api/save/research/conference',
    'research/patent': '/api/save/research/patent',
    'trips': '/api/save/trips'
  };
  
  const endpoint = endpointMap[dataType];
  console.log(`DEBUG saveData: Using endpoint: ${endpoint}`);
  
  if (!endpoint) {
    console.error(`Invalid data type for saving: ${dataType}`);
    showNotification(`Error: Cannot save data for type ${dataType}.`, 'error');
    return false; // Indicate failure
  }

  // Store original button text if a button was provided
  let originalButtonText = '';
  if (buttonElement) {
    originalButtonText = buttonElement.textContent || 'Save';
    buttonElement.textContent = 'Saving...';
    buttonElement.disabled = true;
    console.log(`DEBUG saveData: Original button text: "${originalButtonText}"`);
  }

  console.log(`Attempting to save ${dataType} data...`);
  try {
    console.log(`DEBUG saveData: Preparing fetch request to ${endpoint}`);
    console.log(`DEBUG saveData: Data payload size: ${JSON.stringify(data).length} bytes`);
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data), // Send the data (array or object depending on type)
      credentials: 'include'  // Sends/receives cookies—add to all fetches
    });
    
    console.log(`DEBUG saveData: Response received - status: ${response.status}, ok: ${response.ok}`);

    if (!response.ok) {
      // Check for unauthorized error (session expired)
      if (response.status === 401) {
          console.warn("Session expired or invalid. Redirecting to login.");
          console.log(`DEBUG saveData: Auth error detected, status 401`);
          showNotification("Your session has expired. Please log in again.", 'error');
          // Hide admin content, show login form
          if(adminContent) adminContent.style.display = 'none';
          if(loginSection) loginSection.style.display = 'block';
          if(passwordInput) passwordInput.value = ''; // Clear password field
          return false; // Indicate save failure
      }
      
      // Handle other errors
      let errorMsg = `HTTP error! Status: ${response.status}`;
      try {
         const errData = await response.json();
         console.log(`DEBUG saveData: Error JSON parsed:`, errData);
         errorMsg += ` - ${errData.error || 'Unknown server error'}`;
      } catch (parseError) { 
         console.log(`DEBUG saveData: Failed to parse error JSON:`, parseError);
         /* Ignore if response wasn't JSON */ 
      }
      throw new Error(errorMsg);
    }

    const result = await response.json();
    console.log(`DEBUG saveData: Success response parsed:`, result);
    console.log(`Save successful for ${dataType}:`, result.message);
    showNotification(`${dataType.charAt(0).toUpperCase() + dataType.slice(1).replace('/', ' ')} data saved successfully.`, 'success');
    return true; // Indicate success

  } catch (error) {
    console.error(`Failed to save ${dataType} data:`, error);
    console.log(`DEBUG saveData: Exception caught:`, error);
    showNotification(`Error saving ${dataType} data: ${error.message}`, 'error');
    return false; // Indicate failure
  } finally {
    // Restore button state regardless of success/failure
    if (buttonElement) {
      console.log(`DEBUG saveData: Restoring button text to "${originalButtonText}"`);
      buttonElement.textContent = originalButtonText;
      buttonElement.disabled = false;
    }
    console.log(`DEBUG saveData: Function completed`);
  }
}

function initializeMarkdownEditor() {
    if (document.getElementById('projectDetailMarkdown') && !easyMDEInstance) {
        try {
            easyMDEInstance = new EasyMDE({
                element: document.getElementById('projectDetailMarkdown'),
                spellChecker: false,
                minHeight: "250px",
                toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "image", "code", "table", "|", "preview", "side-by-side", "fullscreen"]
            });
            console.log("EasyMDE Initialized");
        } catch (e) {
            console.error("Failed to initialize EasyMDE:", e);
        }
    }
}

async function initializeAdminPanel() {
    if (isInitialized) return; // Don't run multiple times
    console.log("Initializing admin panel data...");
    
    try {
        // Load trips first as photo grouping depends on it
        await loadTrips(); // Ensure trips are loaded first
        
        // Then load photos which depends on trips
        await loadPhotos();
        
        // Load other data in parallel since they're independent
        await Promise.allSettled([
            loadBooks(),
            loadProjects(),
            loadPageContent(), // Load page content for legacy content
            loadCvData(), // Load all CV data from structured files
            loadResearchData() // Load all research data from structured files
        ]);
        
        initializeMarkdownEditor(); // Initialize the editor
        setupTabNavigation(); // Initialize tab navigation
        setupCvTabNavigation(); // Initialize CV sub-tab navigation
    } catch (error) {
        console.error("Error during admin panel initialization:", error);
        showNotification("Failed to initialize all admin data.", "error");
    } finally {
        isInitialized = true;
    }
}

// Tab navigation functionality
function setupTabNavigation() {
    const tabNav = document.querySelector('.admin-tabs ul.tab-nav');

    if (tabNav) {
        tabNav.addEventListener('click', (event) => {
            // Check if the clicked element is a tab link
            if (event.target.matches('a.tab-link')) {
                event.preventDefault(); // Stop browser from following href="#"

                const clickedTab = event.target;
                const targetPaneSelector = clickedTab.dataset.tabTarget;
                const targetPane = document.querySelector(targetPaneSelector);

                if (!targetPane) {
                    console.warn(`Target pane not found for selector: ${targetPaneSelector}`);
                    return;
                }

                // Remove active class from all tabs and panes first
                tabNav.querySelectorAll('.tab-link.active').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelectorAll('.tab-content .tab-pane.active').forEach(pane => {
                    pane.classList.remove('active');
                });

                // Add active class to the clicked tab and its target pane
                clickedTab.classList.add('active');
                targetPane.classList.add('active');

                // Special case: Re-initialize EasyMDE if the Projects tab becomes active
                if (targetPaneSelector === '#projectManagementSection') {
                    // Check if the instance exists and try to refresh or re-init if needed
                    if (easyMDEInstance && typeof easyMDEInstance.codemirror !== 'undefined') {
                        // Might need a slight delay for the element to become fully visible
                        setTimeout(() => {
                            try {
                                easyMDEInstance.codemirror.refresh();
                                console.log("Project EasyMDE refreshed.");
                            } catch (e) { 
                                console.error("Error refreshing Project EasyMDE:", e);
                            }
                        }, 10); // Small delay
                    } else {
                        // If not initialized, try initializing now
                        initializeMarkdownEditor();
                    }
                }
                
                // Special case: Load contact details if the Contact Details tab becomes active
                if (targetPaneSelector === '#contactDetailsSection') {
                    loadContactDetails();
                }
                
                // Special case: Load homepage content if the Homepage Content tab becomes active
                if (targetPaneSelector === '#homepageSection') {
                    loadHomepage();
                }
                
                // Refresh page content editors if CV or Research tab becomes active
                if (targetPaneSelector === '#cvContentSection' || targetPaneSelector === '#researchContentSection') {
                    // Get the prefix for the current tab
                    const prefix = targetPaneSelector === '#cvContentSection' ? 'cv_' : 'research_';
                    
                    // Refresh all relevant EasyMDE instances
                    setTimeout(() => {
                        Object.keys(pageContentEditors).forEach(key => {
                            if (key.startsWith(prefix)) {
                                try {
                                    if (pageContentEditors[key] && pageContentEditors[key].codemirror) {
                                        pageContentEditors[key].codemirror.refresh();
                                    }
                                } catch (e) {
                                    console.error(`Error refreshing ${key} editor:`, e);
                                }
                            }
                        });
                        console.log(`${prefix} content editors refreshed.`);
                    }, 10); // Small delay for render
                }
            }
        });
    }
}

// Login functionality with server-side authentication
if (loginButton) {
    loginButton.addEventListener('click', async () => {
        try {
            const password = passwordInput.value;
            
            // Send login request to server
            const response = await fetch('/api/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ password }), // Send password to server
                credentials: 'include'  // Sends/receives cookies
            });
            
            if (response.ok) {
                // Login successful
                loginSection.style.display = 'none';
                loginError.style.display = 'none';
                adminContent.style.display = 'block';
                initializeAdminPanel(); // Load data only AFTER successful login
            } else {
                // Login failed
                const errorData = await response.json();
                loginError.textContent = errorData.message || 'Login failed.';
                loginError.style.display = 'block';
                passwordInput.value = ''; // Clear password field
            }
        } catch (error) {
            console.error('Login error:', error);
            loginError.textContent = 'Network error. Please try again.';
            loginError.style.display = 'block';
        }
    });
}

// Logout functionality
if (logoutButton) {
    logoutButton.addEventListener('click', async () => {
        try {
            const response = await fetch('/api/logout', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'include'  // Sends/receives cookies
            });
            
            if (response.ok) {
                // Clear any loaded data
                books = [];
                photos = [];
                projects = [];
                
                // Show login section, hide admin content
                adminContent.style.display = 'none';
                loginSection.style.display = 'block';
                passwordInput.value = ''; // Clear password field
                loginError.style.display = 'none';
            } else {
                showNotification('Logout failed. Please try again.', 'error');
            }
        } catch (error) {
            console.error('Logout error:', error);
            showNotification('Network error during logout. Please try again.', 'error');
        }
    });
}

// Check authentication status on page load (optional)
window.addEventListener('DOMContentLoaded', async () => {
    try {
        const response = await fetch('/api/auth/status');
        if (response.ok) {
            const data = await response.json();
            if (data.isAuthenticated) {
                // User is already authenticated, show admin panel directly
                loginSection.style.display = 'none';
                adminContent.style.display = 'block';
                initializeAdminPanel();
            }
        }
    } catch (error) {
        console.error('Error checking authentication status:', error);
    }
});

// Add listener for Enter key on password input
if (passwordInput) {
    passwordInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault(); // Prevent potential form submission
            loginButton.click(); // Trigger login button click
        }
    });
}

// --- Book Management Functions ---
async function loadBooks() {
    toggleLoading(true);
    try {
        const response = await fetch('/api/data/books', {
            credentials: 'include'  // Sends/receives cookies
        });
        if (!response.ok) {
            let errorMsg = `HTTP error! Status: ${response.status}`;
            try { 
                const errData = await response.json(); 
                errorMsg += ` - ${errData.error || 'Unknown'}`; 
            } catch(e) {}
            throw new Error(errorMsg);
        }
        const data = await response.json();
        books = Array.isArray(data) ? data : [];
        renderBookTable();
    } catch (error) {
        console.error("Could not load books:", error);
        showNotification("Error loading books: " + error.message, 'error');
        if (bookTableBody) {
            bookTableBody.innerHTML = '<tr><td colspan="4">Error loading books. Check console or data/books.json.</td></tr>';
        }
    } finally {
        toggleLoading(false);
    }
}

function renderBookTable() {
    if (!bookTableBody) return;
    bookTableBody.innerHTML = '';
    
    books.forEach((book, index) => {
        const row = bookTableBody.insertRow();
        row.insertCell().textContent = book.title || 'No Title';
        row.insertCell().textContent = book.author || 'No Author';
        
        // Create star rating display
        const ratingCell = row.insertCell();
        const rating = parseInt(book.rating) || 0;
        ratingCell.textContent = '★'.repeat(rating) + '☆'.repeat(5 - rating);
        
        // Actions cell with edit and delete buttons
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-book-btn">Edit</button>
            <button data-index="${index}" class="delete-book-btn">Delete</button>
        `;
    });
    
    // Add event listeners to the edit and delete buttons
    document.querySelectorAll('.edit-book-btn').forEach(button => {
        button.addEventListener('click', handleEditBook);
    });
    
    document.querySelectorAll('.delete-book-btn').forEach(button => {
        button.addEventListener('click', handleDeleteBook);
    });
}

function handleEditBook(event) {
    const index = parseInt(event.target.dataset.index);
    console.log('Editing book at index:', index);
    
    if (typeof index !== 'number' || isNaN(index) || index < 0 || index >= (books?.length || 0)) {
        console.error('Invalid index for editing book:', index);
        showNotification('Invalid book index. Please reload the page.', 'error');
        return;
    }
    
    const book = books[index];
    if (!book || !book.title) {  // Check existence and key props
        console.error('Book data missing or incomplete at index:', index);
        showNotification('Book not found or data incomplete. Reloading...', 'error');
        location.reload();  // Force reload to resync
        return;
    }
    
    formTitle.textContent = 'Edit Book';
    bookIndex.value = index;
    titleInput.value = book.title || '';
    authorInput.value = book.author || '';
    spineColorInput.value = book.spineColor || '#ca0b0b';
    titleColorInput.value = book.titleColor || '#ffffff';
    authorColorInput.value = book.authorColor || '#ffffff';
    ratingInput.value = book.rating || '5';
    genreInput.value = book.genre || '';
    datesReadInput.value = book.datesRead || '';
    reviewInput.value = book.review || '';
    
    // Scroll to the form
    bookForm.scrollIntoView({ behavior: 'smooth' });
}

async function handleDeleteBook(event) {
    const index = parseInt(event.target.dataset.index, 10);
    const book = books[index];
    
    if (confirm(`Are you sure you want to delete "${book.title}" by ${book.author}?`)) {
        let isSuccess = false;
        
        // Create a copy and modify it
        const updatedBooks = [...books]; // Create a shallow copy
        if (index >= 0 && index < updatedBooks.length) {
            updatedBooks.splice(index, 1); // Modify the copy
        } else {
            console.error("Invalid index for deleting book:", index);
            showNotification("Error: Could not delete book due to invalid index.", 'error');
            return; // Stop processing
        }
        
        // Attempt to save the ENTIRE updated COPY array
        isSuccess = await saveData('books', updatedBooks);
        
        // Handle result
        if (isSuccess) {
            // Force reload data from server to ensure sync
            await loadBooks();  // Reload to sync
            // Reset form if the deleted item was being edited
            if (parseInt(bookIndex.value, 10) === index) {
                resetBookForm();
            }
        } else {
            // FAILURE: Alert already shown by saveData
            // Do nothing here, original 'books' array is unchanged
            console.log("Delete failed. Local data array remains unchanged.");
        }
    }
}

function resetBookForm() {
    formTitle.textContent = 'Add New Book';
    bookIndex.value = '';
    bookForm.reset();
    // Set default colors
    spineColorInput.value = '#ca0b0b';
    titleColorInput.value = '#ffffff';
    authorColorInput.value = '#ffffff';
}

// Book form submission handler
if (bookForm) {
    bookForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const bookData = {
            title: titleInput.value,
            author: authorInput.value,
            spineColor: spineColorInput.value,
            titleColor: titleColorInput.value,
            authorColor: authorColorInput.value,
            rating: parseInt(ratingInput.value),
            genre: genreInput.value,
            datesRead: datesReadInput.value,
            review: reviewInput.value
        };
        
        const editIndex = bookIndex.value === '' ? -1 : parseInt(bookIndex.value, 10);
        let isSuccess = false;
        
        // Create a copy and modify it
        const updatedBooks = [...books]; // Create a shallow copy
        if (editIndex === -1) {
            updatedBooks.unshift(bookData); // Add to beginning of the copy
        } else {
            if (editIndex >= 0 && editIndex < updatedBooks.length) {
                updatedBooks[editIndex] = bookData; // Modify the copy
            } else {
                console.error("Invalid index for editing book:", editIndex);
                showNotification("Error: Could not update book due to invalid index.", 'error');
                return; // Stop processing
            }
        }
        
        // Attempt to save the ENTIRE updated COPY array with button reference
        isSuccess = await saveData('books', updatedBooks, saveBookBtn);
        
        // Handle result
        if (isSuccess) {
            // Force reload data from server to ensure sync
            await loadBooks();  // Reload to sync
            resetBookForm();      // Reset form
        } else {
            // FAILURE: Notification already shown by saveData
            // Do nothing here, original 'books' array is unchanged
            // Form is not reset, allowing user to retry
            console.log("Save failed. Local data array remains unchanged.");
        }
    });
}

// Cancel button handler
if (cancelBtn) {
    cancelBtn.addEventListener('click', resetBookForm);
}

// --- Photo Management Functions ---

// Helper function to remember the open/closed state of trip groups
function getOpenTripGroupStates() {
    const states = {};
    const tripGroups = document.querySelectorAll('#photosGroupContainer details.trip-group');
    tripGroups.forEach(group => {
        if (group.dataset.tripId) {
            states[group.dataset.tripId] = group.open;
        }
    });
    console.log("Remembered trip group states:", states);
    return states;
}

// Helper function to apply remembered open/closed states to trip groups
function applyOpenTripGroupStates(states) {
    if (!states) return;
    const tripGroups = document.querySelectorAll('#photosGroupContainer details.trip-group');
    tripGroups.forEach(group => {
        if (group.dataset.tripId && states.hasOwnProperty(group.dataset.tripId)) {
            group.open = states[group.dataset.tripId];
        }
    });
    console.log("Applied trip group states.");
}

// Function to restore default photo order for a specific trip
async function restoreDefaultPhotoOrder(tripIdToRestore) {
    console.log(`Restoring default order for tripId: ${tripIdToRestore}`);

    // Create a new array with copies of photo objects to avoid modifying the original `photos` array directly
    // until after a successful save.
    const updatedPhotos = photos.map(p => ({ ...p }));

    // Identify photos belonging to the target trip and those not in the trip
    const photosInTrip = [];
    const photosNotInTrip = [];

    updatedPhotos.forEach(photo => {
        if ((photo.tripId || "unassigned") === tripIdToRestore) {
            photosInTrip.push(photo);
        } else {
            photosNotInTrip.push(photo);
        }
    });

    if (photosInTrip.length === 0) {
        showNotification(`No photos found for trip ID: ${tripIdToRestore}`, 'info');
        return;
    }

    // Sort photos within the target trip by date (ascending), then by title (ascending)
    photosInTrip.sort((a, b) => {
        const dateA = a.date || '';
        const dateB = b.date || '';
        const titleA = (a.title || '').toLowerCase();
        const titleB = (b.title || '').toLowerCase();

        if (dateA < dateB) return -1;
        if (dateA > dateB) return 1;
        // Dates are equal (or both empty), sort by title
        if (titleA < titleB) return -1;
        if (titleA > titleB) return 1;
        return 0;
    });

    // Re-assign orderIndex sequentially for this trip's photos
    photosInTrip.forEach((photo, newOrder) => {
        photo.orderIndex = newOrder;
    });

    // Reconstruct the full photos array with updated photosInTrip and original photosNotInTrip
    // This ensures photos in other trips retain their original orderIndex.
    const finalPhotosArray = [...photosInTrip, ...photosNotInTrip];
    // Sort the final array by tripId first (consistent grouping), then by new orderIndex
    finalPhotosArray.sort((a, b) => {
        const tripIdA = a.tripId || "unassigned";
        const tripIdB = b.tripId || "unassigned";
        if (tripIdA.localeCompare(tripIdB) !== 0) {
            return tripIdA.localeCompare(tripIdB);
        }
        return (a.orderIndex || 0) - (b.orderIndex || 0);
    });

    // Save the entire updated photos array
    // Attempt to find the button element for visual feedback during save.
    const buttonElement = document.querySelector(`.restore-order-btn[data-trip-id="${tripIdToRestore}"]`);
    const isSuccess = await saveData("images", finalPhotosArray, buttonElement);

    if (isSuccess) {
        photos = finalPhotosArray; // Update local data with the re-ordered and reconstructed array
        
        const openStates = getOpenTripGroupStates(); // Remember current UI state
        renderGroupedPhotoLists();                  // Refresh the display
        applyOpenTripGroupStates(openStates);       // Restore UI state
        showNotification(`Order restored and saved for trip: ${tripIdToRestore}`, 'success');
    } else {
        showNotification(`Failed to save restored order for trip: ${tripIdToRestore}`, 'error');
    }
}

async function loadPhotos() {
    toggleLoading(true);
    try {
        const response = await fetch('/api/data/images', {
            credentials: 'include'  // Sends/receives cookies
        });
        if (!response.ok) {
            let errorMsg = `HTTP error! Status: ${response.status}`;
            try { 
                const errData = await response.json(); 
                errorMsg += ` - ${errData.error || 'Unknown'}`; 
            } catch(e) {}
            throw new Error(errorMsg);
        }
        const data = await response.json();
        photos = Array.isArray(data) ? data : [];
        renderGroupedPhotoLists();
        return photos; // Return the photos data for promise chaining
    } catch (error) {
        console.error("Could not load photos:", error);
        showNotification("Error loading photos: " + error.message, 'error');
        const container = document.getElementById('photosGroupContainer');
        if (container) {
            container.innerHTML = '<p>Error loading photos. Check console or data/images.json.</p>';
        }
        throw error; // Rethrow to allow proper promise handling
    } finally {
        toggleLoading(false);
    }
}

function renderGroupedPhotoLists() {
    const container = document.getElementById('photosGroupContainer');
    if (!container) {
        console.log("DEBUG renderGroupedPhotoLists: container not found, exiting");
        return;
    }
    console.log("--- renderGroupedPhotoLists ---"); // Mark entry

    // Log the data arrays being used
    console.log("Global 'trips' array:", JSON.stringify(trips, null, 2)); // Log loaded trips
    console.log("Global 'photos' array (first 5):", JSON.stringify(photos.slice(0, 5), null, 2)); // Log sample photos
    
    container.innerHTML = ''; // Clear loading/previous content

    // --- Group photos by trip ID ---
    const photosByTrip = {};
    const unassignedPhotos = [];

    photos.forEach((photo, index) => {
        photo.originalIndex = index; // Store original index for editing/deleting later
        const tripId = photo.tripId;
        if (tripId && tripId !== "") {
            if (!photosByTrip[tripId]) {
                photosByTrip[tripId] = [];
            }
            photosByTrip[tripId].push(photo);
        } else {
            unassignedPhotos.push(photo);
        }
    });
    
    console.log("Generated 'photosByTrip' object:", JSON.stringify(photosByTrip, (key, value) => key === 'originalIndex' ? undefined : value, 2)); // Log grouped photos (hide originalIndex for clarity)
    console.log("Generated 'unassignedPhotos' count:", unassignedPhotos.length);
    
    // Sort photos within each trip group by orderIndex first, then by date
    Object.keys(photosByTrip).forEach(tripId => {
        photosByTrip[tripId].sort((a, b) => {
            // Sort by orderIndex if both have it
            if (a.orderIndex !== undefined && b.orderIndex !== undefined) {
                return a.orderIndex - b.orderIndex;
            }
            // Fall back to date sorting
            return (a.date || '').localeCompare(b.date || '');
        });
    });
    
    // Sort unassigned photos by date
    unassignedPhotos.sort((a, b) => (a.date || '').localeCompare(b.date || ''));

    // --- Render Function for a Single Table ---
    function createPhotoTable(photoList, tripId) {
        const table = document.createElement('table');
        table.style.width = '100%';
        table.innerHTML = `<thead><tr><th>Thumbnail</th><th>Title</th><th>Coords</th><th>Date</th><th>Ranking</th><th>Actions</th></tr></thead>`;
        const tbody = table.createTBody();
        
        photoList.forEach(photo => {
            const row = tbody.insertRow();
            
            // Make the row draggable for reordering
            row.draggable = true;
            row.dataset.photoIndex = photo.originalIndex;
            row.dataset.tripId = photo.tripId || 'unassigned';
            row.classList.add('photo-list-row');
            
            // Thumbnail cell
            const imgSrc = photo.thumbnail || '';
            const imgPath = imgSrc ? `img/${imgSrc}` : '';
            const thumbCell = row.insertCell();
            thumbCell.innerHTML = imgSrc ? 
                `<img src="${imgPath}" alt="thumbnail" width="50" height="50" style="object-fit: cover;" data-slug="${imgSrc}">` : 
                'No thumb';
            
            // Other data cells
            row.insertCell().textContent = photo.title || 'N/A';
            
            const lat = photo.lat !== undefined ? parseFloat(photo.lat) : NaN;
            const lng = photo.lng !== undefined ? parseFloat(photo.lng) : NaN;
            row.insertCell().textContent = (!isNaN(lat) && !isNaN(lng)) ? 
                `${lat.toFixed(4)}, ${lng.toFixed(4)}` : 'N/A';
            
            row.insertCell().textContent = photo.date || 'N/A';
            row.insertCell().textContent = photo.ranking !== undefined ? photo.ranking : 'N/A';
            
            // Actions cell with original index
            const actionsCell = row.insertCell();
            actionsCell.innerHTML = `
                <div style="margin-bottom: 8px;">
                  <button class="rotL" data-slug="${imgSrc}" title="Rotate Left">⟲ Left</button>
                  <button class="rotR" data-slug="${imgSrc}" title="Rotate Right">Right ⟳</button>
                </div>
                <button data-index="${photo.originalIndex}" class="edit-photo-btn">Edit</button>
                <button data-index="${photo.originalIndex}" class="delete-photo-btn">Delete</button>
            `;
        });
        
        return table;
    }

    // --- Render Trip Sections ---
    let hasContent = false;
    console.log(`Iterating through ${trips.length} loaded trips to render sections...`); // Log start of loop
    trips.forEach(trip => {
        const tripId = trip.id;
        const tripName = trip.name;
        console.log(` Checking Trip: ID='${tripId}', Name='${tripName}'`); // Log current trip

        const tripPhotos = photosByTrip[tripId]; // Get photos using the trip ID as the key

        console.log(`  Photos found for this trip ID in photosByTrip?`, tripPhotos ? `Yes (${tripPhotos.length})` : 'No'); // Log if photos were found

        if (tripPhotos && tripPhotos.length > 0) {
            console.log(`  -> Rendering section for ${tripName}`); // Log section render start
            hasContent = true;
            const details = document.createElement('details');
            details.className = 'trip-group';
            details.dataset.tripId = tripId; // Add dataset attribute for state preservation
            const summary = document.createElement('summary');
            summary.innerHTML = `
                <strong>${trip.name || 'Unnamed Trip'}</strong>
                (${trip.dateRange || 'No Date'}) - ${tripPhotos.length} photo(s)
                <button type="button" class="restore-order-btn admin-small-button" data-trip-id="${trip.id}" title="Restore default date/name order">Reset Order</button>
            `;
            summary.style.cursor = 'pointer';
            summary.style.padding = '5px 0';
            summary.style.fontWeight = 'bold';

            const table = createPhotoTable(tripPhotos, tripId);
            details.appendChild(summary);
            details.appendChild(table);
            container.appendChild(details);
        } else {
            console.log(`  -> Skipping section for ${tripName} (no photos found in group)`); // Log skipped section
        }
    });

    // --- Render Unassigned Section ---
    if (unassignedPhotos.length > 0) {
        hasContent = true;
        const details = document.createElement('details');
        details.className = 'trip-group';
        details.dataset.tripId = 'unassigned'; // Add dataset attribute for state preservation
        details.open = true; // Open unassigned by default
        const summary = document.createElement('summary');
        summary.innerHTML = `
            <strong>Unassigned Photos</strong> - ${unassignedPhotos.length} photo(s)
            <button type="button" class="restore-order-btn admin-small-button" data-trip-id="unassigned" title="Restore default date/name order">Reset Order</button>
        `;
        summary.style.cursor = 'pointer';
        summary.style.padding = '5px 0';
        summary.style.fontWeight = 'bold';

        const table = createPhotoTable(unassignedPhotos);
        details.appendChild(summary);
        details.appendChild(table);
        container.appendChild(details);
    }

    if (!hasContent) {
        container.innerHTML = '<p>No photos found.</p>';
    }

    setupGroupedPhotoActionListeners(); // Set up event listeners via delegation
}
// Handler for image rotation
document.addEventListener('click', async e => {
    if (e.target.classList.contains('rotL') || e.target.classList.contains('rotR')) {
        const slug = e.target.dataset.slug;
        if (!slug) {
            console.error('No slug found on rotation button');
            showNotification('Error: Cannot identify image to rotate', 'error');
            return;
        }
        const dir = e.target.classList.contains('rotL') ? 'left' : 'right';
        
        // Show loading indicator
        const button = e.target;
        const originalText = button.innerHTML;
        button.innerHTML = '⟳'; // Show loading indicator
        button.disabled = true;
        
        try {
            const response = await fetch(`/api/images/${slug}/rotate`, {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({dir}),
                credentials: 'include'  // Sends/receives cookies
            });
            
            if (response.ok) {
                // Bust cache on all instances of this image
                const cacheBuster = Date.now();
                const imgElements = document.querySelectorAll(`img[src*="${slug}"]`);
                if (imgElements.length > 0) {
                    imgElements.forEach(img => {
                        img.src = img.src.split('?')[0] + '?v=' + cacheBuster;
                    });
                    showNotification(`Image rotated ${dir === 'left' ? 'counterclockwise' : 'clockwise'}`, 'success');
                } else {
                    console.warn('No image elements found to refresh after rotation');
                    showNotification('Image rotated, but thumbnail not refreshed', 'warning');
                }
            } else {
                const errorMsg = response.status === 401 ? 'Authentication required' : 'Server error';
                showNotification(`Failed to rotate image: ${errorMsg}`, 'error');
            }
        } catch (err) {
            console.error('Error rotating image:', err);
            showNotification('Error rotating image: ' + err.message, 'error');
        } finally {
            // Restore button
            button.innerHTML = originalText;
            button.disabled = false;
        }
    }
});

function setupGroupedPhotoActionListeners() {
    const container = document.getElementById("photosGroupContainer");
    if (!container) return;

    // Remove old listener if exists (to prevent duplicates)
    if (container.dataset.listenerAttached === "true") return; // Already attached

    // Click event listener for buttons
    container.addEventListener("click", function(event) {
        const target = event.target;
        if (target.classList.contains("edit-photo-btn")) {
            handleEditPhoto({target: target}); // Pass event-like object with target
        } else if (target.classList.contains("delete-photo-btn")) {
            handleDeletePhoto({target: target}); // Pass event-like object with target
        } else if (target.classList.contains("restore-order-btn")) {
            const tripId = target.dataset.tripId;
            if (tripId) {
                console.log(`Restore order button clicked for trip: ${tripId}`);
                restoreDefaultPhotoOrder(tripId); // Call the restore function
            } else {
                console.warn("Restore button clicked but no tripId found in dataset.");
            }
        }
    });

    // Drag and drop listeners for photo reordering
    let draggedItemIndex = null;
    let draggedItemTripId = null;
    
    container.addEventListener("dragstart", function(event) {
        const row = event.target.closest(".photo-list-row");
        if (!row) return;
        
        draggedItemIndex = parseInt(row.dataset.photoIndex, 10);
        draggedItemTripId = row.dataset.tripId;
        event.dataTransfer.effectAllowed = "move";
        
        // Add a class to style the row being dragged
        row.classList.add("dragging");
    });
    
    container.addEventListener("dragover", function(event) {
        const targetRow = event.target.closest(".photo-list-row");
        if (!targetRow) return;
        
        const targetTripId = targetRow.dataset.tripId;
        
        // Only allow dropping within the same trip group
        if (draggedItemTripId === targetTripId) {
            event.preventDefault(); // Allow drop
            event.dataTransfer.dropEffect = "move";
            
            // Add visual indicator
            document.querySelectorAll(".photo-list-row.dragging-over").forEach(el => {
                el.classList.remove("dragging-over");
            });
            targetRow.classList.add("dragging-over");
        }
    });
    
    container.addEventListener("dragleave", function(event) {
        const row = event.target.closest(".photo-list-row");
        if (row) {
            row.classList.remove("dragging-over");
        }
    });
    
    container.addEventListener("drop", async function(event) {
        event.preventDefault();
        const targetRow = event.target.closest(".photo-list-row");
        if (!targetRow) return;
        
        // Get source and target photo indices
        const sourceIdx = draggedItemIndex;
        const targetIdx = parseInt(targetRow.dataset.photoIndex, 10);
        const targetTripId = targetRow.dataset.tripId;
        
        if (sourceIdx === targetIdx) return; // No change needed
        
        // Remove visual indicators
        document.querySelectorAll(".photo-list-row.dragging-over").forEach(el => {
            el.classList.remove("dragging-over");
        });
        
        // Find photos in the source array
        const sourcePhoto = photos.find(p => p.originalIndex === sourceIdx);
        const targetPhoto = photos.find(p => p.originalIndex === targetIdx);
        
        if (!sourcePhoto || !targetPhoto) {
            console.error("Could not find source or target photo");
            return;
        }
        
        // Find all photos in this trip for reordering
        const tripPhotos = photos.filter(p => (p.tripId || "unassigned") === targetTripId);
        
        // Sort by current orderIndex
        tripPhotos.sort((a, b) => {
            if (a.orderIndex !== undefined && b.orderIndex !== undefined) {
                return a.orderIndex - b.orderIndex;
            }
            return 0;
        });
        
        // Find positions in the sorted array
        const sourceArrIdx = tripPhotos.findIndex(p => p.originalIndex === sourceIdx);
        const targetArrIdx = tripPhotos.findIndex(p => p.originalIndex === targetIdx);
        
        if (sourceArrIdx === -1 || targetArrIdx === -1) {
            console.error("Could not find photos in trip array");
            return;
        }
        
        // Remove source photo and insert at target position
        const [movedPhoto] = tripPhotos.splice(sourceArrIdx, 1);
        tripPhotos.splice(targetArrIdx > sourceArrIdx ? targetArrIdx - 1 : targetArrIdx, 0, movedPhoto);
        
        // Update orderIndex values sequentially
        tripPhotos.forEach((photo, idx) => {
            photo.orderIndex = idx;
            photo.sortIndex = idx; // Set new sortIndex also (matches orderIndex for compatibility)
        });
        
        // Create updated photos array for saving
        const updatedPhotos = [...photos]; // Create a copy
        
        // Save the updated photos to the main images endpoint
        const isSuccess = await saveData("images", updatedPhotos);
        
        // Also send data to the dedicated reorder endpoint
        const items = tripPhotos.map(photo => {
            const slug = photo.imageFull || photo.thumbnail;
            return {
                slug: slug,
                idx: photo.sortIndex
            };
        });
        
        // Send new sort order to the dedicated reorder endpoint
        try {
            const response = await fetch('/api/images/reorder', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',  // Sends/receives cookies
                body: JSON.stringify(items)
            });
            
            if (!response.ok) {
                console.error(`Failed to update sort order via /api/images/reorder: ${response.status}`);
            }
        } catch (error) {
            console.error('Error sending sort order update:', error);
        }
        
        if (isSuccess) {
            photos = updatedPhotos; // Update local data
            
            const openStates = getOpenTripGroupStates(); // Remember state BEFORE re-render
            renderGroupedPhotoLists();                  // Refresh the display
            applyOpenTripGroupStates(openStates);       // Apply state AFTER re-render
        }
    });
    
    container.addEventListener("dragend", function(event) {
        // Clean up
        document.querySelectorAll(".photo-list-row.dragging").forEach(el => {
            el.classList.remove("dragging");
        });
        document.querySelectorAll(".photo-list-row.dragging-over").forEach(el => {
            el.classList.remove("dragging-over");
        });
        draggedItemIndex = null;
        draggedItemTripId = null;
    });
    
    container.dataset.listenerAttached = "true"; // Mark as attached
}
// Keep the old function for compatibility, but make it call the new one
function renderPhotoTable() {
    console.log("DEBUG renderPhotoTable: Redirecting to renderGroupedPhotoLists");
    renderGroupedPhotoLists();
}

function handleEditPhoto(event) {
    const index = parseInt(event.target.dataset.index);
    console.log('Editing photo at index:', index);
    
    if (typeof index !== 'number' || isNaN(index) || index < 0 || index >= (photos?.length || 0)) {
        console.error('Invalid photo index:', index);
        showNotification('Invalid photo index. Reload page.', 'error');
        return;
    }
    
    const photo = photos[index];
    if (!photo || !photo.thumbnail) {
        console.error('Photo data missing or incomplete:', photo);
        showNotification('Photo not found. Reloading...', 'error');
        location.reload();
        return;
    }
    
    photoEditIndex.value = index;
    // Store the existing path in the hidden input
    document.getElementById("currentPhotoThumbnail").value = photo.thumbnail || "";
    // Clear the file input field
    document.getElementById("photoFile").value = null;
    
    photoTitleInput.value = photo.title || "";
    photoDateInput.value = photo.date || "";
    photoDescriptionInput.value = photo.description || "";
    photoLatInput.value = photo.lat || "";
    photoLngInput.value = photo.lng || "";
    photoRankingInput.value = photo.ranking || "5";
    photoTagsInput.value = Array.isArray(photo.tags) ? photo.tags.join(', ') : '';
    
    // Set country field
    // Country field removed - will be auto-determined by server
    
    // Set trip dropdown selection
    populateTripDropdown('photoTripIdSelect', photo.tripId);
    
    photoSubmitButton.textContent = 'Update Photo';
    photoCancelButton.style.display = 'inline-block';
    
    photoForm.scrollIntoView({ behavior: 'smooth' });
}

async function handleDeletePhoto(event) {
    const index = parseInt(event.target.dataset.index, 10);
    const photo = photos[index];
    
    if (confirm(`Are you sure you want to delete the photo "${photo.title || 'Untitled'}"?`)) {
        let isSuccess = false;
        
        // Create a copy and modify it
        const updatedPhotos = [...photos]; // Create a shallow copy
        if (index >= 0 && index < updatedPhotos.length) {
            updatedPhotos.splice(index, 1); // Modify the copy
        } else {
            console.error("Invalid index for deleting photo:", index);
            showNotification("Error: Could not delete photo due to invalid index.", 'error');
            return; // Stop processing
        }
        
        // Attempt to save the ENTIRE updated COPY array
        isSuccess = await saveData('images', updatedPhotos);
        
        // Handle result
        if (isSuccess) {
            // Force reload data from server to ensure sync
            await loadPhotos();  // Reload to sync
            
            const openStates = getOpenTripGroupStates(); // Remember state BEFORE re-render
            renderGroupedPhotoLists();                  // Re-render table
            applyOpenTripGroupStates(openStates);       // Apply state AFTER re-render
            
            // Reset form if the deleted item was being edited
            if (parseInt(photoEditIndex.value, 10) === index) {
                resetPhotoForm();
            }
        } else {
            // FAILURE: Alert already shown by saveData
            // Do nothing here, original 'photos' array is unchanged
            console.log("Delete failed. Local data array remains unchanged.");
        }
    }
}

function resetPhotoForm() {
    photoEditIndex.value = '-1';
    photoForm.reset();
    photoRankingInput.value = '5'; // Set default ranking
    
    // Clear the file input and current path
    document.getElementById('photoFile').value = null;
    document.getElementById('currentPhotoThumbnail').value = '';
    
    // Clear the width and height values
    document.getElementById('photoFullWidth').value = '';
    document.getElementById('photoFullHeight').value = '';
    
    // Reset the trip dropdown to "No Trip"
    photoTripIdSelect.value = '';
    
    // Country field removed - will be auto-determined by server
    
    photoSubmitButton.textContent = 'Add Photo';
    photoCancelButton.style.display = 'none';
}

// === Trip Management Functions ===

// Selectors for trip management
const tripTableBody = document.getElementById('tripTableBody');
const tripForm = document.getElementById('tripForm');
const tripFormTitle = document.getElementById('tripFormTitle');
const tripEditIndex = document.getElementById('tripEditIndex');
const tripNameInput = document.getElementById('tripName');
const tripDateRangeInput = document.getElementById('tripDateRange');
const tripIdInput = document.getElementById('tripId');
const tripSubmitButton = document.getElementById('tripSubmitButton');
const tripCancelButton = document.getElementById('tripCancelButton');

// Load trips data from server
async function loadTrips() {
    toggleLoading(true);
    try {
        console.log("loadTrips: Fetching trips data from server...");
        const response = await fetch('/api/data/trips', {
            credentials: 'include'  // Sends/receives cookies
        });
        if (!response.ok) {
            let errorMsg = `HTTP error! Status: ${response.status}`;
            try { 
                const errData = await response.json(); 
                errorMsg += ` - ${errData.error || 'Unknown'}`; 
            } catch(e) {}
            throw new Error(errorMsg);
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
            throw new Error("Invalid format: trips data is not an array");
        }
        
        console.log("loadTrips: Received trips data:", JSON.stringify(data, null, 2));
        trips = data;
        console.log(`Successfully loaded/updated ${trips.length} trips.`);
        console.log("loadTrips: Stored in global 'trips' array:", JSON.stringify(trips, null, 2));
        
        // --- Re-render dependent UI components ---
        renderTripTable(); // Update the trip management table
        populateTripDropdown('photoTripIdSelect'); // Update dropdown in photo form
        renderGroupedPhotoLists(); // Re-render the photo groups view
        // --- End re-rendering ---
        
        return trips; // Return the trips data for promise chaining
    } catch (error) {
        console.error("Could not load trips:", error);
        showNotification("Error loading trips: " + error.message, 'error');
        
        // Update UI to show error state
        if (tripTableBody) {
            tripTableBody.innerHTML = '<tr><td colspan="4">Error loading trips. Check console or data/trips.json.</td></tr>';
        }
        if (document.getElementById('photosGroupContainer')) {
            document.getElementById('photosGroupContainer').innerHTML = '<p>Error loading trip data, cannot display photos by group.</p>';
        }
        
        throw error; // Rethrow to allow proper promise handling
    } finally {
        toggleLoading(false);
    }
}

// Render the trips table
function renderTripTable() {
    if (!tripTableBody) return;
    
    tripTableBody.innerHTML = '';
    
    trips.forEach((trip, index) => {
        const row = tripTableBody.insertRow();
        row.insertCell().textContent = trip.name || 'N/A';
        row.insertCell().textContent = trip.dateRange || '';
        row.insertCell().textContent = trip.id || '';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-trip-btn">Edit</button>
            <button data-index="${index}" class="delete-trip-btn">Delete</button>
        `;
    });
    
    // Add event listeners to the buttons
    document.querySelectorAll('.edit-trip-btn').forEach(button => {
        button.addEventListener('click', handleEditTrip);
    });
    
    document.querySelectorAll('.delete-trip-btn').forEach(button => {
        button.addEventListener('click', handleDeleteTrip);
    });
}

// Handle edit trip button
function handleEditTrip(event) {
    const index = event.target.dataset.index;
    const trip = trips[index];
    
    tripEditIndex.value = index;
    tripNameInput.value = trip.name || '';
    tripDateRangeInput.value = trip.dateRange || '';
    tripIdInput.value = trip.id || '';
    tripIdInput.readOnly = true; // Make ID read-only when editing
    
    tripFormTitle.textContent = 'Edit Trip';
    tripSubmitButton.textContent = 'Update Trip';
    tripCancelButton.style.display = 'inline-block';
    
    tripForm.scrollIntoView({ behavior: 'smooth' });
}

// Handle delete trip button
async function handleDeleteTrip(event) {
    const index = parseInt(event.target.dataset.index, 10);
    const trip = trips[index];
    
    if (confirm(`Are you sure you want to delete the trip "${trip.name || 'Untitled'}"?`)) {
        // Create a copy and modify it
        const updatedTrips = [...trips]; // Create a shallow copy
        if (index >= 0 && index < updatedTrips.length) {
            updatedTrips.splice(index, 1); // Modify the copy
        } else {
            console.error("Invalid index for deleting trip:", index);
            showNotification("Error: Could not delete trip due to invalid index.", 'error');
            return; // Stop processing
        }
        
        // Attempt to save the ENTIRE updated COPY array
        const isSuccess = await saveData('trips', updatedTrips);
        
        // Handle result
        if (isSuccess) {
            await loadTrips(); // Reload trips data and update all UI components
            // Reset form if the deleted item was being edited
            if (parseInt(tripEditIndex.value, 10) === index) {
                resetTripForm();
            }
        } else {
            // FAILURE: Alert already shown by saveData
            console.log("Delete failed. Local data array remains unchanged.");
        }
    }
}

// Reset trip form to default state
function resetTripForm() {
    tripEditIndex.value = '-1';
    tripForm.reset();
    tripIdInput.readOnly = false; // Make ID editable again for new trips
    
    tripFormTitle.textContent = 'Add New Trip';
    tripSubmitButton.textContent = 'Add Trip';
    tripCancelButton.style.display = 'none';
}

// Trip form submission handler
if (tripForm) {
    tripForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const tripData = {
            id: tripIdInput.value,
            name: tripNameInput.value,
            dateRange: tripDateRangeInput.value
        };
        
        const editIndex = tripEditIndex.value === '-1' ? -1 : parseInt(tripEditIndex.value, 10);
        let isSuccess = false;
        
        // Create a copy and modify it
        const updatedTrips = [...trips]; // Create a shallow copy
        if (editIndex === -1) {
            updatedTrips.push(tripData); // Add to end of the copy
        } else {
            if (editIndex >= 0 && editIndex < updatedTrips.length) {
                updatedTrips[editIndex] = tripData; // Modify the copy
            } else {
                console.error("Invalid index for editing trip:", editIndex);
                showNotification("Error: Could not update trip due to invalid index.", 'error');
                return; // Stop processing
            }
        }
        
        // Attempt to save the ENTIRE updated COPY array
        isSuccess = await saveData('trips', updatedTrips, tripSubmitButton);
        
        // Handle result
        if (isSuccess) {
            await loadTrips(); // Reload trips data and update all UI components
            resetTripForm();   // Reset form
        } else {
            // FAILURE: Alert already shown by saveData
            // Do nothing here, original 'trips' array is unchanged
            console.log("Save failed. Local data array remains unchanged.");
        }
    });
}

// Trip dropdown population
function populateTripDropdown(selectElementId, selectedTripId = null) {
    const selectElement = document.getElementById(selectElementId);
    if (!selectElement) return;
    
    console.log(`populateTripDropdown: Populating dropdown ${selectElementId} with trips, selected=${selectedTripId}`);
    
    // Clear existing options except the first "No Trip" option
    while (selectElement.options.length > 1) {
        selectElement.remove(1);
    }
    
    // Add options for each trip
    trips.forEach(trip => {
        const option = document.createElement('option');
        option.value = trip.id;
        option.textContent = `${trip.name} (${trip.id})`;
        console.log(`  Added trip option: value="${trip.id}", text="${option.textContent}"`);
        
        // Set as selected if it matches the selectedTripId
        if (trip.id === selectedTripId) {
            option.selected = true;
            console.log(`  Selected this option because ${trip.id} === ${selectedTripId}`);
        }
        
        selectElement.appendChild(option);
    });
}

// Add cancel button handler for trip form
if (tripCancelButton) {
    tripCancelButton.addEventListener('click', resetTripForm);
}

// Photo form submission handler
if (photoForm) {
    photoForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        console.log("DEBUG photoForm: Form submission started");
        
        // First, handle the file upload if a file is selected
        console.log("DEBUG photoForm: Calling uploadFile('photoFile')");
        const uploadResult = await uploadFile('photoFile');
        console.log("DEBUG photoForm: Upload Result:", uploadResult);
        
        // If upload failed, stop processing. Error notification already shown by uploadFile
        if (!uploadResult.success && uploadResult.error !== undefined) {
            console.log("DEBUG photoForm: Upload failed, stopping form processing");
            return;
        }
        
        // Get the existing filename from hidden input
        const existingFilename = document.getElementById('currentPhotoThumbnail').value;
        console.log("DEBUG photoForm: Existing Filename:", existingFilename);
        
        // Determine the thumbnail filename to use
        let thumbnailFilename;
        if (uploadResult.filename) {
            // If a new file was uploaded, use its filename
            thumbnailFilename = uploadResult.filename;
            console.log("DEBUG photoForm: Using new uploaded filename");
        } else {
            // If no new file, use the existing filename from hidden input
            thumbnailFilename = existingFilename;
            console.log("DEBUG photoForm: Using existing filename (no new file)");
        }
        console.log("DEBUG photoForm: Final Thumbnail Filename:", thumbnailFilename);
        
        // Read dimensions from hidden inputs
        const widthVal = document.getElementById('photoFullWidth').value;
        const heightVal = document.getElementById('photoFullHeight').value;
        const fullWidth = parseInt(widthVal, 10) || null; // Use null if not available
        const fullHeight = parseInt(heightVal, 10) || null;
        
        const editIndex = photoEditIndex.value === '-1' ? -1 : parseInt(photoEditIndex.value, 10);
        console.log("DEBUG photoForm: Edit Index:", editIndex, "isNew:", editIndex === -1);
        
        // Get existing photo for editing case
        const existingPhoto = (editIndex === -1) ? null : photos[editIndex];
        
        const photoData = {
            thumbnail: thumbnailFilename, // Just storing the filename
            imageFull: thumbnailFilename, // Using same file for full image
            title: photoTitleInput.value,
            date: photoDateInput.value,
            description: photoDescriptionInput.value,
            lat: parseFloat(photoLatInput.value) || 0,
            lng: parseFloat(photoLngInput.value) || 0,
            ranking: parseInt(photoRankingInput.value) || 5,
            fullWidth: fullWidth, // Add width from hidden input
            fullHeight: fullHeight, // Add height from hidden input
            tags: photoTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag),
            tripId: photoTripIdSelect.value === '' ? null : photoTripIdSelect.value,
            country: null, // Will be auto-determined by server based on coordinates
            // Assign orderIndex and sortIndex: use existing if editing, else use appropriate defaults
            orderIndex: existingPhoto?.orderIndex ?? Date.now(), // Use existing or timestamp for new
            sortIndex: existingPhoto?.sortIndex ?? (photos.length) // Use existing or append to end
        };
        console.log("DEBUG photoForm: Photo Data Object:", photoData);
        
        let isSuccess = false;
        
        // Create a copy and modify it
        const updatedPhotos = [...photos]; // Create a shallow copy
        if (editIndex === -1) {
            console.log("DEBUG photoForm: Adding new photo to beginning of array");
            updatedPhotos.unshift(photoData); // Add to beginning of the copy
        } else {
            if (editIndex >= 0 && editIndex < updatedPhotos.length) {
                console.log("DEBUG photoForm: Updating existing photo at index", editIndex);
                updatedPhotos[editIndex] = photoData; // Modify the copy
            } else {
                console.error("Invalid index for editing photo:", editIndex);
                showNotification("Error: Could not update photo due to invalid index.", 'error');
                console.log("DEBUG photoForm: Invalid index, stopping processing");
                return; // Stop processing
            }
        }
        
        // Attempt to save the ENTIRE updated COPY array with button reference
        console.log("DEBUG photoForm: Calling saveData with updated photos array");
        isSuccess = await saveData('images', updatedPhotos, photoSubmitButton);
        console.log("DEBUG photoForm: Save result:", isSuccess);
        
        // Handle result
        if (isSuccess) {
            console.log("DEBUG photoForm: Save successful, updating local array and UI");
            // Force reload data from server to ensure sync
            await loadPhotos();  // Reload to sync
            
            const openStates = getOpenTripGroupStates(); // Remember state BEFORE re-render
            renderGroupedPhotoLists();                  // Re-render table
            applyOpenTripGroupStates(openStates);       // Apply state AFTER re-render
            
            resetPhotoForm();       // Reset form
        } else {
            // FAILURE: Notification already shown by saveData
            // Do nothing here, original 'photos' array is unchanged
            // Form is not reset, allowing user to retry
            console.log("DEBUG photoForm: Save failed. Local data array remains unchanged.");
        }
    });
}

// Photo cancel button handler
if (photoCancelButton) {
    photoCancelButton.addEventListener('click', resetPhotoForm);
}

// --- Project Management Functions ---
async function loadProjects() {
    toggleLoading(true);
    try {
        // Try to load projects.json, create it if it doesn't exist
        const response = await fetch('/api/data/projects', {
            credentials: 'include'  // Sends/receives cookies
        });
        if (!response.ok) {
            console.log("projects.json not found, using empty array");
            projects = [];
        } else {
            const data = await response.json();
            projects = Array.isArray(data) ? data : [];
        }
        renderProjectList();
        // Set up skills autocomplete after loading projects
        await setupSkillsAutocomplete();
    } catch (error) {
        console.error("Could not load projects:", error);
        showNotification("Error loading projects: " + error.message, 'error');
        projects = []; // Use empty array
        if (projectTableBody) {
            projectTableBody.innerHTML = `<tr><td colspan="4">Error loading projects. Check console or ensure 'data/projects.json' exists and is valid JSON. ${error.message}</td></tr>`;
        }
    } finally {
        toggleLoading(false);
    }
}

function renderProjectList() {
    console.log("DEBUG renderProjectList: Starting to render project list");
    if (!projectTableBody) {
        console.log("DEBUG renderProjectList: projectTableBody not found, exiting");
        return;
    }
    projectTableBody.innerHTML = '';
    
    console.log(`DEBUG renderProjectList: Projects array length: ${projects.length}`);
    if (projects.length === 0) {
        console.log("DEBUG renderProjectList: No projects found");
        projectTableBody.innerHTML = '<tr><td colspan="4">No projects found. Use "Generate Projects JSON" to create initial data.</td></tr>';
        return;
    }
    
    projects.forEach((project, index) => {
        console.log(`DEBUG renderProjectList: Rendering project at index ${index}:`, project);
        console.log(`DEBUG renderProjectList: Project image path: "${project.image}"`);
        
        const row = projectTableBody.insertRow();
        row.className = 'sortable-row';
        row.dataset.id = project.id || `project-${index}`;
        
        // Add drag handle
        const dragCell = row.insertCell();
        dragCell.className = 'drag-handle';
        dragCell.innerHTML = '☰';
        
        row.insertCell().textContent = project.title || 'N/A';
        row.insertCell().textContent = project.status || 'N/A';
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-project-btn">Edit</button>
            <button data-index="${index}" class="delete-project-btn">Delete</button>
        `;
    });
    
    // Add event listeners to the buttons
    document.querySelectorAll('.edit-project-btn').forEach(button => {
        button.addEventListener('click', handleEditProject);
    });
    
    document.querySelectorAll('.delete-project-btn').forEach(button => {
        button.addEventListener('click', handleDeleteProject);
    });
    
    // Initialize sortable on the project table
    initializeProjectSortable();
}

/**
 * Initializes sortable functionality on the project table.
 */
function initializeProjectSortable() {
    if (typeof Sortable === 'undefined') {
        console.warn('Sortable.js not loaded, skipping project sortable initialization');
        return;
    }
    
    const tbody = document.getElementById('projectTableBody');
    if (!tbody) return;
    
    new Sortable(tbody, {
        handle: '.drag-handle',
        animation: 150,
        onEnd: handleProjectReorder
    });
}

/**
 * Handles project reorder after drag.
 * @param {Event} evt - Sortable event object
 */
async function handleProjectReorder(evt) {
    // Collect current row order
    const rows = Array.from(projectTableBody.querySelectorAll('tr'));
    const reorderedData = rows.map((row, idx) => ({
        id: row.dataset.id,
        idx: idx
    }));
    
    try {
        const response = await fetch('/api/projects/reorder', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify(reorderedData)
        });
        
        if (response.ok) {
            showNotification('Project order saved successfully', 'success');
            // Reload projects to sync with server
            await loadProjects();
        } else {
            const error = await response.json();
            showNotification('Failed to save project order: ' + (error.error || 'Unknown error'), 'error');
            // Reload to restore original order
            await loadProjects();
        }
    } catch (error) {
        console.error('Error reordering projects:', error);
        showNotification('Error saving project order: ' + error.message, 'error');
        // Reload to restore original order
        await loadProjects();
    }
}

function handleEditProject(event) {
    const index = event.target.dataset.index;
    const project = projects[index];
    
    // Set form fields
    projectEditIndex.value = index;
    projectIdInput.value = project.id || '';
    projectTitleInput.value = project.title || '';
    
    // Store the existing path in the hidden input
    document.getElementById('currentProjectImage').value = project.image || '';
    // Clear the file input field
    document.getElementById('projectFile').value = null;
    
    projectSummaryInput.value = project.summary || '';
    // Populate CV Summary - use cvSummary if available, otherwise fall back to general summary
    document.getElementById('projectCvSummary').value = project.cvSummary || project.summary || '';
    projectRoleInput.value = project.role || '';
    projectSkillsInput.value = Array.isArray(project.skills) ? project.skills.join(', ') : '';
    projectStatusInput.value = project.status || '';
    // Set showOnCv checkbox - default to true if not specified
    document.getElementById('projectShowOnCv').checked = project.showOnCv !== false;
    
    // Populate dynamic links
    projectLinksContainer.innerHTML = ''; // Clear existing rows first
    let hasLinks = false;
    if (project.links && typeof project.links === 'object') {
        Object.entries(project.links).forEach(([type, url]) => {
            if (url) { // Only create rows for links that have a URL
                const linkRow = createLinkRow(type, url);
                projectLinksContainer.appendChild(linkRow);
                hasLinks = true;
            }
        });
    }
    // Show/hide the 'no links' message
    if(noLinksMsg) noLinksMsg.style.display = hasLinks ? 'none' : 'block';
    
    // Set the EasyMDE content
    if (easyMDEInstance) {
        easyMDEInstance.value(project.detailMarkdown || '');
    }
    
    // Change button text and show cancel button
    projectSubmitButton.textContent = 'Update Project';
    projectCancelButton.style.display = 'inline-block';
    
    // Scroll to the form
    projectForm.scrollIntoView({ behavior: 'smooth' });
}

async function handleDeleteProject(event) {
    const index = parseInt(event.target.dataset.index, 10);
    const project = projects[index];
    
    if (confirm(`Are you sure you want to delete the project "${project.title}"?`)) {
        let isSuccess = false;
        
        // Create a copy and modify it
        const updatedProjects = [...projects]; // Create a shallow copy
        if (index >= 0 && index < updatedProjects.length) {
            updatedProjects.splice(index, 1); // Modify the copy
        } else {
            console.error("Invalid index for deleting project:", index);
            showNotification("Error: Could not delete project due to invalid index.", 'error');
            return; // Stop processing
        }
        
        // Attempt to save the ENTIRE updated COPY array
        isSuccess = await saveData('projects', updatedProjects);
        
        // Handle result
        if (isSuccess) {
            // Force reload data from server to ensure sync
            await loadProjects();  // Reload to sync
            // Reset form if the deleted item was being edited
            if (parseInt(projectEditIndex.value, 10) === index) {
                resetProjectForm();
            }
        } else {
            // FAILURE: Alert already shown by saveData
            // Do nothing here, original 'projects' array is unchanged
            console.log("Delete failed. Local data array remains unchanged.");
        }
    }
}

function resetProjectForm() {
    projectEditIndex.value = '-1';
    projectForm.reset();
    
    // Clear the file input and current path
    document.getElementById('projectFile').value = null;
    document.getElementById('currentProjectImage').value = '';
    
    // Clear the width and height values
    document.getElementById('projectFullWidth').value = '';
    document.getElementById('projectFullHeight').value = '';
    
    // Clear the EasyMDE editor
    if (easyMDEInstance) {
        easyMDEInstance.value('');
    }
    
    // Clear dynamic links
    if (projectLinksContainer) projectLinksContainer.innerHTML = '';
    if(noLinksMsg) noLinksMsg.style.display = 'block'; // Show 'no links' message
    
    // Reset button text and hide cancel button
    projectSubmitButton.textContent = 'Add Project';
    projectCancelButton.style.display = 'none';
}

// Add event listeners for the project form
if (projectForm) {
    projectForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        console.log("DEBUG projectForm: Form submission started");
        
        try {
            // First, handle the file upload if a file is selected
            console.log("DEBUG projectForm: Calling uploadFile('projectFile')");
            const uploadResult = await uploadFile('projectFile');
            console.log("DEBUG projectForm: Upload Result:", uploadResult);
            
            // If upload failed, stop processing. Error notification already shown by uploadFile
            if (!uploadResult.success && uploadResult.error !== undefined) {
                console.log("DEBUG projectForm: Upload failed, stopping form processing");
                return;
            }
            
            // Get the existing filename from hidden input
            const existingFilename = document.getElementById('currentProjectImage').value;
            console.log("DEBUG projectForm: Existing Filename:", existingFilename);
            
            // Determine the image filename to use
            let imageFilename;
            if (uploadResult.filename) {
                // If a new file was uploaded, use its filename
                imageFilename = uploadResult.filename;
                console.log("DEBUG projectForm: Using new uploaded filename");
            } else {
                // If no new file, use the existing filename from hidden input
                imageFilename = existingFilename;
                console.log("DEBUG projectForm: Using existing filename (no new file)");
            }
            console.log("DEBUG projectForm: Final Image Filename:", imageFilename);
            
            // Parse skills string to array
            const skillsArray = projectSkillsInput.value
                .split(',')
                .map(skill => skill.trim())
                .filter(skill => skill !== '');
            console.log("DEBUG projectForm: Skills Array:", skillsArray);
            
            // Collect links from dynamic UI
            const collectedLinks = {};
            const linkRows = projectLinksContainer.querySelectorAll('.project-link-row');
            linkRows.forEach(rowDiv => {
                const typeSelect = rowDiv.querySelector('.project-link-type');
                const urlInput = rowDiv.querySelector('.project-link-url');
                if (typeSelect && urlInput) {
                    const linkType = typeSelect.value; // e.g., 'github', 'demo'
                    const linkUrl = urlInput.value.trim();
                    if (linkUrl) { // Only add if URL is not empty
                        collectedLinks[linkType] = linkUrl;
                    }
                }
            });
            console.log("DEBUG projectForm: Collected Links:", collectedLinks);
            
            // Get markdown content from EasyMDE
            const markdownContent = easyMDEInstance ? easyMDEInstance.value() : '';
            console.log("DEBUG projectForm: Markdown Content Length:", markdownContent.length);
            
            // Read dimensions from hidden inputs
            const widthVal = document.getElementById('projectFullWidth').value;
            const heightVal = document.getElementById('projectFullHeight').value;
            const fullWidth = parseInt(widthVal, 10) || null; // Use null if not available
            const fullHeight = parseInt(heightVal, 10) || null;
            
            // Create project data object
            const projectData = {
                id: projectIdInput.value,
                title: projectTitleInput.value,
                image: imageFilename, // Just storing the filename
                summary: projectSummaryInput.value,
                cvSummary: document.getElementById('projectCvSummary').value || '', // Add CV-specific summary
                role: projectRoleInput.value,
                skills: skillsArray,
                links: collectedLinks,
                status: projectStatusInput.value,
                showOnCv: document.getElementById('projectShowOnCv').checked, // Add CV visibility flag
                fullWidth: fullWidth, // Add width from hidden input
                fullHeight: fullHeight, // Add height from hidden input
                detailMarkdown: markdownContent
            };
            console.log("DEBUG projectForm: Project Data Object:", projectData);
            
            const editIndex = projectEditIndex.value === '-1' ? -1 : parseInt(projectEditIndex.value, 10);
            console.log("DEBUG projectForm: Edit Index:", editIndex, "isNew:", editIndex === -1);
            let isSuccess = false;
            
            // Create a copy and modify it
            const updatedProjects = [...projects]; // Create a shallow copy
            if (editIndex === -1) {
                console.log("DEBUG projectForm: Adding new project to beginning of array");
                updatedProjects.unshift(projectData); // Add to beginning of the copy
            } else {
                if (editIndex >= 0 && editIndex < updatedProjects.length) {
                    console.log("DEBUG projectForm: Updating existing project at index", editIndex);
                    updatedProjects[editIndex] = projectData; // Modify the copy
                } else {
                    console.error("Invalid index for editing project:", editIndex);
                    showNotification("Error: Could not update project due to invalid index.", 'error');
                    console.log("DEBUG projectForm: Invalid index, stopping processing");
                    return; // Stop processing
                }
            }
            
            // Attempt to save the ENTIRE updated COPY array with button reference
            console.log("DEBUG projectForm: Calling saveData with updated projects array");
            isSuccess = await saveData('projects', updatedProjects, projectSubmitButton);
            console.log("DEBUG projectForm: Save result:", isSuccess);
            
            // Handle result
            if (isSuccess) {
                console.log("DEBUG projectForm: Save successful, updating local array and UI");
                // Force reload data from server to ensure sync
                await loadProjects();  // Reload to sync
                resetProjectForm();         // Reset form
            } else {
                // FAILURE: Notification already shown by saveData
                // Do nothing here, original 'projects' array is unchanged
                // Form is not reset, allowing user to retry
                console.log("DEBUG projectForm: Save failed. Local data array remains unchanged.");
            }
        } catch (error) {
            console.error('Error saving project:', error);
            showNotification('An error occurred while saving the project: ' + error.message, 'error');
            console.log("DEBUG projectForm: Exception caught:", error);
        }
    });
}

if (projectCancelButton) {
    projectCancelButton.addEventListener('click', resetProjectForm);
}

/**
 * Sets up autocomplete for project skills input using allSkillsCache.
 */
async function setupSkillsAutocomplete() {
    try {
        // Fetch skills data to get allSkillsCache
        const response = await fetch('/api/data/cv/skills', {
            credentials: 'include'
        });
        
        if (!response.ok) {
            console.warn('Could not fetch skills for autocomplete');
            return;
        }
        
        const skillsData = await response.json();
        const allSkills = skillsData.allSkillsCache || [];
        
        // Create or update datalist
        let datalist = document.getElementById('skillsSuggestions');
        if (!datalist) {
            datalist = document.createElement('datalist');
            datalist.id = 'skillsSuggestions';
            document.body.appendChild(datalist);
        }
        
        // Clear existing options
        datalist.innerHTML = '';
        
        // Add options for each skill
        allSkills.forEach(skill => {
            const option = document.createElement('option');
            option.value = skill;
            datalist.appendChild(option);
        });
        
        // Set the datalist on all skill inputs
        const skillInputs = [
            document.getElementById('projectSkills'),
            document.getElementById('workSkills'),
            document.getElementById('researchSkills')
        ];
        
        skillInputs.forEach(skillsInput => {
            if (skillsInput) {
                skillsInput.setAttribute('list', 'skillsSuggestions');
                
                // Add custom autocomplete for comma-separated values
                skillsInput.addEventListener('input', function(e) {
                    const value = e.target.value;
                    const parts = value.split(',');
                    const lastPart = parts[parts.length - 1].trim();
                    
                    if (lastPart.length > 0) {
                        // Filter suggestions based on the last part
                        datalist.innerHTML = '';
                        allSkills
                            .filter(skill => skill.toLowerCase().startsWith(lastPart.toLowerCase()))
                            .forEach(skill => {
                                const option = document.createElement('option');
                                // Set value to complete the current input
                                const prefix = parts.slice(0, -1).join(', ');
                                option.value = prefix ? prefix + ', ' + skill : skill;
                                datalist.appendChild(option);
                            });
                    }
                });
            }
        });
    } catch (error) {
        console.error('Error setting up skills autocomplete:', error);
    }
}

// Manual save section has been removed as we now save directly to the API

// CV Management Functions
async function loadCvData() {
    console.log("Loading CV data...");
    toggleLoading(true);
    try {
        const results = await Promise.allSettled([
            fetchCvSection('education'),
            fetchCvSection('work'),
            fetchCvSection('research'),
            fetchCvSection('projects'),
            fetchCvSection('skills'),
            fetchCvSection('achievements'),
            fetchCvSection('positions')
        ]);

        // Process results and show errors if any
        let errors = [];
        results.forEach((result, index) => {
            const sections = ['education', 'work', 'research', 'projects', 'skills', 'achievements', 'positions'];
            const section = sections[index];
            
            if (result.status === 'fulfilled') {
                console.log(`Successfully loaded CV ${section} data`);
            } else {
                console.error(`Failed to load CV ${section} data:`, result.reason);
                errors.push(`${section}: ${result.reason.message}`);
            }
        });

        // Show error notification if any
        if (errors.length > 0) {
            showNotification(`Error loading some CV data: ${errors.join('; ')}`, 'error');
        }

        // Render the tables now that data is loaded
        renderCvEducationTable();
        renderCvWorkTable();
        renderCvResearchTable();
        renderCvSkillsForm();
        renderCvAchievementsTable();
        renderCvPositionsTable();

    } catch (error) {
        console.error("Failed to load CV data:", error);
        showNotification(`Error loading CV data: ${error.message}`, 'error');
    } finally {
        toggleLoading(false);
    }
}

async function fetchCvSection(section) {
    try {
        const response = await fetch(`/api/data/cv/${section}`, {
            credentials: 'include'  // Sends/receives cookies
        });
        if (!response.ok) {
            let errorMsg = `HTTP error! Status: ${response.status}`;
            try { 
                const errData = await response.json(); 
                errorMsg += ` - ${errData.error || 'Unknown'}`; 
            } catch(e) {}
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        
        // Update the global variable based on the section
        switch(section) {
            case 'education':
                cvEducation = Array.isArray(data) ? data : [];
                break;
            case 'work':
                cvWork = Array.isArray(data) ? data : [];
                break;
            case 'research':
                cvResearch = Array.isArray(data) ? data : [];
                break;
            case 'projects':
                cvProjects = Array.isArray(data) ? data : [];
                break;
            case 'skills':
                cvSkills = (typeof data === 'object' && data !== null) ? data : { programming: [], software: [], technical: [] };
                break;
            case 'achievements':
                cvAchievements = Array.isArray(data) ? data : [];
                break;
            case 'positions':
                cvPositions = Array.isArray(data) ? data : [];
                break;
        }
        
        return data;
    } catch (error) {
        console.error(`Error fetching CV ${section} data:`, error);
        // Show error in the corresponding table
        const tableBody = document.getElementById(`${section}TableBody`);
        if (tableBody) {
            tableBody.innerHTML = `<tr><td colspan="4">Error loading ${section} data: ${error.message}</td></tr>`;
        }
        throw error; // Re-throw to propagate
    }
}

// Function to save a specific CV section
async function saveCvData(section, data, buttonElement = null) {
    return await saveData(`cv/${section}`, data, buttonElement);
}

// CV Sub-Tab Handling

/**
 * Sets up the CV sub-tab navigation
 */
function setupCvTabNavigation() {
    const cvTabNav = document.querySelector('.cv-tab-nav');
    
    if (cvTabNav) {
        cvTabNav.addEventListener('click', (event) => {
            // Check if the clicked element is a CV tab link
            if (event.target.matches('a.cv-tab-link')) {
                event.preventDefault();
                
                const clickedTab = event.target;
                const targetTab = clickedTab.dataset.cvTab;
                
                // Remove active class from all CV tabs and panes
                cvTabNav.querySelectorAll('.cv-tab-link').forEach(tab => {
                    tab.classList.remove('active');
                });
                document.querySelectorAll('.cv-tab-pane').forEach(pane => {
                    pane.classList.remove('active');
                });
                
                // Add active class to clicked tab and corresponding pane
                clickedTab.classList.add('active');
                document.getElementById(`cv${targetTab.charAt(0).toUpperCase() + targetTab.slice(1)}Section`).classList.add('active');
            }
        });
    }
}

// --- Education Management ---
function renderCvEducationTable() {
    const tableBody = document.getElementById('educationTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    cvEducation.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = item.institution || 'N/A';
        row.insertCell().textContent = item.degree || 'N/A';
        row.insertCell().textContent = item.dates || 'N/A';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-education-btn">Edit</button>
            <button data-index="${index}" class="delete-education-btn">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-education-btn').forEach(btn => {
        btn.addEventListener('click', handleEditEducation);
    });
    
    document.querySelectorAll('.delete-education-btn').forEach(btn => {
        btn.addEventListener('click', handleDeleteEducation);
    });
}

function handleEditEducation(event) {
    const index = event.target.dataset.index;
    const item = cvEducation[index];
    
    document.getElementById('educationEditIndex').value = index;
    document.getElementById('educationInstitution').value = item.institution || '';
    document.getElementById('educationDegree').value = item.degree || '';
    document.getElementById('educationHonours').value = item.honours || '';
    document.getElementById('educationDates').value = item.dates || '';
    
    document.getElementById('educationSubmitButton').textContent = 'Update Entry';
    document.getElementById('educationCancelButton').style.display = 'inline-block';
    
    document.getElementById('educationForm').scrollIntoView({ behavior: 'smooth' });
}

async function handleDeleteEducation(event) {
    const index = parseInt(event.target.dataset.index);
    const item = cvEducation[index];
    
    if (confirm(`Are you sure you want to delete the education entry for "${item.institution || 'Unknown Institution'}"?`)) {
        const updatedEducation = [...cvEducation];
        updatedEducation.splice(index, 1);
        
        const isSuccess = await saveCvData('education', updatedEducation);
        
        if (isSuccess) {
            cvEducation = updatedEducation;
            renderCvEducationTable();
            
            if (parseInt(document.getElementById('educationEditIndex').value) === index) {
                resetEducationForm();
            }
        }
    }
}

function resetEducationForm() {
    document.getElementById('educationEditIndex').value = '-1';
    document.getElementById('educationForm').reset();
    document.getElementById('educationSubmitButton').textContent = 'Add Entry';
    document.getElementById('educationCancelButton').style.display = 'none';
}

// Education form submit handler
const educationForm = document.getElementById('educationForm');
if (educationForm) {
    educationForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = {
            institution: document.getElementById('educationInstitution').value,
            degree: document.getElementById('educationDegree').value,
            honours: document.getElementById('educationHonours').value,
            dates: document.getElementById('educationDates').value
        };
        
        const editIndex = document.getElementById('educationEditIndex').value;
        const index = editIndex === '-1' ? -1 : parseInt(editIndex);
        
        const updatedEducation = [...cvEducation];
        
        if (index === -1) {
            updatedEducation.unshift(formData);
        } else {
            updatedEducation[index] = formData;
        }
        
        const isSuccess = await saveCvData('education', updatedEducation);
        
        if (isSuccess) {
            cvEducation = updatedEducation;
            renderCvEducationTable();
            resetEducationForm();
        }
    });
}

// Education cancel button
const educationCancelButton = document.getElementById('educationCancelButton');
if (educationCancelButton) {
    educationCancelButton.addEventListener('click', resetEducationForm);
}

// --- Work Experience Management ---
function renderCvWorkTable() {
    const tableBody = document.getElementById('workTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    cvWork.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = item.title || 'N/A';
        row.insertCell().textContent = item.company || 'N/A';
        row.insertCell().textContent = item.dates || 'N/A';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-work-btn">Edit</button>
            <button data-index="${index}" class="delete-work-btn">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-work-btn').forEach(btn => {
        btn.addEventListener('click', handleEditWork);
    });
    
    document.querySelectorAll('.delete-work-btn').forEach(btn => {
        btn.addEventListener('click', handleDeleteWork);
    });
}

function handleEditWork(event) {
    const index = event.target.dataset.index;
    const item = cvWork[index];
    
    document.getElementById('workEditIndex').value = index;
    document.getElementById('workTitle').value = item.title || '';
    document.getElementById('workCompany').value = item.company || '';
    document.getElementById('workDates').value = item.dates || '';
    document.getElementById('workDescription').value = item.description || '';
    document.getElementById('workSkills').value = (item.skills || []).join(', ');
    
    document.getElementById('workSubmitButton').textContent = 'Update Entry';
    document.getElementById('workCancelButton').style.display = 'inline-block';
    
    document.getElementById('workForm').scrollIntoView({ behavior: 'smooth' });
}

async function handleDeleteWork(event) {
    const index = parseInt(event.target.dataset.index);
    const item = cvWork[index];
    
    if (confirm(`Are you sure you want to delete the work entry "${item.title || 'Unknown Position'}" at "${item.company || 'Unknown Company'}"?`)) {
        const updatedWork = [...cvWork];
        updatedWork.splice(index, 1);
        
        const isSuccess = await saveCvData('work', updatedWork);
        
        if (isSuccess) {
            cvWork = updatedWork;
            renderCvWorkTable();
            
            if (parseInt(document.getElementById('workEditIndex').value) === index) {
                resetWorkForm();
            }
        }
    }
}

function resetWorkForm() {
    document.getElementById('workEditIndex').value = '-1';
    document.getElementById('workForm').reset();
    document.getElementById('workSubmitButton').textContent = 'Add Entry';
    document.getElementById('workCancelButton').style.display = 'none';
}

// Work form submit handler
const workForm = document.getElementById('workForm');
if (workForm) {
    workForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = {
            title: document.getElementById('workTitle').value,
            company: document.getElementById('workCompany').value,
            dates: document.getElementById('workDates').value,
            description: document.getElementById('workDescription').value,
            skills: document.getElementById('workSkills').value
                .split(',').map(s => s.trim()).filter(s => s)
        };
        
        const editIndex = document.getElementById('workEditIndex').value;
        const index = editIndex === '-1' ? -1 : parseInt(editIndex);
        
        const updatedWork = [...cvWork];
        
        if (index === -1) {
            updatedWork.unshift(formData);
        } else {
            updatedWork[index] = formData;
        }
        
        const isSuccess = await saveCvData('work', updatedWork);
        
        if (isSuccess) {
            cvWork = updatedWork;
            renderCvWorkTable();
            resetWorkForm();
        }
    });
}

// Work cancel button
const workCancelButton = document.getElementById('workCancelButton');
if (workCancelButton) {
    workCancelButton.addEventListener('click', resetWorkForm);
}

// --- Research Experience Management ---
function renderCvResearchTable() {
    const tableBody = document.getElementById('researchTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    cvResearch.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = item.title || 'N/A';
        row.insertCell().textContent = item.organization || 'N/A';
        row.insertCell().textContent = item.dates || 'N/A';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-research-btn">Edit</button>
            <button data-index="${index}" class="delete-research-btn">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-research-btn').forEach(btn => {
        btn.addEventListener('click', handleEditResearch);
    });
    
    document.querySelectorAll('.delete-research-btn').forEach(btn => {
        btn.addEventListener('click', handleDeleteResearch);
    });
}

function handleEditResearch(event) {
    const index = event.target.dataset.index;
    const item = cvResearch[index];
    
    document.getElementById('researchEditIndex').value = index;
    document.getElementById('researchTitle').value = item.title || '';
    document.getElementById('researchOrganization').value = item.organization || '';
    document.getElementById('researchDates').value = item.dates || '';
    document.getElementById('researchDescription').value = item.description || '';
    document.getElementById('researchSkills').value = (item.skills || []).join(', ');
    
    document.getElementById('researchSubmitButton').textContent = 'Update Entry';
    document.getElementById('researchCancelButton').style.display = 'inline-block';
    
    document.getElementById('researchForm').scrollIntoView({ behavior: 'smooth' });
}

async function handleDeleteResearch(event) {
    const index = parseInt(event.target.dataset.index);
    const item = cvResearch[index];
    
    if (confirm(`Are you sure you want to delete the research entry "${item.title || 'Unknown Position'}" at "${item.organization || 'Unknown Organization'}"?`)) {
        const updatedResearch = [...cvResearch];
        updatedResearch.splice(index, 1);
        
        const isSuccess = await saveCvData('research', updatedResearch);
        
        if (isSuccess) {
            cvResearch = updatedResearch;
            renderCvResearchTable();
            
            if (parseInt(document.getElementById('researchEditIndex').value) === index) {
                resetResearchForm();
            }
        }
    }
}

function resetResearchForm() {
    document.getElementById('researchEditIndex').value = '-1';
    document.getElementById('researchForm').reset();
    document.getElementById('researchSubmitButton').textContent = 'Add Entry';
    document.getElementById('researchCancelButton').style.display = 'none';
}

// Research form submit handler
const researchForm = document.getElementById('researchForm');
if (researchForm) {
    researchForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = {
            title: document.getElementById('researchTitle').value,
            organization: document.getElementById('researchOrganization').value,
            dates: document.getElementById('researchDates').value,
            description: document.getElementById('researchDescription').value,
            skills: document.getElementById('researchSkills').value
                .split(',').map(s => s.trim()).filter(s => s)
        };
        
        const editIndex = document.getElementById('researchEditIndex').value;
        const index = editIndex === '-1' ? -1 : parseInt(editIndex);
        
        const updatedResearch = [...cvResearch];
        
        if (index === -1) {
            updatedResearch.unshift(formData);
        } else {
            updatedResearch[index] = formData;
        }
        
        const isSuccess = await saveCvData('research', updatedResearch);
        
        if (isSuccess) {
            cvResearch = updatedResearch;
            renderCvResearchTable();
            resetResearchForm();
        }
    });
}

// Research cancel button
const researchCancelButton = document.getElementById('researchCancelButton');
if (researchCancelButton) {
    researchCancelButton.addEventListener('click', resetResearchForm);
}

// --- Skills Management ---
let skillSortables = []; // Store sortable instances

/**
 * Loads and renders skills with drag init.
 */
async function loadSkills() {
    try {
        const response = await fetch('/api/data/cv/skills', {
            credentials: 'include'
        });
        
        if (!response.ok) {
            throw new Error(`Failed to load skills: ${response.statusText}`);
        }
        
        cvSkills = await response.json();
        renderSkills();
    } catch (error) {
        console.error('Error loading skills:', error);
        showNotification('Failed to load skills: ' + error.message, 'error');
    }
}

/**
 * Renders skill boxes in their respective categories.
 */
function renderSkills() {
    const categories = ['programming', 'software', 'technical', 'uncategorized'];
    
    categories.forEach(category => {
        const container = document.querySelector(`#${category}Skills .skills-list`);
        if (!container) return;
        
        // Clear existing content
        container.innerHTML = '';
        
        // Get skills for this category
        const skills = cvSkills[category] || [];
        
        // Render each skill
        skills.forEach(skill => {
            const skillBox = document.createElement('div');
            skillBox.className = 'skill-box';
            
            // Handle both string and object formats
            let projects = [];
            if (typeof skill === 'string') {
                skillBox.textContent = skill;
                skillBox.dataset.name = skill;
                skillBox.dataset.projects = '';
            } else if (skill && skill.name) {
                skillBox.textContent = skill.name;
                skillBox.dataset.name = skill.name;
                projects = skill.projects || [];
                skillBox.dataset.projects = projects.join(',');
            }
            
            // Add color coding based on skill source
            if (skill.source === 'role') {
                skillBox.classList.add('skill-role-only');
            } else if (projects.length > 0) {
                skillBox.classList.add('skill-derived');
            } else {
                skillBox.classList.add('skill-manual');
            }
            
            container.appendChild(skillBox);
        });
    });
    
    initializeSkillSortables();
}

/**
 * Initializes sortable on all skill categories.
 */
function initializeSkillSortables() {
    if (typeof Sortable === 'undefined') {
        console.warn('Sortable.js not loaded, skipping skills sortable initialization');
        return;
    }
    
    // Clean up existing sortables
    skillSortables.forEach(sortable => sortable.destroy());
    skillSortables = [];
    
    const categories = ['programming', 'software', 'technical', 'uncategorized'];
    
    categories.forEach(category => {
        const container = document.querySelector(`#${category}Skills .skills-list`);
        if (!container) return;
        
        const sortable = new Sortable(container, {
            group: 'skills', // Shared group allows cross-category dragging
            animation: 150,
            onAdd: handleSkillMove,
            onSort: handleSkillMove // Also handle reordering within same category
        });
        
        skillSortables.push(sortable);
    });
}

/**
 * Handles skill move between categories.
 * @param {Event} evt - Sortable event
 */
async function handleSkillMove(evt) {
    // Reconstruct the skills data from DOM
    const updatedSkills = {
        programming: [],
        software: [],
        technical: [],
        uncategorized: [],
        allSkillsCache: cvSkills.allSkillsCache || []
    };
    
    const categories = ['programming', 'software', 'technical', 'uncategorized'];
    
    categories.forEach(category => {
        const container = document.querySelector(`#${category}Skills .skills-list`);
        if (!container) return;
        
        const skillBoxes = container.querySelectorAll('.skill-box');
        updatedSkills[category] = Array.from(skillBoxes).map(box => ({
            name: box.dataset.name,
            projects: box.dataset.projects ? box.dataset.projects.split(',').filter(p => p) : []
        }));
    });
    
    // Save to server
    try {
        const response = await fetch('/api/save/cv/skills', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify(updatedSkills)
        });
        
        if (response.ok) {
            showNotification('Skills updated successfully', 'success');
            cvSkills = updatedSkills;
        } else {
            const error = await response.json();
            showNotification('Failed to save skills: ' + (error.error || 'Unknown error'), 'error');
            // Reload to restore original state
            await loadSkills();
        }
    } catch (error) {
        console.error('Error saving skills:', error);
        showNotification('Error saving skills: ' + error.message, 'error');
        // Reload to restore original state
        await loadSkills();
    }
}

// Add skill form handler
const addSkillForm = document.getElementById('addSkillForm');
if (addSkillForm) {
    addSkillForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const name = document.getElementById('newSkillName').value.trim();
        const category = document.getElementById('newSkillCategory').value;
        const projectsInput = document.getElementById('newSkillProjects').value;
        const projects = projectsInput ? projectsInput.split(',').map(p => p.trim()).filter(p => p) : [];
        
        if (!name) {
            showNotification('Please enter a skill name', 'error');
            return;
        }
        
        // Add to the appropriate category
        if (!cvSkills[category]) {
            cvSkills[category] = [];
        }
        
        // Check if skill already exists
        const exists = cvSkills[category].some(skill => 
            (typeof skill === 'string' && skill === name) ||
            (skill && skill.name === name)
        );
        
        if (exists) {
            showNotification('Skill already exists in this category', 'warning');
            return;
        }
        
        // Add the new skill
        cvSkills[category].push({
            name: name,
            projects: projects
        });
        
        // Save to server
        try {
            const response = await fetch('/api/save/cv/skills', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify(cvSkills)
            });
            
            if (response.ok) {
                showNotification('Skill added successfully', 'success');
                // Clear form
                addSkillForm.reset();
                // Re-render skills
                renderSkills();
            } else {
                const error = await response.json();
                showNotification('Failed to add skill: ' + (error.error || 'Unknown error'), 'error');
                // Remove the added skill
                cvSkills[category].pop();
            }
        } catch (error) {
            console.error('Error adding skill:', error);
            showNotification('Error adding skill: ' + error.message, 'error');
            // Remove the added skill
            cvSkills[category].pop();
        }
    });
}

// Replace the old renderCvSkillsForm with a call to loadSkills
function renderCvSkillsForm() {
    loadSkills();
}

// --- Achievements Management ---
function renderCvAchievementsTable() {
    const tableBody = document.getElementById('achievementsTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    cvAchievements.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = item.award || 'N/A';
        row.insertCell().textContent = item.year || 'N/A';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-achievements-btn">Edit</button>
            <button data-index="${index}" class="delete-achievements-btn">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-achievements-btn').forEach(btn => {
        btn.addEventListener('click', handleEditAchievements);
    });
    
    document.querySelectorAll('.delete-achievements-btn').forEach(btn => {
        btn.addEventListener('click', handleDeleteAchievements);
    });
}

function handleEditAchievements(event) {
    const index = event.target.dataset.index;
    const item = cvAchievements[index];
    
    document.getElementById('achievementsEditIndex').value = index;
    document.getElementById('achievementTitle').value = item.award || '';
    document.getElementById('achievementYear').value = item.year || '';
    
    document.getElementById('achievementsSubmitButton').textContent = 'Update Entry';
    document.getElementById('achievementsCancelButton').style.display = 'inline-block';
    
    document.getElementById('achievementsForm').scrollIntoView({ behavior: 'smooth' });
}

async function handleDeleteAchievements(event) {
    const index = parseInt(event.target.dataset.index);
    const item = cvAchievements[index];
    
    if (confirm(`Are you sure you want to delete the achievement "${item.award || 'Unknown Achievement'}"?`)) {
        const updatedAchievements = [...cvAchievements];
        updatedAchievements.splice(index, 1);
        
        const isSuccess = await saveCvData('achievements', updatedAchievements);
        
        if (isSuccess) {
            cvAchievements = updatedAchievements;
            renderCvAchievementsTable();
            
            if (parseInt(document.getElementById('achievementsEditIndex').value) === index) {
                resetAchievementsForm();
            }
        }
    }
}

function resetAchievementsForm() {
    document.getElementById('achievementsEditIndex').value = '-1';
    document.getElementById('achievementsForm').reset();
    document.getElementById('achievementsSubmitButton').textContent = 'Add Entry';
    document.getElementById('achievementsCancelButton').style.display = 'none';
}

// Achievements form submit handler
const achievementsForm = document.getElementById('achievementsForm');
if (achievementsForm) {
    achievementsForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = {
            award: document.getElementById('achievementTitle').value,
            year: document.getElementById('achievementYear').value
        };
        
        const editIndex = document.getElementById('achievementsEditIndex').value;
        const index = editIndex === '-1' ? -1 : parseInt(editIndex);
        
        const updatedAchievements = [...cvAchievements];
        
        if (index === -1) {
            updatedAchievements.unshift(formData);
        } else {
            updatedAchievements[index] = formData;
        }
        
        const isSuccess = await saveCvData('achievements', updatedAchievements);
        
        if (isSuccess) {
            cvAchievements = updatedAchievements;
            renderCvAchievementsTable();
            resetAchievementsForm();
        }
    });
}

// Achievements cancel button
const achievementsCancelButton = document.getElementById('achievementsCancelButton');
if (achievementsCancelButton) {
    achievementsCancelButton.addEventListener('click', resetAchievementsForm);
}

// --- Positions Management ---
function renderCvPositionsTable() {
    const tableBody = document.getElementById('positionsTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    cvPositions.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = item.role || 'N/A';
        row.insertCell().textContent = item.organization || 'N/A';
        row.insertCell().textContent = item.dates || 'N/A';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-positions-btn">Edit</button>
            <button data-index="${index}" class="delete-positions-btn">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-positions-btn').forEach(btn => {
        btn.addEventListener('click', handleEditPositions);
    });
    
    document.querySelectorAll('.delete-positions-btn').forEach(btn => {
        btn.addEventListener('click', handleDeletePositions);
    });
}

function handleEditPositions(event) {
    const index = event.target.dataset.index;
    const item = cvPositions[index];
    
    document.getElementById('positionsEditIndex').value = index;
    document.getElementById('positionTitle').value = item.role || '';
    document.getElementById('positionOrganization').value = item.organization || '';
    document.getElementById('positionDates').value = item.dates || '';
    document.getElementById('positionDescription').value = item.description || '';
    
    document.getElementById('positionsSubmitButton').textContent = 'Update Entry';
    document.getElementById('positionsCancelButton').style.display = 'inline-block';
    
    document.getElementById('positionsForm').scrollIntoView({ behavior: 'smooth' });
}

async function handleDeletePositions(event) {
    const index = parseInt(event.target.dataset.index);
    const item = cvPositions[index];
    
    if (confirm(`Are you sure you want to delete the position "${item.role || 'Unknown Position'}" at "${item.organization || 'Unknown Organization'}"?`)) {
        const updatedPositions = [...cvPositions];
        updatedPositions.splice(index, 1);
        
        const isSuccess = await saveCvData('positions', updatedPositions);
        
        if (isSuccess) {
            cvPositions = updatedPositions;
            renderCvPositionsTable();
            
            if (parseInt(document.getElementById('positionsEditIndex').value) === index) {
                resetPositionsForm();
            }
        }
    }
}

function resetPositionsForm() {
    document.getElementById('positionsEditIndex').value = '-1';
    document.getElementById('positionsForm').reset();
    document.getElementById('positionsSubmitButton').textContent = 'Add Entry';
    document.getElementById('positionsCancelButton').style.display = 'none';
}

// Positions form submit handler
const positionsForm = document.getElementById('positionsForm');
if (positionsForm) {
    positionsForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = {
            role: document.getElementById('positionTitle').value,
            organization: document.getElementById('positionOrganization').value,
            dates: document.getElementById('positionDates').value,
            description: document.getElementById('positionDescription').value
        };
        
        const editIndex = document.getElementById('positionsEditIndex').value;
        const index = editIndex === '-1' ? -1 : parseInt(editIndex);
        
        const updatedPositions = [...cvPositions];
        
        if (index === -1) {
            updatedPositions.unshift(formData);
        } else {
            updatedPositions[index] = formData;
        }
        
        const isSuccess = await saveCvData('positions', updatedPositions);
        
        if (isSuccess) {
            cvPositions = updatedPositions;
            renderCvPositionsTable();
            resetPositionsForm();
        }
    });
}

// Positions cancel button
const positionsCancelButton = document.getElementById('positionsCancelButton');
if (positionsCancelButton) {
    positionsCancelButton.addEventListener('click', resetPositionsForm);
}

// Legacy Page Content Functions - Kept for Research tab
async function loadPageContent() {
    console.log("Loading page content...");
    try {
        const response = await fetch('/api/data/page_content', {
            credentials: 'include'  // Sends/receives cookies
        });
        if (!response.ok) {
            // Try parsing error from backend
            let errorMsg = `HTTP error! Status: ${response.status}`;
             try { const errData = await response.json(); errorMsg += ` - ${errData.error || 'Unknown'}`; } catch(e){}
            throw new Error(errorMsg);
        }
        pageContent = await response.json();
        console.log("Page content loaded:", pageContent);
        populateContentEditors(); // Populate editors AFTER content is loaded
    } catch (error) {
        console.error("Failed to load page content:", error);
        alert(`Error loading page content: ${error.message}`);
        // Display error in editor containers
        const researchContainer = document.getElementById('researchEditorContainer');
        if (researchContainer) researchContainer.innerHTML = `<p style="color:red;">Failed to load Research content.</p>`;
    }
}

function populateContentEditors() {
    const researchContainer = document.getElementById('researchEditorContainer');

    if (!researchContainer) {
         console.error("Research editor container not found!");
         return;
    }
    researchContainer.innerHTML = '';
    pageContentEditors = {}; // Clear old instances

    // Sort keys for consistent order
    const sortedKeys = Object.keys(pageContent).sort();

    sortedKeys.forEach(key => {
        if (!key.startsWith('research_')) return; // Skip non-research keys
        
        const container = researchContainer;
        const editorWrapper = document.createElement('div');
        editorWrapper.style.marginBottom = '15px';

        const label = document.createElement('label');
        label.textContent = `Content for: ${key}`; // Use key as label
        label.style.fontWeight = 'bold';
        label.style.display = 'block';
        label.style.marginBottom = '5px';
        label.htmlFor = `page-content-${key}`;

        const textarea = document.createElement('textarea');
        textarea.id = `page-content-${key}`;

        editorWrapper.appendChild(label);
        editorWrapper.appendChild(textarea);
        container.appendChild(editorWrapper);

        // Initialize EasyMDE for this textarea
        try {
            const editorInstance = new EasyMDE({
                element: textarea,
                spellChecker: false,
                minHeight: '150px',
            });
            editorInstance.value(pageContent[key] || ''); // Set initial value
            pageContentEditors[key] = editorInstance; // Store the instance
        } catch (e) {
            console.error(`Failed to initialize EasyMDE for key ${key}:`, e);
            // Optionally display an error message instead of the editor
            textarea.value = `Error initializing editor for ${key}.`;
            textarea.disabled = true;
        }
    });
    console.log("Populated research content editors", pageContentEditors);
}

// Save button handler for research content
document.addEventListener('DOMContentLoaded', () => {
    // Research content save button
    const saveResearchContentButton = document.getElementById('saveResearchContentButton');
    if (saveResearchContentButton) {
        saveResearchContentButton.addEventListener('click', async () => {
            // Create a copy of the current content
            const updatedContent = { ...pageContent };
            
            // Update Research-related keys
            Object.keys(pageContentEditors).forEach(key => {
                if (key.startsWith('research_')) {
                    updatedContent[key] = pageContentEditors[key].value();
                }
            });
            
            // Save to server with button reference
            const isSuccess = await saveData('page_content', updatedContent, saveResearchContentButton);
            if (isSuccess) {
                // Update our local copy (notification shown by saveData)
                pageContent = updatedContent;
            }
        });
    }
});

// === Research Management Functions ===

// Load all research data from APIs
async function loadResearchData() {
    console.log("Loading research data...");
    toggleLoading(true);
    try {
        const results = await Promise.allSettled([
            fetchResearchSection('journal'),
            fetchResearchSection('thesis'),
            fetchResearchSection('conference'),
            fetchResearchSection('patent')
        ]);

        // Process results and show errors if any
        let errors = [];
        results.forEach((result, index) => {
            const sections = ['journal', 'thesis', 'conference', 'patent'];
            const section = sections[index];
            
            if (result.status === 'fulfilled') {
                console.log(`Successfully loaded research ${section} data`);
            } else {
                console.error(`Failed to load research ${section} data:`, result.reason);
                errors.push(`${section}: ${result.reason.message}`);
            }
        });

        // Show error notification if any
        if (errors.length > 0) {
            showNotification(`Error loading some research data: ${errors.join('; ')}`, 'error');
        }

        // Render the tables now that data is loaded
        renderResearchJournalTable();
        renderResearchThesisForm();
        renderResearchConferenceTable();
        renderResearchPatentTable();

    } catch (error) {
        console.error("Failed to load research data:", error);
        showNotification(`Error loading research data: ${error.message}`, 'error');
    } finally {
        toggleLoading(false);
    }
}

// Fetch a specific research section from the API
async function fetchResearchSection(section) {
    try {
        const response = await fetch(`/api/data/research/${section}`, {
            credentials: 'include'  // Sends/receives cookies
        });
        if (!response.ok) {
            let errorMsg = `HTTP error! Status: ${response.status}`;
            try { 
                const errData = await response.json(); 
                errorMsg += ` - ${errData.error || 'Unknown'}`; 
            } catch(e) {}
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        
        // Update the global variable based on the section
        switch(section) {
            case 'journal':
                researchJournal = Array.isArray(data) ? data : [];
                break;
            case 'thesis':
                researchThesis = (typeof data === 'object' && data !== null) ? data : {};
                break;
            case 'conference':
                researchConference = Array.isArray(data) ? data : [];
                break;
            case 'patent':
                researchPatent = Array.isArray(data) ? data : [];
                break;
        }
        
        return data;
    } catch (error) {
        console.error(`Error fetching research ${section} data:`, error);
        // Show error in the corresponding table
        const tableId = section === 'thesis' ? null : `research${section.charAt(0).toUpperCase() + section.slice(1)}TableBody`;
        if (tableId) {
            const tableBody = document.getElementById(tableId);
            if (tableBody) {
                tableBody.innerHTML = `<tr><td colspan="4">Error loading ${section} data: ${error.message}</td></tr>`;
            }
        }
        throw error; // Re-throw to propagate
    }
}

// Function to save a specific research section
async function saveResearchData(section, data) {
    return await saveData(`research/${section}`, data);
}

// Create a research link row for the form
function createResearchLinkRow(type = '', url = '') {
    const rowDiv = document.createElement('div');
    rowDiv.className = 'research-link-row';
    rowDiv.style.display = 'flex';
    rowDiv.style.marginBottom = '5px';
    rowDiv.style.gap = '5px'; // Add spacing between elements

    // Input for type
    const typeInput = document.createElement('input');
    typeInput.type = 'text';
    typeInput.className = 'research-link-type';
    typeInput.placeholder = 'Type (e.g., pdf, code, project)';
    typeInput.value = type;
    typeInput.style.width = '30%';

    // Input for URL
    const urlInput = document.createElement('input');
    urlInput.type = 'text';
    urlInput.className = 'research-link-url';
    urlInput.placeholder = 'Link URL (e.g., https://...)';
    urlInput.value = url;
    urlInput.style.flexGrow = '1'; // Allow URL input to take available space

    // Remove button
    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.textContent = 'Remove';
    removeButton.className = 'remove-link-button';
    removeButton.onclick = function() { 
        rowDiv.remove(); // Remove this row div
        // Check if container is empty and show message
        const parentId = rowDiv.parentNode.id;
        const noLinksMsg = document.getElementById(parentId.replace('Container', 'NoLinksMsg'));
        if (noLinksMsg && rowDiv.parentNode.querySelectorAll('.research-link-row').length === 0) {
            noLinksMsg.style.display = 'block';
        }
    };

    rowDiv.appendChild(typeInput);
    rowDiv.appendChild(urlInput);
    rowDiv.appendChild(removeButton);

    return rowDiv;
}

// Initialize EasyMDE for research form abstract fields
function initializeResearchEditors() {
    // Journal Abstract
    if (document.getElementById('journalAbstract') && !researchEditors.journal) {
        try {
            researchEditors.journal = new EasyMDE({
                element: document.getElementById('journalAbstract'),
                spellChecker: false,
                minHeight: "200px",
                toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "code", "|", "preview", "side-by-side", "fullscreen"]
            });
        } catch (e) {
            console.error("Failed to initialize Journal EasyMDE:", e);
        }
    }
    
    // Thesis Abstract
    if (document.getElementById('thesisAbstract') && !researchEditors.thesis) {
        try {
            researchEditors.thesis = new EasyMDE({
                element: document.getElementById('thesisAbstract'),
                spellChecker: false,
                minHeight: "200px",
                toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "code", "|", "preview", "side-by-side", "fullscreen"]
            });
        } catch (e) {
            console.error("Failed to initialize Thesis EasyMDE:", e);
        }
    }
    
    // Conference Abstract
    if (document.getElementById('conferenceAbstract') && !researchEditors.conference) {
        try {
            researchEditors.conference = new EasyMDE({
                element: document.getElementById('conferenceAbstract'),
                spellChecker: false,
                minHeight: "200px",
                toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "code", "|", "preview", "side-by-side", "fullscreen"]
            });
        } catch (e) {
            console.error("Failed to initialize Conference EasyMDE:", e);
        }
    }
    
    // Patent Abstract
    if (document.getElementById('patentAbstract') && !researchEditors.patent) {
        try {
            researchEditors.patent = new EasyMDE({
                element: document.getElementById('patentAbstract'),
                spellChecker: false,
                minHeight: "200px",
                toolbar: ["bold", "italic", "heading", "|", "quote", "unordered-list", "ordered-list", "|", "link", "code", "|", "preview", "side-by-side", "fullscreen"]
            });
        } catch (e) {
            console.error("Failed to initialize Patent EasyMDE:", e);
        }
    }
}

// Refresh EasyMDE editors when tab becomes visible
function refreshResearchEditors() {
    Object.keys(researchEditors).forEach(key => {
        if (researchEditors[key] && researchEditors[key].codemirror) {
            try {
                setTimeout(() => {
                    researchEditors[key].codemirror.refresh();
                    console.log(`${key} editor refreshed`);
                }, 10);
            } catch (e) {
                console.error(`Error refreshing ${key} editor:`, e);
            }
        }
    });
}

// --- Journal Articles Functions ---

function renderResearchJournalTable() {
    const tableBody = document.getElementById('researchJournalTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    if (researchJournal.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="4">No journal articles found. Use the "Add Journal Article" button below.</td></tr>';
        return;
    }
    
    researchJournal.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = item.title || 'N/A';
        row.insertCell().textContent = item.venue || 'N/A';
        row.insertCell().textContent = item.date || 'N/A';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-journal-btn">Edit</button>
            <button data-index="${index}" class="delete-journal-btn">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-journal-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const index = parseInt(this.dataset.index);
            showResearchEntryForm('journal', index);
        });
    });
    
    document.querySelectorAll('.delete-journal-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const index = parseInt(this.dataset.index);
            handleDeleteResearchEntry('journal', index);
        });
    });
}

// Journal Add Link button listener
const addJournalLinkButton = document.getElementById('addJournalLinkButton');
if (addJournalLinkButton) {
    addJournalLinkButton.addEventListener('click', function() {
        const container = document.getElementById('journalLinksContainer');
        const noLinksMsg = document.getElementById('journalNoLinksMsg');
        if (container) {
            const newRow = createResearchLinkRow(); // Create a new blank row
            container.appendChild(newRow);
            if (noLinksMsg) noLinksMsg.style.display = 'none'; // Hide the 'no links' message
        }
    });
}

// --- Thesis Functions ---

function renderResearchThesisForm() {
    // Initialize the editor first to avoid UI glitches
    if (!researchEditors.thesis) {
        initializeResearchEditors();
    }
    
    // Populate form fields
    const titleInput = document.getElementById('thesisTitle');
    const authorsInput = document.getElementById('thesisAuthors');
    const venueInput = document.getElementById('thesisVenue');
    const dateInput = document.getElementById('thesisDate');
    const linksContainer = document.getElementById('thesisLinksContainer');
    const noLinksMsg = document.getElementById('thesisNoLinksMsg');
    
    if (titleInput) titleInput.value = researchThesis.title || '';
    if (authorsInput) authorsInput.value = researchThesis.authors || '';
    if (venueInput) venueInput.value = researchThesis.venue || '';
    if (dateInput) dateInput.value = researchThesis.date || '';
    
    // Set abstract content if the editor is initialized
    if (researchEditors.thesis) {
        researchEditors.thesis.value(researchThesis.abstract || '');
    }
    
    // Clear and repopulate links
    if (linksContainer) {
        linksContainer.innerHTML = '';
        
        // Add the "no links" message back
        if (noLinksMsg) linksContainer.appendChild(noLinksMsg);
        
        // If there are links, add them as rows and hide the no links message
        let hasLinks = false;
        if (researchThesis.links && typeof researchThesis.links === 'object') {
            Object.entries(researchThesis.links).forEach(([type, url]) => {
                if (url) { // Only create rows for links that have a URL
                    const linkRow = createResearchLinkRow(type, url);
                    linksContainer.appendChild(linkRow);
                    hasLinks = true;
                }
            });
        }
        
        // Show/hide the 'no links' message
        if (noLinksMsg) noLinksMsg.style.display = hasLinks ? 'none' : 'block';
    }
}

// Thesis Add Link button listener
const addThesisLinkButton = document.getElementById('addThesisLinkButton');
if (addThesisLinkButton) {
    addThesisLinkButton.addEventListener('click', function() {
        const container = document.getElementById('thesisLinksContainer');
        const noLinksMsg = document.getElementById('thesisNoLinksMsg');
        if (container) {
            const newRow = createResearchLinkRow(); // Create a new blank row
            container.appendChild(newRow);
            if (noLinksMsg) noLinksMsg.style.display = 'none'; // Hide the 'no links' message
        }
    });
}

// Thesis Save button listener
const saveThesisButton = document.getElementById('saveThesisButton');
if (saveThesisButton) {
    saveThesisButton.addEventListener('click', async function() {
        // Gather form data
        const title = document.getElementById('thesisTitle').value;
        const authors = document.getElementById('thesisAuthors').value;
        const venue = document.getElementById('thesisVenue').value;
        const date = document.getElementById('thesisDate').value;
        const abstract = researchEditors.thesis ? researchEditors.thesis.value() : '';
        
        // Validate required fields
        if (!title || !authors || !venue) {
            showNotification("Please fill in all required fields.", 'error');
            return;
        }
        
        // Collect links
        const links = {};
        const linkRows = document.querySelectorAll('#thesisLinksContainer .research-link-row');
        linkRows.forEach(row => {
            const typeInput = row.querySelector('.research-link-type');
            const urlInput = row.querySelector('.research-link-url');
            if (typeInput && urlInput && typeInput.value && urlInput.value) {
                links[typeInput.value] = urlInput.value;
            }
        });
        
        // Create updated thesis data
        const updatedThesis = {
            title,
            authors,
            venue,
            date,
            abstract,
            links
        };
        
        // Save the data
        const isSuccess = await saveResearchData('thesis', updatedThesis);
        
        // Handle result
        if (isSuccess) {
            researchThesis = updatedThesis; // Update the local copy
            showNotification('Thesis data saved successfully!', 'success');
        }
    });
}

// --- Conference Papers Functions ---

function renderResearchConferenceTable() {
    const tableBody = document.getElementById('researchConferenceTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    if (researchConference.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="4">No conference papers found. Use the "Add Conference Paper" button below.</td></tr>';
        return;
    }
    
    researchConference.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = item.title || 'N/A';
        row.insertCell().textContent = item.venue || 'N/A';
        row.insertCell().textContent = item.date || 'N/A';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-conference-btn">Edit</button>
            <button data-index="${index}" class="delete-conference-btn">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-conference-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const index = parseInt(this.dataset.index);
            showResearchEntryForm('conference', index);
        });
    });
    
    document.querySelectorAll('.delete-conference-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const index = parseInt(this.dataset.index);
            handleDeleteResearchEntry('conference', index);
        });
    });
}

// Conference Add Link button listener
const addConferenceLinkButton = document.getElementById('addConferenceLinkButton');
if (addConferenceLinkButton) {
    addConferenceLinkButton.addEventListener('click', function() {
        const container = document.getElementById('conferenceLinksContainer');
        const noLinksMsg = document.getElementById('conferenceNoLinksMsg');
        if (container) {
            const newRow = createResearchLinkRow(); // Create a new blank row
            container.appendChild(newRow);
            if (noLinksMsg) noLinksMsg.style.display = 'none'; // Hide the 'no links' message
        }
    });
}

// --- Patent Functions ---

function renderResearchPatentTable() {
    const tableBody = document.getElementById('researchPatentTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    if (researchPatent.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="4">No patents found. Use the "Add Patent" button below.</td></tr>';
        return;
    }
    
    researchPatent.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.insertCell().textContent = item.title || 'N/A';
        row.insertCell().textContent = item.venue || 'N/A';
        row.insertCell().textContent = item.date || 'N/A';
        
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button data-index="${index}" class="edit-patent-btn">Edit</button>
            <button data-index="${index}" class="delete-patent-btn">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-patent-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const index = parseInt(this.dataset.index);
            showResearchEntryForm('patent', index);
        });
    });
    
    document.querySelectorAll('.delete-patent-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const index = parseInt(this.dataset.index);
            handleDeleteResearchEntry('patent', index);
        });
    });
}

// Patent Add Link button listener
const addPatentLinkButton = document.getElementById('addPatentLinkButton');
if (addPatentLinkButton) {
    addPatentLinkButton.addEventListener('click', function() {
        const container = document.getElementById('patentLinksContainer');
        const noLinksMsg = document.getElementById('patentNoLinksMsg');
        if (container) {
            const newRow = createResearchLinkRow(); // Create a new blank row
            container.appendChild(newRow);
            if (noLinksMsg) noLinksMsg.style.display = 'none'; // Hide the 'no links' message
        }
    });
}

// --- Generic Research Entry Form Functions ---

/**
 * Shows the form for adding or editing a research entry
 * @param {string} type - Type of research entry: 'journal', 'conference', or 'patent'
 * @param {number} index - Index of the entry to edit, or -1 for a new entry
 */
function showResearchEntryForm(type, index = -1) {
    // Get form and relevant data
    const formId = `research${type.charAt(0).toUpperCase() + type.slice(1)}Form`;
    const form = document.getElementById(formId);
    const dataArray = type === 'journal' ? researchJournal : 
                      type === 'conference' ? researchConference : 
                      type === 'patent' ? researchPatent : [];
                      
    // Initialize the editor if not already done
    if (!researchEditors[type]) {
        initializeResearchEditors();
    }
    
    if (!form) return;
    
    // Make form visible
    form.style.display = 'block';
    
    // Set up form for add or edit
    const editIndexInput = document.getElementById(`${type}EditIndex`);
    if (editIndexInput) editIndexInput.value = index;
    
    // Clear form or populate with existing data
    if (index === -1) {
        // Adding new entry - clear form
        resetResearchEntryForm(type);
    } else {
        // Editing existing entry - populate form
        const item = dataArray[index];
        if (!item) {
            console.error(`Invalid index ${index} for ${type} data`);
            return;
        }
        
        // Fill in the form fields
        document.getElementById(`${type}Id`).value = item.id || '';
        document.getElementById(`${type}Title`).value = item.title || '';
        document.getElementById(`${type}Authors`).value = item.authors || '';
        document.getElementById(`${type}Venue`).value = item.venue || '';
        document.getElementById(`${type}Date`).value = item.date || '';
        
        // Set abstract content in EasyMDE
        if (researchEditors[type]) {
            researchEditors[type].value(item.abstract || '');
        }
        
        // Clear and repopulate links
        const linksContainer = document.getElementById(`${type}LinksContainer`);
        const noLinksMsg = document.getElementById(`${type}NoLinksMsg`);
        if (linksContainer) {
            linksContainer.innerHTML = '';
            
            // Add the "no links" message back
            if (noLinksMsg) linksContainer.appendChild(noLinksMsg);
            
            // Add link rows for existing links
            let hasLinks = false;
            if (item.links && typeof item.links === 'object') {
                Object.entries(item.links).forEach(([linkType, url]) => {
                    if (url) { // Only create rows for links that have a URL
                        const linkRow = createResearchLinkRow(linkType, url);
                        linksContainer.appendChild(linkRow);
                        hasLinks = true;
                    }
                });
            }
            
            // Show/hide the 'no links' message
            if (noLinksMsg) noLinksMsg.style.display = hasLinks ? 'none' : 'block';
        }
        
        // Update submit button text
        const submitButton = document.getElementById(`${type}SubmitButton`);
        if (submitButton) {
            submitButton.textContent = `Update ${type.charAt(0).toUpperCase() + type.slice(1)}`;
        }
        
        // Show cancel button
        const cancelButton = document.getElementById(`${type}CancelButton`);
        if (cancelButton) {
            cancelButton.style.display = 'inline-block';
        }
    }
    
    // Refresh the EasyMDE editor to ensure it's visible and rendered properly
    if (researchEditors[type] && researchEditors[type].codemirror) {
        setTimeout(() => {
            researchEditors[type].codemirror.refresh();
        }, 10);
    }
    
    // Scroll to the form
    form.scrollIntoView({ behavior: 'smooth' });
}

// Reset a research entry form to default state
function resetResearchEntryForm(type) {
    const formId = `research${type.charAt(0).toUpperCase() + type.slice(1)}Form`;
    const form = document.getElementById(formId);
    const editIndexInput = document.getElementById(`${type}EditIndex`);
    
    if (!form || !editIndexInput) return;
    
    // Reset form state
    form.reset();
    editIndexInput.value = '-1';
    
    // Clear EasyMDE content
    if (researchEditors[type]) {
        researchEditors[type].value('');
    }
    
    // Clear links container
    const linksContainer = document.getElementById(`${type}LinksContainer`);
    const noLinksMsg = document.getElementById(`${type}NoLinksMsg`);
    if (linksContainer) {
        linksContainer.innerHTML = '';
        
        // Add the "no links" message back
        if (noLinksMsg) {
            linksContainer.appendChild(noLinksMsg);
            noLinksMsg.style.display = 'block';
        }
    }
    
    // Update submit button text
    const submitButton = document.getElementById(`${type}SubmitButton`);
    if (submitButton) {
        submitButton.textContent = `Save ${type.charAt(0).toUpperCase() + type.slice(1)}`;
    }
    
    // Hide cancel button
    const cancelButton = document.getElementById(`${type}CancelButton`);
    if (cancelButton) {
        cancelButton.style.display = 'none';
    }
}

// Handle deleting a research entry
async function handleDeleteResearchEntry(type, index) {
    // Determine which data array to use
    let dataArray, renderFunction;
    switch (type) {
        case 'journal':
            dataArray = researchJournal;
            renderFunction = renderResearchJournalTable;
            break;
        case 'conference':
            dataArray = researchConference;
            renderFunction = renderResearchConferenceTable;
            break;
        case 'patent':
            dataArray = researchPatent;
            renderFunction = renderResearchPatentTable;
            break;
        default:
            console.error(`Invalid research type: ${type}`);
            return;
    }
    
    const item = dataArray[index];
    if (!item) {
        console.error(`Invalid index ${index} for ${type} data`);
        return;
    }
    
    // Confirm deletion
    if (!confirm(`Are you sure you want to delete "${item.title || 'Untitled'}"?`)) {
        return;
    }
    
    // Create a copy of the array and remove the item
    const updatedArray = [...dataArray];
    updatedArray.splice(index, 1);
    
    // Save the updated array
    const isSuccess = await saveResearchData(type, updatedArray);
    
    // Handle result
    if (isSuccess) {
        // Update the local data and re-render
        switch (type) {
            case 'journal': researchJournal = updatedArray; break;
            case 'conference': researchConference = updatedArray; break;
            case 'patent': researchPatent = updatedArray; break;
        }
        
        renderFunction();
        
        // Reset form if currently editing the deleted item
        const editIndexInput = document.getElementById(`${type}EditIndex`);
        if (editIndexInput && parseInt(editIndexInput.value) === index) {
            resetResearchEntryForm(type);
            
            // Also hide the form
            const form = document.getElementById(`research${type.charAt(0).toUpperCase() + type.slice(1)}Form`);
            if (form) form.style.display = 'none';
        }
    }
}

// Set up form submit handlers for research entries
document.addEventListener('DOMContentLoaded', function() {
    // Journal form submit
    const journalForm = document.getElementById('researchJournalForm');
    if (journalForm) {
        journalForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            await handleResearchFormSubmit('journal');
        });
    }
    
    // Conference form submit
    const conferenceForm = document.getElementById('researchConferenceForm');
    if (conferenceForm) {
        conferenceForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            await handleResearchFormSubmit('conference');
        });
    }
    
    // Patent form submit
    const patentForm = document.getElementById('researchPatentForm');
    if (patentForm) {
        patentForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            await handleResearchFormSubmit('patent');
        });
    }
    
    // Cancel buttons
    const cancelButtons = {
        journal: document.getElementById('journalCancelButton'),
        conference: document.getElementById('conferenceCancelButton'),
        patent: document.getElementById('patentCancelButton')
    };
    
    Object.entries(cancelButtons).forEach(([type, button]) => {
        if (button) {
            button.addEventListener('click', function() {
                resetResearchEntryForm(type);
                
                // Hide the form
                const form = document.getElementById(`research${type.charAt(0).toUpperCase() + type.slice(1)}Form`);
                if (form) form.style.display = 'none';
            });
        }
    });
    
    // Make research editors refresh when the tab is shown
    document.querySelectorAll('[data-tab-target="#researchContentSection"]').forEach(tab => {
        tab.addEventListener('click', function() {
            setTimeout(refreshResearchEditors, 50);
            
            // Initialize editors if they haven't been created yet
            if (!researchEditors.journal) {
                initializeResearchEditors();
            }
        });
    });
});

// Handle form submission for research entries
async function handleResearchFormSubmit(type) {
    // Get form and field elements
    const idInput = document.getElementById(`${type}Id`);
    const titleInput = document.getElementById(`${type}Title`);
    const authorsInput = document.getElementById(`${type}Authors`);
    const venueInput = document.getElementById(`${type}Venue`);
    const dateInput = document.getElementById(`${type}Date`);
    const editIndexInput = document.getElementById(`${type}EditIndex`);
    const linksContainer = document.getElementById(`${type}LinksContainer`);
    
    // Validate required fields
    if (!idInput.value || !titleInput.value || !authorsInput.value || !venueInput.value) {
        showNotification("Please fill in all required fields.", 'error');
        return;
    }
    
    // Collect links
    const links = {};
    const linkRows = linksContainer.querySelectorAll('.research-link-row');
    linkRows.forEach(row => {
        const typeInput = row.querySelector('.research-link-type');
        const urlInput = row.querySelector('.research-link-url');
        if (typeInput && urlInput && typeInput.value && urlInput.value) {
            links[typeInput.value] = urlInput.value;
        }
    });
    
    // Create research entry object
    const entry = {
        id: idInput.value,
        title: titleInput.value,
        authors: authorsInput.value,
        venue: venueInput.value,
        date: dateInput.value,
        abstract: researchEditors[type] ? researchEditors[type].value() : '',
        links: links
    };
    
    // Determine if adding or editing
    const index = editIndexInput.value === '-1' ? -1 : parseInt(editIndexInput.value);
    
    // Get the correct data array and render function
    let dataArray, renderFunction;
    switch (type) {
        case 'journal':
            dataArray = researchJournal;
            renderFunction = renderResearchJournalTable;
            break;
        case 'conference':
            dataArray = researchConference;
            renderFunction = renderResearchConferenceTable;
            break;
        case 'patent':
            dataArray = researchPatent;
            renderFunction = renderResearchPatentTable;
            break;
        default:
            console.error(`Invalid research type: ${type}`);
            return;
    }
    
    // Create updated array
    const updatedArray = [...dataArray];
    
    if (index === -1) {
        // Adding new entry
        updatedArray.unshift(entry);
    } else {
        // Editing existing entry
        if (index >= 0 && index < updatedArray.length) {
            updatedArray[index] = entry;
        } else {
            console.error(`Invalid index ${index} for ${type} data`);
            showNotification(`Error: Invalid index ${index}.`, 'error');
            return;
        }
    }
    
    // Save the updated array
    const isSuccess = await saveResearchData(type, updatedArray);
    
    // Handle result
    if (isSuccess) {
        // Update the local data and re-render
        switch (type) {
            case 'journal': researchJournal = updatedArray; break;
            case 'conference': researchConference = updatedArray; break;
            case 'patent': researchPatent = updatedArray; break;
        }
        
        renderFunction();
        
        // Reset and hide the form
        resetResearchEntryForm(type);
        const form = document.getElementById(`research${type.charAt(0).toUpperCase() + type.slice(1)}Form`);
        if (form) form.style.display = 'none';
    }
}

// Map and EXIF functionality for photo coordinates

// Initialize the coordinate selection map
function initializeCoordMap() {
    if (!coordMap && document.getElementById('coordMap')) { // Initialize only once
        coordMap = L.map('coordMap').setView([20, 0], 2); // Initial view
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18, attribution: '© OSM'
        }).addTo(coordMap);

        coordMap.on('click', function(e) {
            const lat = e.latlng.lat.toFixed(6);
            const lng = e.latlng.lng.toFixed(6);
            document.getElementById('photoLat').value = lat;
            document.getElementById('photoLng').value = lng;

            if (!coordMarker) {
                coordMarker = L.marker(e.latlng).addTo(coordMap);
            } else {
                coordMarker.setLatLng(e.latlng);
            }
             coordMap.panTo(e.latlng); // Center map on click
        });
        console.log("Coordinate map initialized.");
    } else if (coordMap) {
        // If map exists but was hidden, invalidate its size
        setTimeout(() => coordMap.invalidateSize(), 0);
    }
}

// Function to update map marker when lat/lng inputs change manually
function updateMapMarkerFromInputs() {
    if (!coordMap) return; // Don't do anything if map isn't visible/init

    const lat = parseFloat(document.getElementById('photoLat').value);
    const lng = parseFloat(document.getElementById('photoLng').value);

    if (!isNaN(lat) && !isNaN(lng)) {
        const latLng = L.latLng(lat, lng);
        if (!coordMarker) {
            coordMarker = L.marker(latLng).addTo(coordMap);
        } else {
            coordMarker.setLatLng(latLng);
        }
        // Only pan/zoom if the map is actually visible
        if (document.getElementById('coordMap').style.display !== 'none') {
            coordMap.setView(latLng, coordMap.getZoom() < 10 ? 10 : coordMap.getZoom()); // Zoom in if needed
        }
    } else {
        // If inputs invalid, remove marker
        if (coordMarker) {
            coordMap.removeLayer(coordMarker);
            coordMarker = null;
        }
    }
}

// Helper to convert DMS array to decimal degrees
function dmsToDecimal(dms, ref) {
    if (!dms || dms.length !== 3) return NaN;
    var degrees = dms[0].numerator ? dms[0].numerator / dms[0].denominator : dms[0];
    var minutes = dms[1].numerator ? dms[1].numerator / dms[1].denominator : dms[1];
    var seconds = dms[2].numerator ? dms[2].numerator / dms[2].denominator : dms[2];
    var dd = degrees + minutes / 60 + seconds / 3600;
    // Reference: N/S/E/W
    if (ref === 'S' || ref === 'W') {
        dd *= -1;
    }
    return dd;
}

// Add DOM Ready function for map and EXIF functionality
document.addEventListener('DOMContentLoaded', function() {
    // Show/Hide Map Button
    const showMapButton = document.getElementById('showCoordMapButton');
    const coordMapDiv = document.getElementById('coordMap');
    if (showMapButton && coordMapDiv) {
        showMapButton.addEventListener('click', () => {
            const isHidden = coordMapDiv.style.display === 'none';
            coordMapDiv.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                initializeCoordMap(); // Initialize or invalidate size
            }
        });
    }

    // Listen to manual input changes to update map marker
    const latInput = document.getElementById('photoLat');
    const lngInput = document.getElementById('photoLng');
    if(latInput) latInput.addEventListener('change', updateMapMarkerFromInputs);
    if(lngInput) lngInput.addEventListener('change', updateMapMarkerFromInputs);

    // Listener for file input change to read EXIF and dimensions
    const photoFileInput = document.getElementById('photoFile');
    if (photoFileInput) {
        photoFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Clear previous dimensions
            document.getElementById('photoFullWidth').value = '';
            document.getElementById('photoFullHeight').value = '';
            
            // Read image dimensions using FileReader
            const reader = new FileReader();
            const img = new Image();
            
            img.onload = function() {
                console.log(`Read dimensions for ${file.name}: ${this.naturalWidth} x ${this.naturalHeight}`);
                document.getElementById('photoFullWidth').value = this.naturalWidth;
                document.getElementById('photoFullHeight').value = this.naturalHeight;
                URL.revokeObjectURL(this.src); // Clean up blob URL
            };
            
            img.onerror = function() {
                console.error(`Could not load image ${file.name} to read dimensions.`);
                // Clear dimensions if loading failed
                document.getElementById('photoFullWidth').value = '';
                document.getElementById('photoFullHeight').value = '';
                showNotification(`Error reading dimensions for ${file.name}.`, 'error');
                URL.revokeObjectURL(this.src); // Clean up blob URL
            };
            
            reader.onload = function(event) {
                img.src = event.target.result; // Load image data into Image object
            };
            
            reader.onerror = function() {
                console.error(`FileReader error for ${file.name}.`);
                showNotification(`Error reading file ${file.name}.`, 'error');
            };
            
            reader.readAsDataURL(file); // Read file as Data URL

            EXIF.getData(file, function() {
                // Extract GPS data
                const lat = EXIF.getTag(this, 'GPSLatitude');
                const latRef = EXIF.getTag(this, 'GPSLatitudeRef');
                const lng = EXIF.getTag(this, 'GPSLongitude');
                const lngRef = EXIF.getTag(this, 'GPSLongitudeRef');

                console.log("EXIF GPS Data:", { lat, latRef, lng, lngRef }); // Debug

                // Process GPS data if available
                if (lat && latRef && lng && lngRef) {
                    const decLat = dmsToDecimal(lat, latRef);
                    const decLng = dmsToDecimal(lng, lngRef);

                    console.log("EXIF Coords found:", decLat, decLng);

                    if (!isNaN(decLat) && !isNaN(decLng)) {
                        document.getElementById('photoLat').value = decLat.toFixed(6);
                        document.getElementById('photoLng').value = decLng.toFixed(6);
                        showNotification('GPS Coordinates automatically extracted from photo EXIF data.', 'info');
                        updateMapMarkerFromInputs(); // Update map with EXIF coords
                        // Ensure map is visible if we found coords
                        if (coordMapDiv && coordMapDiv.style.display === 'none') {
                            showMapButton.click(); // Simulate click to show map
                        } else if (coordMap) {
                            // Map already visible, just pan/zoom
                            coordMap.setView([decLat, decLng], coordMap.getZoom() < 10 ? 10 : coordMap.getZoom());
                        }

                    } else {
                        console.warn("Could not convert EXIF GPS data to decimal.");
                    }
                } else {
                    console.log("No GPS data found in EXIF.");
                    // Maybe show a message? Or do nothing.
                }
                
                // --- Extract Date/Time Information ---
                const dateTimeOriginal = EXIF.getTag(this, "DateTimeOriginal");
                const dateTimeDigitized = EXIF.getTag(this, "DateTimeDigitized");
                // Use DateTimeOriginal first, fall back to DateTimeDigitized
                const photoDateTime = dateTimeOriginal || dateTimeDigitized;

                console.log("EXIF DateTimeOriginal:", dateTimeOriginal);
                console.log("EXIF DateTimeDigitized:", dateTimeDigitized);

                if (photoDateTime && typeof photoDateTime === 'string') {
                    // EXIF format is often 'YYYY:MM:DD HH:MM:SS'
                    // We need 'YYYY-MM-DD' for the input field
                    console.log("EXIF DateTime found:", photoDateTime);
                    // Extract the date part and replace colons with hyphens
                    const datePart = photoDateTime.split(' ')[0]; // Get 'YYYY:MM:DD'
                    if (datePart && datePart.length === 10) {
                        const formattedDate = datePart.replace(/:/g, '-'); // Replace ':' with '-'
                        // Check if format looks correct
                        if (formattedDate.match(/^\d{4}-\d{2}-\d{2}$/)) {
                            document.getElementById('photoDate').value = formattedDate;
                            console.log("Formatted Date from EXIF:", formattedDate);
                            showNotification('Capture date automatically extracted from photo EXIF data.', 'info');
                        } else {
                            console.warn("Could not format extracted EXIF date correctly:", datePart);
                        }
                    } else {
                        console.warn("Unexpected EXIF date format:", datePart);
                    }
                } else {
                    console.log("No suitable DateTime EXIF tag found.");
                }
            });
        });
    }
    
    // Listener for project file input to read dimensions
    const projectFileInput = document.getElementById('projectFile');
    if (projectFileInput) {
        projectFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Clear previous dimensions
            document.getElementById('projectFullWidth').value = '';
            document.getElementById('projectFullHeight').value = '';
            
            // Read image dimensions using FileReader
            const reader = new FileReader();
            const img = new Image();
            
            img.onload = function() {
                console.log(`Read project image dimensions for ${file.name}: ${this.naturalWidth} x ${this.naturalHeight}`);
                document.getElementById('projectFullWidth').value = this.naturalWidth;
                document.getElementById('projectFullHeight').value = this.naturalHeight;
                URL.revokeObjectURL(this.src); // Clean up blob URL
            };
            
            img.onerror = function() {
                console.error(`Could not load project image ${file.name} to read dimensions.`);
                // Clear dimensions if loading failed
                document.getElementById('projectFullWidth').value = '';
                document.getElementById('projectFullHeight').value = '';
                showNotification(`Error reading dimensions for ${file.name}.`, 'error');
                URL.revokeObjectURL(this.src); // Clean up blob URL
            };
            
            reader.onload = function(event) {
                img.src = event.target.result; // Load image data into Image object
            };
            
            reader.onerror = function() {
                console.error(`FileReader error for ${file.name}.`);
                showNotification(`Error reading file ${file.name}.`, 'error');
            };
            
            reader.readAsDataURL(file); // Read file as Data URL
        });
    }
});

// === Contact Banner Management ===

let contactData = [];
let contactSortable = null;

/**
 * Loads and renders contact banner items with sortable functionality.
 */
async function loadContactDetails() {
    try {
        const response = await fetch('/api/data/contactBanner', {
            credentials: 'include'
        });
        
        if (response.status === 404) {
            // File doesn't exist, create empty structure
            contactData = { headerText: '', items: [] };
        } else if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        } else {
            const data = await response.json();
            // Handle both old array format and new object format
            if (Array.isArray(data)) {
                contactData = { headerText: '', items: data };
            } else {
                contactData = data;
            }
        }
        
        // Load headerText into form
        const headerTextElement = document.getElementById('contactHeaderText');
        if (headerTextElement) {
            headerTextElement.value = contactData.headerText || '';
        }
        
        renderContactTable();
        initializeContactSortable();
    } catch (error) {
        console.error('Error loading contact details:', error);
        showNotification('Error loading contact details: ' + error.message, 'error');
        contactData = { headerText: '', items: [] };
        renderContactTable();
    }
}

/**
 * Renders the contact items table.
 */
function renderContactTable() {
    const tableBody = document.getElementById('contactTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';
    
    // Ensure contactData has items array
    const items = contactData.items || [];
    
    // Sort by order
    const sortedContacts = [...items].sort((a, b) => (a.order || 0) - (b.order || 0));
    
    sortedContacts.forEach((item, index) => {
        const row = tableBody.insertRow();
        row.className = 'sortable-row';
        row.dataset.order = item.order || index;
        
        // Drag handle
        const dragCell = row.insertCell();
        dragCell.innerHTML = '<span class="drag-handle">⋮⋮</span>';
        
        // Icon
        const iconCell = row.insertCell();
        iconCell.innerHTML = `<img src="icons/${item.icon}" alt="${item.label || 'Icon'}" style="width: 24px; height: 24px;">`;
        
        // Link
        const linkCell = row.insertCell();
        linkCell.innerHTML = `<a href="${item.link}" target="_blank">${item.label || item.link}</a>`;
        
        // Actions
        const actionsCell = row.insertCell();
        actionsCell.innerHTML = `
            <button class="admin-small-button edit-contact-btn" data-index="${index}">Edit</button>
            <button class="admin-small-button delete-contact-btn" data-index="${index}">Delete</button>
        `;
    });
    
    // Add event listeners
    document.querySelectorAll('.edit-contact-btn').forEach(btn => {
        btn.addEventListener('click', handleEditContact);
    });
    
    document.querySelectorAll('.delete-contact-btn').forEach(btn => {
        btn.addEventListener('click', handleDeleteContact);
    });
}

/**
 * Initializes sortable functionality for contact table.
 */
function initializeContactSortable() {
    if (typeof Sortable === 'undefined') {
        console.warn('Sortable.js not loaded, skipping contact sortable initialization');
        return;
    }
    
    // Clean up existing sortable
    if (contactSortable) {
        contactSortable.destroy();
    }
    
    const tableBody = document.getElementById('contactTableBody');
    if (!tableBody) return;
    
    contactSortable = new Sortable(tableBody, {
        handle: '.drag-handle',
        animation: 150,
        onEnd: async function(evt) {
            // Update order based on new positions
            const rows = Array.from(tableBody.querySelectorAll('tr'));
            const reorderedItems = rows.map((row, index) => {
                const originalIndex = parseInt(row.querySelector('.edit-contact-btn').dataset.index);
                const item = { ...contactData.items[originalIndex] };
                item.order = index;
                return item;
            });
            
            // Save reordered data with headerText preserved
            const updatedData = {
                headerText: contactData.headerText || '',
                items: reorderedItems
            };
            
            try {
                const response = await fetch('/api/save/contactBanner', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(updatedData)
                });
                
                if (response.ok) {
                    contactData = updatedData;
                    showNotification('Contact items reordered successfully!', 'success');
                } else {
                    throw new Error('Failed to save reordered contact items');
                }
            } catch (error) {
                console.error('Error saving reordered contact items:', error);
                showNotification('Error saving reordered contact items', 'error');
                // Reload to reset order
                loadContactDetails();
            }
        }
    });
}

/**
 * Handles editing a contact item.
 */
function handleEditContact(event) {
    const index = parseInt(event.target.dataset.index);
    const item = contactData.items[index];
    
    document.getElementById('contactEditIndex').value = index;
    document.getElementById('contactLink').value = item.link || '';
    document.getElementById('contactLabel').value = item.label || '';
    
    document.getElementById('contactSubmitButton').textContent = 'Update Contact Item';
    document.getElementById('contactCancelButton').style.display = 'inline-block';
    
    document.getElementById('contactForm').scrollIntoView({ behavior: 'smooth' });
}

/**
 * Handles deleting a contact item.
 */
async function handleDeleteContact(event) {
    const index = parseInt(event.target.dataset.index);
    const item = contactData.items[index];
    
    if (confirm(`Are you sure you want to delete the ${item.label || 'contact'} item?`)) {
        try {
            const updatedItems = contactData.items.filter((_, i) => i !== index);
            const updatedData = {
                headerText: contactData.headerText || '',
                items: updatedItems
            };
            
            const response = await fetch('/api/save/contactBanner', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify(updatedData)
            });
            
            if (response.ok) {
                contactData = updatedData;
                renderContactTable();
                initializeContactSortable();
                showNotification('Contact item deleted successfully!', 'success');
            } else {
                throw new Error('Failed to delete contact item');
            }
        } catch (error) {
            console.error('Error deleting contact item:', error);
            showNotification('Error deleting contact item', 'error');
        }
    }
}

/**
 * Resets the contact form.
 */
function resetContactForm() {
    document.getElementById('contactEditIndex').value = '-1';
    document.getElementById('contactForm').reset();
    document.getElementById('contactSubmitButton').textContent = 'Add Contact Item';
    document.getElementById('contactCancelButton').style.display = 'none';
}

// Contact form submit handler
const contactForm = document.getElementById('contactForm');
if (contactForm) {
    contactForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const editIndex = document.getElementById('contactEditIndex').value;
        const index = editIndex === '-1' ? -1 : parseInt(editIndex);
        const link = document.getElementById('contactLink').value;
        const label = document.getElementById('contactLabel').value;
        const iconFile = document.getElementById('contactIconUpload').files[0];
        
        // For editing, use existing icon if no new file is uploaded
        let iconFilename = '';
        if (index !== -1 && !iconFile) {
            iconFilename = contactData.items[index].icon;
        } else if (iconFile) {
            // Upload new icon
            try {
                const formData = new FormData();
                formData.append('image', iconFile);
                
                const uploadResponse = await fetch('/api/upload/image', {
                    method: 'POST',
                    credentials: 'include',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error('Failed to upload icon');
                }
                
                const uploadResult = await uploadResponse.json();
                iconFilename = uploadResult.filename;
            } catch (error) {
                console.error('Error uploading icon:', error);
                showNotification('Error uploading icon: ' + error.message, 'error');
                return;
            }
        } else {
            showNotification('Please select an icon file', 'error');
            return;
        }
        
        const contactItem = {
            icon: iconFilename,
            link: link,
            label: label,
            order: index === -1 ? Math.max(...(contactData.items || []).map(c => c.order || 0), -1) + 1 : contactData.items[index].order
        };
        
        const updatedItems = [...(contactData.items || [])];
        if (index === -1) {
            updatedItems.push(contactItem);
        } else {
            updatedItems[index] = contactItem;
        }
        
        const updatedData = {
            headerText: contactData.headerText || '',
            items: updatedItems
        };
        
        try {
            const response = await fetch('/api/save/contactBanner', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify(updatedData)
            });
            
            if (response.ok) {
                contactData = updatedData;
                renderContactTable();
                initializeContactSortable();
                resetContactForm();
                showNotification('Contact item saved successfully!', 'success');
            } else {
                throw new Error('Failed to save contact item');
            }
        } catch (error) {
            console.error('Error saving contact item:', error);
            showNotification('Error saving contact item', 'error');
        }
    });
}

// Contact cancel button
const contactCancelButton = document.getElementById('contactCancelButton');
if (contactCancelButton) {
    contactCancelButton.addEventListener('click', resetContactForm);
}

// === Homepage Content Management ===

/**
 * Loads homepage content from the server and populates the textarea and image preview
 */
async function loadHomepage() {
    try {
        const response = await fetch('/api/data/homepage', {
            credentials: 'include'
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        const homepageTextarea = document.getElementById('homepageContent');
        const currentImage = document.getElementById('currentImage');
        const noImageText = document.getElementById('noImageText');
        
        if (homepageTextarea) {
            homepageTextarea.value = data.content || '';
        }
        
        // Update image preview
        if (data.image && data.image.trim() !== '') {
            currentImage.src = `img/${data.image}`;
            currentImage.style.display = 'block';
            noImageText.style.display = 'none';
        } else {
            currentImage.style.display = 'none';
            noImageText.style.display = 'block';
        }
        
        // Store current image for later use
        window.currentHomepageImage = data.image || '';
        
        console.log('Homepage content loaded successfully');
    } catch (error) {
        console.error('Error loading homepage content:', error);
        showNotification('Error loading homepage content: ' + error.message, 'error');
    }
}

/**
 * Saves homepage content to the server
 */
async function saveHomepage() {
    try {
        const homepageTextarea = document.getElementById('homepageContent');
        if (!homepageTextarea) {
            throw new Error('Homepage content textarea not found');
        }
        
        const content = homepageTextarea.value;
        const image = window.currentHomepageImage || '';
        
        const response = await fetch('/api/save/homepage', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ content, image })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to save homepage content');
        }
        
        showNotification('Homepage content saved successfully!', 'success');
        console.log('Homepage content saved successfully');
    } catch (error) {
        console.error('Error saving homepage content:', error);
        showNotification('Error saving homepage content: ' + error.message, 'error');
    }
}

/**
 * Previews homepage content by rendering Markdown to HTML
 */
function previewHomepage() {
    try {
        const homepageTextarea = document.getElementById('homepageContent');
        const previewDiv = document.getElementById('homepagePreview');
        
        if (!homepageTextarea || !previewDiv) {
            throw new Error('Homepage content elements not found');
        }
        
        const markdownContent = homepageTextarea.value;
        
        // Check if marked.js is available
        if (typeof marked === 'undefined') {
            throw new Error('Markdown parser (marked.js) not available');
        }
        
        // Parse Markdown to HTML
        const htmlContent = marked.parse(markdownContent);
        
        // Display preview
        previewDiv.innerHTML = htmlContent;
        previewDiv.style.display = 'block';
        
        showNotification('Homepage preview generated', 'info');
        console.log('Homepage preview generated');
    } catch (error) {
        console.error('Error generating homepage preview:', error);
        showNotification('Error generating preview: ' + error.message, 'error');
    }
}

/**
 * Handles homepage image upload
 */
async function uploadHomepageImage() {
    try {
        const fileInput = document.getElementById('homepageImageUpload');
        if (!fileInput || !fileInput.files[0]) {
            throw new Error('Please select an image file first');
        }
        
        const file = fileInput.files[0];
        
        // Validate file type
        if (!file.type.startsWith('image/')) {
            throw new Error('Please select a valid image file');
        }
        
        // Validate file size (max 5MB) - check before upload
        if (file.size > 5 * 1024 * 1024) {
            showNotification('Image too large (max 5MB)', 'error');
            return;
        }
        
        const formData = new FormData();
        formData.append('uploadedImage', file); // match server field
        
        showNotification('Uploading image...', 'info');
        
        const response = await fetch('/api/upload/image', {
            method: 'POST',
            credentials: 'include',
            body: formData
        });
        
        if (!response.ok) {
            let errorMessage = 'Failed to upload image';
            try {
                const errorData = await response.json();
                if (errorData.error) {
                    errorMessage = errorData.error;
                    // Provide specific message for field mismatch
                    if (errorData.error.includes('Unexpected field')) {
                        errorMessage = 'Upload failed: Field mismatch with server';
                    }
                }
            } catch (parseError) {
                // If response isn't JSON, use default message
            }
            throw new Error(errorMessage);
        }
        
        const data = await response.json();
        
        // Update current image tracking
        window.currentHomepageImage = data.filename;
        
        // Update preview
        const currentImage = document.getElementById('currentImage');
        const noImageText = document.getElementById('noImageText');
        
        currentImage.src = `img/${data.filename}`;
        currentImage.style.display = 'block';
        noImageText.style.display = 'none';
        
        // Clear file input
        fileInput.value = '';
        
        showNotification('Image uploaded successfully!', 'success');
        console.log('Homepage image uploaded:', data.filename);
        
    } catch (error) {
        console.error('Error uploading homepage image:', error);
        showNotification('Error uploading image: ' + error.message, 'error');
    }
}

// Homepage Save button event listener
const saveHomepageButton = document.getElementById('saveHomepage');
if (saveHomepageButton) {
    saveHomepageButton.addEventListener('click', saveHomepage);
}

// Homepage Preview button event listener
const previewHomepageButton = document.getElementById('previewHomepage');
if (previewHomepageButton) {
    previewHomepageButton.addEventListener('click', previewHomepage);
}

// Homepage Image Upload button event listener
const uploadImageButton = document.getElementById('uploadImageBtn');
if (uploadImageButton) {
    uploadImageButton.addEventListener('click', uploadHomepageImage);
}

// === Separate Header Text Save Functionality ===

/**
 * Saves only the header text without affecting contact items
 */
async function saveContactHeader() {
    try {
        const headerTextElement = document.getElementById('contactHeaderText');
        if (!headerTextElement) {
            throw new Error('Header text element not found');
        }
        
        const headerText = headerTextElement.value || '';
        
        // Preserve existing items, only update headerText
        const updatedData = {
            headerText: headerText,
            items: contactData.items || []
        };
        
        const response = await fetch('/api/save/contactBanner', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(updatedData)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to save header text');
        }
        
        // Update local data
        contactData.headerText = headerText;
        
        showNotification('Header text saved successfully!', 'success');
        console.log('Header text saved successfully');
    } catch (error) {
        console.error('Error saving header text:', error);
        showNotification('Error saving header text: ' + error.message, 'error');
    }
}

// Header Save button event listener
const saveHeaderButton = document.getElementById('saveHeaderBtn');
if (saveHeaderButton) {
    saveHeaderButton.addEventListener('click', saveContactHeader);
}-e 
```
-e 
### ./js/bookshelf.js

```js
/* bookshelf.js - Enhanced bookshelf with dynamic loading, filtering, and overlay */

// Global books array to store fetched data
let books = [];

/**
 * Fetches and loads books from JSON API
 */
async function loadBooks() {
    try {
        const response = await fetch('/api/data/books');
        if (!response.ok) {
            throw new Error(`Failed to fetch books: ${response.status}`);
        }
        
        books = await response.json();
        console.log(`Loaded ${books.length} books`);
        
        // Initialize filters with dynamic genre options
        initFilters();
        
        // Initial render
        filterAndSortBooks();
        
    } catch (error) {
        console.error('Error loading books:', error);
        // Show error message to user
        const booksRow = document.getElementById('books-row');
        if (booksRow) {
            booksRow.innerHTML = '<p style="color: red; padding: 20px;">Error loading books. Please try again later.</p>';
        }
    }
}

/**
 * Initializes filter dropdowns with dynamic options
 */
function initFilters() {
    const genreSelect = document.getElementById('genreFilter');
    
    // Clear existing options except "all genres"
    const allOption = genreSelect.querySelector('option[value="all"]');
    genreSelect.innerHTML = '';
    genreSelect.appendChild(allOption);
    
    // Extract unique genres from books
    const genres = new Set();
    books.forEach(book => {
        if (book.genre) {
            // Handle comma-separated genres
            book.genre.split(',').forEach(g => {
                const trimmed = g.trim();
                if (trimmed) genres.add(trimmed);
            });
        }
    });
    
    // Add genre options to dropdown
    [...genres].sort().forEach(genre => {
        const option = document.createElement('option');
        option.value = genre;
        option.textContent = genre;
        genreSelect.appendChild(option);
    });
    
    // Add event listeners for filter changes
    document.getElementById('genreFilter').addEventListener('change', filterAndSortBooks);
    document.getElementById('ratingFilter').addEventListener('change', filterAndSortBooks);
    document.getElementById('sortOrder').addEventListener('change', filterAndSortBooks);
}

/**
 * Filters and sorts books based on current filter selections, then renders them
 */
function filterAndSortBooks() {
    const genreFilter = document.getElementById('genreFilter').value;
    const ratingFilter = document.getElementById('ratingFilter').value;
    const sortOrder = document.getElementById('sortOrder').value;
    
    // Filter books
    let filteredBooks = books.filter(book => {
        // Genre filter
        const matchGenre = genreFilter === 'all' || 
            (book.genre && book.genre.includes(genreFilter));
        
        // Rating filter
        const matchRating = ratingFilter === 'all' || 
            book.rating >= parseInt(ratingFilter, 10);
        
        return matchGenre && matchRating;
    });
    
    // Sort books
    switch (sortOrder) {
        case 'date-desc':
            filteredBooks.sort((a, b) => new Date(b.datesRead || 0) - new Date(a.datesRead || 0));
            break;
        case 'date-asc':
            filteredBooks.sort((a, b) => new Date(a.datesRead || 0) - new Date(b.datesRead || 0));
            break;
        case 'rating-desc':
            filteredBooks.sort((a, b) => (b.rating || 0) - (a.rating || 0));
            break;
        case 'rating-asc':
            filteredBooks.sort((a, b) => (a.rating || 0) - (b.rating || 0));
            break;
        default:
            // Default to date-desc
            filteredBooks.sort((a, b) => new Date(b.datesRead || 0) - new Date(a.datesRead || 0));
    }
    
    // Render filtered and sorted books
    renderBooks(filteredBooks);
}

/**
 * Renders books as cards in the books-row container
 * @param {Array} booksToRender - Array of book objects to render
 */
function renderBooks(booksToRender) {
    const booksRow = document.getElementById('books-row');
    if (!booksRow) {
        console.error('books-row element not found');
        return;
    }
    
    // Clear existing books
    booksRow.innerHTML = '';
    
    if (!booksToRender || booksToRender.length === 0) {
        booksRow.innerHTML = '<p style="padding: 20px; color: #666;">No books match the current filters.</p>';
        return;
    }
    
    // Create book cards
    booksToRender.forEach(book => {
        const bookCard = document.createElement('div');
        bookCard.className = 'book-card';
        bookCard.onclick = () => openOverlay(book);
        
        // Generate star rating display
        const stars = '★'.repeat(book.rating || 0) + '☆'.repeat(5 - (book.rating || 0));
        
        // Create card content
        bookCard.innerHTML = `
            <div class="book-card-content">
                <h3 class="book-title">${escapeHtml(book.title || 'Untitled')}</h3>
                <p class="book-author">${escapeHtml(book.author || 'Unknown Author')}</p>
                <div class="book-rating">${stars}</div>
                <p class="book-genre">${escapeHtml(book.genre || '')}</p>
            </div>
        `;
        
        booksRow.appendChild(bookCard);
    });
    
    console.log(`Rendered ${booksToRender.length} books`);
}

/**
 * Opens the review overlay popup with book details
 * @param {Object} book - Book object containing title, author, rating, etc.
 */
function openOverlay(book) {
    console.log("Opening overlay for:", book.title);
    
    // Set overlay content
    document.getElementById('overlayTitle').textContent = book.title || 'Untitled';
    document.getElementById('overlayAuthor').textContent = book.author || 'Unknown Author';
    
    // Create details string with rating, genre, and read date
    const stars = '★'.repeat(book.rating || 0) + '☆'.repeat(5 - (book.rating || 0));
    const details = [
        `Rating: ${stars}`,
        book.genre ? `Genre: ${book.genre}` : '',
        book.datesRead ? `Read: ${book.datesRead}` : ''
    ].filter(Boolean).join(' | ');
    
    document.getElementById('overlayDetails').textContent = details;
    
    // Set review text (escape HTML for security)
    const reviewElement = document.getElementById('overlayReviewText');
    reviewElement.textContent = book.review || 'No review available.';
    
    // Show overlay
    const overlay = document.getElementById('reviewOverlay');
    overlay.style.display = 'block';
}

/**
 * Closes the review overlay popup
 */
function closeOverlay() {
    const overlay = document.getElementById('reviewOverlay');
    overlay.style.display = 'none';
}

/**
 * Escapes HTML characters to prevent XSS
 * @param {string} text - Text to escape
 * @returns {string} - Escaped text
 */
function escapeHtml(text) {
    if (typeof text !== 'string') return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Event listeners
document.addEventListener('DOMContentLoaded', () => {
    // Load books when page loads
    loadBooks();
    
    // Close overlay event listeners
    const closeButton = document.getElementById('closeOverlay');
    if (closeButton) {
        closeButton.addEventListener('click', closeOverlay);
    }
    
    // Close overlay when clicking outside content
    const overlay = document.getElementById('reviewOverlay');
    if (overlay) {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                closeOverlay();
            }
        });
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
        if (books.length > 0) {
            filterAndSortBooks();
        }
    });
});

// Close overlay with Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        closeOverlay();
    }
});-e 
```
-e 
### ./js/cv.js

```js
document.addEventListener('DOMContentLoaded', () => {
    console.log("CV page loaded, attempting to load dynamic content...");
    loadDynamicCvContent();
});

async function loadDynamicCvContent() {
    try {
        console.log("Fetching CV data from structured endpoints...");
        
        // Load all CV sections concurrently using Promise.all
        const [education, work, research, projects, skills, achievements, positions] = await Promise.all([
            fetchCvSection('education'),
            fetchCvSection('work'),
            fetchCvSection('research'),
            fetchCvSection('projects'),
            fetchCvSection('skills'),
            fetchCvSection('achievements'),
            fetchCvSection('positions')
        ]);
        
        // Render each section with the retrieved data
        renderEducation(education);
        renderWork(work);
        renderResearch(research);
        renderProjects(projects);
        renderSkills(skills);
        renderAchievements(achievements);
        renderPositions(positions);
        
    } catch (error) {
        console.error('Error loading dynamic CV content:', error);
        // Display error message to user
        const body = document.querySelector('main.container') || document.body;
        const errorDiv = document.createElement('div');
        errorDiv.textContent = `Failed to load CV content: ${error.message}`;
        errorDiv.style.color = 'red';
        errorDiv.style.border = '1px solid red';
        errorDiv.style.padding = '10px';
        errorDiv.style.margin = '10px 0';
        if(body.firstChild) body.insertBefore(errorDiv, body.firstChild); else body.appendChild(errorDiv);
    }
}

// Helper function to fetch a specific CV section
async function fetchCvSection(section) {
    try {
        const response = await fetch(`/api/data/cv/${section}`);
        if (!response.ok) {
            let errorMsg = `Failed to fetch ${section} data: ${response.status}`;
            try { const errData = await response.json(); errorMsg += ` - ${errData.error || 'Unknown'}`; } catch(e){}
            throw new Error(errorMsg);
        }
        return await response.json();
    } catch (error) {
        console.error(`Error fetching ${section} section:`, error);
        throw error; // Re-throw to be handled by the main function
    }
}

// Render functions for each section

function renderEducation(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.warn("No education data available or invalid format");
        return;
    }
    
    const container = document.querySelector('#education ul');
    if (!container) return;
    
    container.innerHTML = ''; // Clear loading state
    
    data.forEach(item => {
        const li = document.createElement('li');
        li.innerHTML = `
            <strong>${item.institution}</strong>, ${item.degree}
            ${item.honours ? `<em>${item.honours}</em>` : ''}
            <span>${item.dates || ''}</span>
        `;
        container.appendChild(li);
    });
}

function renderWork(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.warn("No work experience data available or invalid format");
        return;
    }
    
    const container = document.querySelector('#work');
    if (!container) return;
    
    // Remove existing placeholder content
    const existingItems = container.querySelectorAll('.experience');
    existingItems.forEach(item => item.remove());
    
    data.forEach(item => {
        const div = document.createElement('div');
        div.className = 'experience';
        
        // Format the header with title, company and dates
        const title = document.createElement('h3');
        title.innerHTML = `${item.title} – ${item.company} <span>(${item.dates})</span>`;
        
        // Create description list from markdown content
        const description = document.createElement('ul');
        
        if (item.description) {
            // Split the markdown bullet points and create list items
            const points = item.description.split('\n').filter(point => point.trim().startsWith('-'));
            
            points.forEach(point => {
                const li = document.createElement('li');
                // Remove the leading dash and trim
                li.textContent = point.substring(1).trim();
                description.appendChild(li);
            });
        }
        
        div.appendChild(title);
        div.appendChild(description);
        container.appendChild(div);
    });
}

function renderResearch(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.warn("No research data available or invalid format");
        return;
    }
    
    const container = document.querySelector('#research');
    if (!container) return;
    
    // Remove existing placeholder content
    const existingItems = container.querySelectorAll('.experience');
    existingItems.forEach(item => item.remove());
    
    data.forEach(item => {
        const div = document.createElement('div');
        div.className = 'experience';
        
        const title = document.createElement('h3');
        
        // Check if this research has associated links
        let linksHtml = '';
        // Handle both array format and object format for links
        if (Array.isArray(item.links)) {
            // Array format
            item.links.forEach(link => {
                linksHtml += ` <a href="${link.url}" class="small-link">[${link.text}]</a>`;
            });
        } else if (item.links && typeof item.links === 'object') {
            // Object format
            if (item.links.research) {
                linksHtml += ` <a href="${item.links.research}" class="small-link">[Research]</a>`;
            }
            if (item.links.project) {
                linksHtml += ` <a href="${item.links.project}" class="small-link">[Project]</a>`;
            }
        }
        
        title.innerHTML = `${item.title} – ${item.organization} <span>(${item.dates})</span>${linksHtml}`;
        
        // Create description list from markdown content
        const description = document.createElement('ul');
        
        if (item.description) {
            // Split the markdown bullet points and create list items
            const points = item.description.split('\n').filter(point => point.trim().startsWith('-'));
            
            points.forEach(point => {
                const li = document.createElement('li');
                // Remove the leading dash and trim
                li.textContent = point.substring(1).trim();
                description.appendChild(li);
            });
        }
        
        div.appendChild(title);
        div.appendChild(description);
        container.appendChild(div);
    });
}

/**
 * Renders CV projects by fetching from projects.json and filtering by showOnCv flag.
 * Uses cvSummary if available, otherwise falls back to general summary.
 * @param {Array} data - Legacy parameter, not used (fetches fresh data)
 */
async function renderProjects(data) {
    // Fetch projects from projects.json instead of cv_projects.json
    try {
        const response = await fetch('/api/data/projects');
        if (!response.ok) {
            throw new Error('Failed to fetch projects');
        }
        
        const allProjects = await response.json();
        // Filter and sort projects that should show on CV
        const cvProjects = allProjects
            .filter(p => p.showOnCv === true)
            .sort((a, b) => (a.order || 0) - (b.order || 0));
        
        const container = document.querySelector('#projects .project-list');
        if (!container) return;
        
        // Clear existing content
        container.innerHTML = '';
        
        if (cvProjects.length === 0) {
            container.innerHTML = '<p>No projects available.</p>';
            return;
        }
        
        cvProjects.forEach(project => {
            // Create clickable project item container
            const projectDiv = document.createElement('div');
            projectDiv.className = 'project-item';
            projectDiv.dataset.id = project.id;
            projectDiv.style.cursor = 'pointer';
            projectDiv.style.marginBottom = '20px';
            
            const title = document.createElement('h3');
            
            // Handle status display
            let statusHtml = project.status ? ` <span style="font-weight: normal; font-size: 0.9em;">(${project.status})</span>` : '';
            
            // Handle links
            let linkHtml = '';
            if (project.links && typeof project.links === 'object') {
                Object.entries(project.links).forEach(([type, url]) => {
                    if (url && url !== '#') {
                        linkHtml += ` <a href="${url}" class="small-link" onclick="event.stopPropagation()">[${type.charAt(0).toUpperCase() + type.slice(1)}]</a>`;
                    }
                });
            }
            
            title.innerHTML = `${project.title}${statusHtml}${linkHtml}`;
            
            // Use CV-specific summary if available, otherwise fall back to general summary
            const summary = document.createElement('p');
            summary.textContent = project.cvSummary || project.summary || '';
            summary.style.marginTop = '5px';
            
            projectDiv.appendChild(title);
            projectDiv.appendChild(summary);
            
            // Add click handler for project detail navigation
            projectDiv.addEventListener('click', (e) => {
                // Don't navigate if clicking on a link
                if (e.target.tagName !== 'A') {
                    window.location.href = `project-detail.html?id=${project.id}`;
                }
            });
            
            // Add hover effect
            projectDiv.addEventListener('mouseenter', () => {
                projectDiv.style.backgroundColor = '#f5f5f5';
            });
            projectDiv.addEventListener('mouseleave', () => {
                projectDiv.style.backgroundColor = '';
            });
            
            container.appendChild(projectDiv);
        });
    } catch (error) {
        console.error('Error loading projects:', error);
        const container = document.querySelector('#projects .project-list');
        if (container) {
            container.innerHTML = '<p style="color: red;">Failed to load projects.</p>';
        }
    }
}

/**
 * Renders skill names with clickable items and tooltips showing linked projects.
 * Filters out uncategorized skills from display.
 * @param {Object} data - Skills data object with categories containing skill objects
 */
function renderSkills(data) {
    if (typeof data !== 'object' || data === null) {
        console.warn("No skills data available or invalid format");
        return;
    }
    
    const container = document.querySelector('#skills ul');
    if (!container) return;
    
    container.innerHTML = ''; // Clear existing content
    
    // Helper function to render skills from a category
    const renderSkillCategory = (categoryName, displayName, skills) => {
        if (!Array.isArray(skills) || skills.length === 0) return;
        
        const li = document.createElement('li');
        const categorySpan = document.createElement('span');
        categorySpan.innerHTML = `<strong>${displayName}:</strong> `;
        li.appendChild(categorySpan);
        
        // Create clickable skill items
        const skillSpans = skills.map((skill, index) => {
            const span = document.createElement('span');
            span.className = 'skill-item';
            span.textContent = typeof skill === 'object' ? skill.name : skill;
            
            // Store project data if available and add linked-skill class
            if (skill.projects && skill.projects.length > 0) {
                span.classList.add('linked-skill');
                span.dataset.projects = JSON.stringify(skill.projects);
                span.dataset.skillName = skill.name;
            }
            
            return span;
        });
        
        // Add skill spans with comma separators
        skillSpans.forEach((span, index) => {
            li.appendChild(span);
            if (index < skillSpans.length - 1) {
                li.appendChild(document.createTextNode(', '));
            }
        });
        
        container.appendChild(li);
    };
    
    // Render each category (excluding uncategorized)
    renderSkillCategory('programming', 'Programming Languages', data.programming);
    renderSkillCategory('software', 'Software &amp; Tools', data.software);
    renderSkillCategory('technical', 'Technical Skills', data.technical);
    
    // Add click handlers and tooltips after rendering
    addSkillInteractions();
}

/**
 * Adds click handlers and hover tooltips to skill items.
 * Shows linked projects on hover and opens modal with clickable links on click.
 */
function addSkillInteractions() {
    const skillItems = document.querySelectorAll('.skill-item[data-projects]');
    let currentTooltip = null;
    
    // Setup modal close handlers
    const modal = document.getElementById('skillModal');
    const closeBtn = document.querySelector('.close');
    
    closeBtn.addEventListener('click', () => {
        modal.style.display = 'none';
    });
    
    window.addEventListener('click', (event) => {
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    });
    
    skillItems.forEach(item => {
        const projects = JSON.parse(item.dataset.projects || '[]');
        const skillName = item.dataset.skillName;
        
        if (projects.length === 0) return;
        
        // Add hover tooltip
        item.addEventListener('mouseenter', (e) => {
            // Remove any existing tooltip
            if (currentTooltip) {
                currentTooltip.remove();
            }
            
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'skill-tooltip';
            tooltip.textContent = `Projects: ${projects.join(', ')}`;
            
            // Position tooltip
            const rect = item.getBoundingClientRect();
            tooltip.style.position = 'absolute';
            tooltip.style.left = rect.left + 'px';
            tooltip.style.top = (rect.bottom + 5) + 'px';
            tooltip.style.background = '#333';
            tooltip.style.color = '#fff';
            tooltip.style.padding = '5px 10px';
            tooltip.style.borderRadius = '3px';
            tooltip.style.fontSize = '0.9em';
            tooltip.style.zIndex = '1000';
            tooltip.style.whiteSpace = 'nowrap';
            
            document.body.appendChild(tooltip);
            currentTooltip = tooltip;
        });
        
        item.addEventListener('mouseleave', () => {
            if (currentTooltip) {
                currentTooltip.remove();
                currentTooltip = null;
            }
        });
        
        // Add click handler to open modal
        item.addEventListener('click', () => {
            openSkillModal(skillName, projects);
        });
    });
}

/**
 * Opens modal with skill details and clickable project links.
 * @param {string} skillName - The name of the skill
 * @param {Array} projects - Array of project IDs associated with the skill
 */
async function openSkillModal(skillName, projects) {
    const modal = document.getElementById('skillModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalList = document.getElementById('modalList');
    
    // Set title
    modalTitle.textContent = `${skillName} - Associated Items`;
    
    // Clear previous content
    modalList.innerHTML = '';
    
    // Create a loading message
    const loadingLi = document.createElement('li');
    loadingLi.textContent = 'Loading...';
    modalList.appendChild(loadingLi);
    
    // Show modal immediately
    modal.style.display = 'flex';
    
    try {
        // Fetch all data in parallel
        const [projectsData, workData, researchData] = await Promise.all([
            fetch('/api/data/projects').then(r => r.json()).catch(() => []),
            fetch('/api/data/cv/work').then(r => r.json()).catch(() => []),
            fetch('/api/data/cv/research').then(r => r.json()).catch(() => [])
        ]);
        
        // Clear loading message
        modalList.innerHTML = '';
        
        let hasItems = false;
        
        // Add project links with titles
        if (projects && projects.length > 0) {
            const projectHeader = document.createElement('li');
            projectHeader.innerHTML = '<strong>Projects:</strong>';
            modalList.appendChild(projectHeader);
            
            projects.forEach(projectId => {
                const project = projectsData.find(p => p.id === projectId);
                const li = document.createElement('li');
                const link = document.createElement('a');
                link.href = `project-detail.html?id=${projectId}`;
                link.textContent = project ? project.title : projectId;
                li.appendChild(link);
                modalList.appendChild(li);
                hasItems = true;
            });
        }
        
        // Add work roles with skills
        const workRoles = workData.filter(role => 
            role.skills && role.skills.includes(skillName)
        );
        if (workRoles.length > 0) {
            const workHeader = document.createElement('li');
            workHeader.innerHTML = '<strong>Work Experience:</strong>';
            workHeader.style.marginTop = hasItems ? '10px' : '0';
            modalList.appendChild(workHeader);
            
            workRoles.forEach(role => {
                const li = document.createElement('li');
                li.textContent = `${role.title} - ${role.company}`;
                modalList.appendChild(li);
                hasItems = true;
            });
        }
        
        // Add research roles with skills
        const researchRoles = researchData.filter(role => 
            role.skills && role.skills.includes(skillName)
        );
        if (researchRoles.length > 0) {
            const researchHeader = document.createElement('li');
            researchHeader.innerHTML = '<strong>Research Experience:</strong>';
            researchHeader.style.marginTop = hasItems ? '10px' : '0';
            modalList.appendChild(researchHeader);
            
            researchRoles.forEach(role => {
                const li = document.createElement('li');
                li.textContent = `${role.title} - ${role.organization}`;
                modalList.appendChild(li);
                hasItems = true;
            });
        }
        
        if (!hasItems) {
            const li = document.createElement('li');
            li.textContent = 'No associated items found';
            modalList.appendChild(li);
        }
        
    } catch (error) {
        console.error('Error loading skill details:', error);
        modalList.innerHTML = '<li>Error loading details</li>';
    }
}

function renderAchievements(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.warn("No achievements data available or invalid format");
        return;
    }
    
    const container = document.querySelector('#achievements ul');
    if (!container) return;
    
    container.innerHTML = ''; // Clear existing content
    
    data.forEach(item => {
        const li = document.createElement('li');
        
        if (item.award.toLowerCase().startsWith('notable') || item.award.toLowerCase().includes('academic results')) {
            // For "Notable Academic Results", add emphasis
            li.innerHTML = `<em>${item.award}</em>`;
        } else {
            // Regular awards
            li.textContent = item.year ? `${item.award} (${item.year})` : item.award;
        }
        
        container.appendChild(li);
    });
}

function renderPositions(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.warn("No positions data available or invalid format");
        return;
    }
    
    const container = document.querySelector('#positions ul');
    if (!container) return;
    
    container.innerHTML = ''; // Clear existing content
    
    data.forEach(item => {
        const li = document.createElement('li');
        li.innerHTML = `
            <strong>${item.role}</strong>, ${item.organization} <em>(${item.dates})</em> – ${item.description}
        `;
        container.appendChild(li);
    });
}-e 
```
-e 
### ./js/globe.js

```js
// globe.js - CesiumJS Globe Viewer Initialization

let gAllPhotos = [];  // global cache: populated once, reused forever
const photoKey = p => (p.imageFull || p.thumbnail).split('/').pop();

// This is the main initialization function that fetches the Cesium token and initializes the viewer
async function initializeGlobeViewer() {
    console.log("Attempting to initialize globe viewer...");

    // --- Fetch Cesium Token from Backend ---
    let cesiumToken = null;
    try {
        console.log("Fetching Cesium token...");
        const response = await fetch('/api/config/cesium-token');
        if (!response.ok) {
            let errorMsg = `Failed to fetch token: ${response.status}`;
            try { 
                const err = await response.json(); 
                errorMsg += ` - ${err.error}`; 
            } catch(e) {}
            throw new Error(errorMsg);
        }
        const data = await response.json();
        if (!data.token) {
            throw new Error("Token not found in server response.");
        }
        cesiumToken = data.token;
        console.log("Cesium token fetched successfully.");

    } catch (error) {
        console.error("Error fetching Cesium token:", error);
        alert(`Failed to get configuration required for Globe Viewer: ${error.message}`);
        // Display error in container
        const container = document.getElementById('cesiumContainer');
        if(container) container.innerHTML = `<p style="color:red; padding: 20px;">Configuration Error: ${error.message}</p>`;
        return; // Stop initialization
    }

    // --- Set Token and Initialize Viewer ---
    Cesium.Ion.defaultAccessToken = cesiumToken;

    // Check if container exists before initialization
    const cesiumContainer = document.getElementById('cesiumContainer');
    if (!cesiumContainer) {
        console.error('Globe container not found - cesiumContainer element missing');
        alert('Globe container not found. Please ensure the page has a cesiumContainer element.');
        return;
    }

    try {
        console.log("Initializing Cesium.Viewer with pickers ENABLED initially...");
        const viewer = new Cesium.Viewer(cesiumContainer, {
            // --- Let Viewer choose defaults & Ensure pickers initialize ---
            // No explicit imageryProvider or terrainProvider - use defaults
            
            // --- Enable Pickers during init ---
            baseLayerPicker: true, // Enable for proper initialization
            sceneModePicker: true, // Enable for proper initialization
            
            // --- UI elements configuration ---
            animation: false,
            fullscreenButton: false,
            vrButton: false,
            geocoder: true,
            homeButton: true,
            infoBox: false, // Disable default InfoBox panel
            selectionIndicator: true,
            timeline: false,
            navigationHelpButton: false,
            navigationInstructionsInitiallyVisible: false,
            
            // Improve rendering quality
            requestRenderMode: true,
            maximumRenderTimeChange: Infinity,
        });

        // Fly to home view immediately to ensure we start looking at the whole globe
        viewer.camera.flyHome(0);
        console.log("Cesium Viewer constructor finished.");
        
        // --- Hide Pickers Immediately After Init ---
        hideViewerWidgets(viewer); // Call helper function to hide them
        
        console.log("Cesium Viewer initialized successfully (pickers hidden post-init).");

        // --- Add event listeners for loading progress and errors ---
        viewer.scene.globe.tileLoadProgressEvent.addEventListener(function(numberOfPendingTiles) {
            // Silently track tile loading progress
        });
        
        viewer.scene.renderError.addEventListener(function(scene, error) {
            console.error("CesiumJS Rendering Error:", error);
            // Handle severe errors potentially
        });

        console.log("Cesium Viewer initialized successfully using fetched token.");

        // Set up click handler for entities
        const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        handler.setInputAction(function(movement) {
            const pickedObject = viewer.scene.pick(movement.position);
            if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && 
                pickedObject.id instanceof Cesium.Entity && pickedObject.id.properties?.photoData) {
                // We clicked one of our photo pin entities
                const clickedEntity = pickedObject.id;
                const clickedPhotoData = clickedEntity.properties.photoData.getValue(viewer.clock.currentTime); // Get data
                const clickedPhotoIndex = clickedEntity.properties.photoIndex.getValue(viewer.clock.currentTime); // Get index

                console.log(`Cesium Entity clicked: ${clickedEntity.name}, Index: ${clickedPhotoIndex}`);

                // --- Fly To Entity ---
                viewer.flyTo(clickedEntity, {
                    duration: 2.0, // Animation duration in seconds
                    offset: new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-90), 1.5e4) // Look down from 1km away
                }).then(function(didFlightComplete) {
                    if (didFlightComplete) {
                        console.log("FlyTo complete, opening GLightbox...");
                        // --- Open GLightbox (Contextual Logic) ---
                        buildAndOpenLightbox(clickedPhotoData, 'trip'); // Use the helper function
                    } else {
                        console.warn("FlyTo was cancelled.");
                    }
                }).catch(function(error) {
                    console.error("Error during flyTo or GLightbox:", error);
                    // Attempt to open lightbox even if flyTo fails
                    buildAndOpenLightbox(clickedPhotoData, 'trip');
                });
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

        // Helper function to build and open GLightbox
        function buildAndOpenLightbox(clickedPhoto, initialContext = 'trip') {
            const photos = gAllPhotos;           // single source of truth
            if (!photos.length)
              throw new Error('gAllPhotos empty; ensure globe initialised first.');
              
            // Determine context (trip or country)
            const contextId = initialContext === 'trip' && clickedPhoto.tripId ? 
                clickedPhoto.tripId : clickedPhoto.country;
            const contextKey = initialContext === 'trip' && clickedPhoto.tripId ? 
                'tripId' : 'country';
                    
            // Helper function to get context photos with proper filtering and sorting
            function getContextPhotos(contextType) {
                // Filter photos by context
                const photosInContext = photos.filter(photo => photo[contextKey] === contextId);
                
                // Create a copy for sorting
                const sorted = [...photosInContext];
                
                // Sort by sortIndex (if available), fallback to date
                sorted.sort((a, b) => {
                    const ai = a.sortIndex;
                    const bi = b.sortIndex;
                    if (ai != null && bi != null) return ai - bi;      // both indexed
                    if (ai == null && bi != null) return 1;           // a without index
                    if (bi == null && ai != null) return -1;           // b without index
                    return new Date(a.date) - new Date(b.date);        // both missing
                });
                
                return sorted;
            }
            
            // Debug: verify clicked photo has required properties
            console.log("Clicked photo data:", clickedPhoto?.title);
            
            // Get sorted gallery photos for the initial context
            const sortedGalleryPhotos = getContextPhotos(initialContext);
            
            // Log the sorted array to help with debugging
            console.log("Context photos after sorting:", sortedGalleryPhotos.map(p => p.title)); // Log titles in sorted order
            
            // Find the index of the clicked photo in the sorted array using stable key
            const startIndex = sortedGalleryPhotos.findIndex(
                p => photoKey(p) === photoKey(clickedPhoto)
            );
            
            if (startIndex === -1) {
                console.error(`CRITICAL: Clicked photo (title ${clickedPhoto?.title}) NOT FOUND in its own context gallery after sorting! Defaulting to 0.`, clickedPhoto, sortedGalleryPhotos);
                throw new Error('Clicked photo not found in sorted subset');
            }
            
            console.log(`Starting gallery at SORTED index ${startIndex} for clicked photo "${clickedPhoto?.title}" using key "${photoKey(clickedPhoto)}".`);
            
            // Map sortedGalleryPhotos to galleryElements for GLightbox
            const galleryElements = sortedGalleryPhotos.map((p, idx) => {
                // Determine filename, preferring imageFull, falling back to thumbnail
                const filenameToUse = p?.imageFull || p?.thumbnail;
                
                // Construct URL safely
                const fullImageUrl = filenameToUse ? `img/${filenameToUse}` : 'img/placeholder-cover.png'; // Use placeholder if no filename found
                
                // Log the details for the item corresponding to the initial click
                if (idx === startIndex) {
                    console.log(`Element for starting index ${startIndex}:`);
                    console.log(`  >> Href requesting: ${fullImageUrl}`);
                    console.log(`  >> Based on photo data:`, p); // Log the source photo object
                }
                
                return {
                    href: fullImageUrl, // This is the URL GLightbox will request
                    type: 'image',
                    title: p.title || '',
                    description: p.description || '',
                    alt: p.title || 'Photo'
                };
            });
            
            console.log(`--- Finished preparing ${galleryElements.length} elements ---`);
            
            if (galleryElements.length === 0) {
                console.error("No gallery elements created! Check filtering logic and data.");
                showNotification("Error: No photos found for this context", "error");
                return;
            }
            
            // Initialize GLightbox with the filtered gallery
            const lightbox = GLightbox({
                elements: galleryElements,
                startAt: Math.max(0, startIndex),
                loop: true
            });
            
            // Only keep the close listener
            lightbox.on('close', () => {
                console.log("GLightbox closed.");
            });
            
            // Open the lightbox
            lightbox.open();
            
            // Use the global tripsData variable instead of trips
            const contextDescription = contextKey === 'tripId' && clickedPhoto.tripId ? 
                `Trip "${tripsData.find(t => t.id === clickedPhoto.tripId)?.name || clickedPhoto.tripId}"` : 
                `Country "${clickedPhoto.country}"`;
            
            console.log(`Showing photos from ${contextDescription}`);
            showNotification(`Showing photos from ${contextDescription}`, 'info');
        }

        // Now that the viewer is ready, load the photo data
        loadAndPlaceGlobeMarkers(viewer); // Call function to add photo markers

    } catch (error) {
        console.error("Error initializing Cesium Viewer:", error);
        alert(`Failed to initialize 3D Globe Viewer: ${error.message}`);
        // Use the container we already found and verified exists
        if(cesiumContainer) cesiumContainer.innerHTML = `<p style="color:red; padding: 20px;">Viewer Error: ${error.message}</p>`;
    }
}

// Global trips variable to be accessible from all functions
let tripsData = [];

// Function to load photo data and add entities to the globe
async function loadAndPlaceGlobeMarkers(viewer) {
    console.log("Loading photo data for globe...");
    if (!viewer) {
        console.error("Viewer not available for placing markers.");
        return;
    }

    try {
        const response = await fetch('/api/data/images');
        if (!response.ok) {
            let errorMsg = `Failed to fetch images: ${response.status}`;
            try { 
                const err = await response.json(); 
                errorMsg += ` - ${err.error}`; 
            } catch(e) {}
            throw new Error(errorMsg);
        }
        const photos = await response.json();
        if (!Array.isArray(photos)) throw new Error("Invalid image data format.");
        
        gAllPhotos = photos;  // cache photos globally
        
        console.log(`Processing ${photos.length} images for globe placement...`);
        let placedCount = 0;

        // Use PinBuilder for creating pin graphics
        const pinBuilder = new Cesium.PinBuilder();

        // Fetch trips data for descriptions if available
        try {
            const tripsResponse = await fetch('/api/data/trips');
            if (tripsResponse.ok) {
                tripsData = await tripsResponse.json(); // Store in global variable
                console.log(`Loaded ${tripsData.length} trips for reference.`);
            }
        } catch (tripError) {
            console.warn("Could not load trips data:", tripError);
        }

        // Sort photos by sortIndex before creating pins
        const sortedPhotos = [...photos].sort((a, b) => {
            const ai = a.sortIndex;
            const bi = b.sortIndex;
            if (ai != null && bi != null) return ai - bi;      // both indexed
            if (ai == null && bi != null) return 1;           // a without index
            if (bi == null && ai != null) return -1;           // b without index
            return new Date(a.date) - new Date(b.date);        // both missing
        });
        
        // Use Promise.all to handle async pin creation efficiently
        const entityPromises = sortedPhotos.map(async (photo, index) => {
            // Ensure lat/lng are numbers
            const lat = parseFloat(photo.lat);
            const lng = parseFloat(photo.lng);

            if (!isNaN(lat) && !isNaN(lng)) {
                try {
                    console.log(`Processing photo index ${index}, Title: ${photo?.title}`);
                    // Pass the photo's sortIndex (or index if not available) as the display order
                    const displayIndex = typeof photo.sortIndex === 'number' ? photo.sortIndex : index;
                    await createPhotoPinEntity(viewer, pinBuilder, photo, tripsData, displayIndex);
                    placedCount++;
                } catch (entityError) {
                    console.error(`Failed to create entity for ${photo.title || 'Untitled'}:`, entityError);
                }
            } else {
                console.warn(`Skipping photo "${photo.title || 'Untitled'}" due to invalid coordinates.`);
            }
        });
        
        await Promise.all(entityPromises); // Wait for all entities to be processed
        console.log(`${placedCount} photo locations added to the globe.`);

    } catch (error) {
        console.error("Error loading or placing globe markers:", error);
        showNotification(`Error loading photo locations: ${error.message}`, 'error');
    }
}

// Create photo pin entities and add them to the globe
async function createPhotoPinEntity(viewer, pinBuilder, image, trips, idx) {
    const lat = parseFloat(image.lat);
    const lng = parseFloat(image.lng);
    // Position with height 0 initially, let heightReference handle terrain
    const position = Cesium.Cartesian3.fromDegrees(lng, lat, 0.0);

    // --- Commenting out PinBuilder ---
    /*
    // Generate the pin graphic (returns a Promise)
    let pinUrl;
    try {
        // Create a blue pin with 'camera' icon
        pinUrl = await pinBuilder.fromMakiIconId('camera', Cesium.Color.DODGERBLUE, 48);
    } catch (pinError) {
        console.error("Error generating pin graphic:", pinError);
        // Fallback to a simple color pin if icon fails
        pinUrl = await pinBuilder.fromColor(Cesium.Color.ROYALBLUE, 48);
    }
    */

    // Prepare InfoBox description (HTML)
    const thumbUrl = image.thumbnail ? `img/${image.thumbnail}` : '';
    let descriptionHtml = `<h3>${image.title || 'Untitled'}</h3>`;
    if (image.date) descriptionHtml += `<p><em>Date: ${image.date}</em></p>`;
    if (image.country) descriptionHtml += `<p><em>Country: ${image.country}</em></p>`;
    if (image.tripId) {
        const tripInfo = tripsData.find(t => t.id === image.tripId);
        if (tripInfo) descriptionHtml += `<p><em>Trip: ${tripInfo.name}</em></p>`;
    }
    // Add thumbnail to description if available
    if (thumbUrl) {
        descriptionHtml += `<p><img src="${thumbUrl}" alt="thumbnail" style="max-width: 200px; height: auto;"></p>`;
    }
    if (image.description) descriptionHtml += `<p>${image.description}</p>`;
    // No button needed since we open lightbox directly from entity click handler
    
    console.log(`Creating entity for: ${image.title || 'Untitled'}`);

    // Use local pin model
    try {
        console.log(` --> Attempting viewer.entities.add for ${image.title || 'Untitled'}`);
        viewer.entities.add({
            name: image.title || 'Photo Location', // Text on hover
            position: position,
            model: {
                uri: 'models/pin.glb',
                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, // Keep height reference
                
                // Overall base size multiplier
                scale: 500, // Base scale for close-up view
                
                // Dynamic scaling with distance - adjusted for better mid-range visibility
                scaleByDistance: new Cesium.NearFarScalar(
                    5.0e2,  // nearDistance: 500m
                    1.0,    // nearScale: Full base scale when closer
                    2.5e6,  // farDistance: 2500km - better for mid-range zoom
                    0.45    // farScale: Moderate shrinking to 45% when far
                ),
                
                // Absolute minimum screen size safety net
                minimumPixelSize: 32 // Smallest acceptable size in pixels
            },
            description: descriptionHtml, // Content for InfoBox on click
            properties: { // Store custom data for later access
                photoIndex: idx, // Link back to index in array
                photoData: image // Store the original image data object
            }
        });
        console.log(` --> Successfully called viewer.entities.add for ${image.title || 'Untitled'}`);
    } catch (addError) {
        console.error(` --> ERROR during viewer.entities.add for ${image.title || 'Untitled'}:`, addError);
    }
}

// Helper function to hide specific Cesium UI widgets via CSS class
function hideViewerWidgets(viewerInstance) {
    console.log("Attempting to hide picker widgets...");
    try {
        // Cesium adds classes to the container or creates specific elements.
        const container = viewerInstance.container;

        const layerPicker = container.querySelector('.cesium-baseLayerPicker-dropDown');
        if (layerPicker) {
             layerPicker.style.display = 'none';
             console.log("BaseLayerPicker dropdown hidden.");
        } else { console.warn("Could not find BaseLayerPicker element to hide."); }
        
        // Also hide the button itself which might be separate
        const layerPickerButton = container.querySelector('.cesium-viewer-toolbar .cesium-baseLayerPicker-selected');
        // Or sometimes just the button container directly:
        const layerPickerButtonContainer = container.querySelector('.cesium-baseLayerPicker-button');
        if (layerPickerButtonContainer) {
             layerPickerButtonContainer.style.display = 'none';
             console.log("BaseLayerPicker button hidden.");
        } else if (layerPickerButton) {
             layerPickerButton.style.display = 'none'; // Fallback if container class changes
             console.log("BaseLayerPicker selected button part hidden.");
        } else { console.warn("Could not find BaseLayerPicker button element to hide."); }

        const sceneModePicker = container.querySelector('.cesium-sceneModePicker-wrapper');
        if (sceneModePicker) {
            sceneModePicker.style.display = 'none';
            console.log("SceneModePicker hidden.");
        } else { console.warn("Could not find SceneModePicker element to hide."); }

    } catch(e) {
         console.error("Error trying to hide widgets:", e);
    }
}

// Helper function to show notifications
function showNotification(message, type = 'info') {
    console.log(`[${type.toUpperCase()}] ${message}`); // Basic console fallback
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `globe-notification ${type}`;
    notification.textContent = message;
    notification.style.position = 'fixed';
    notification.style.bottom = '20px';
    notification.style.left = '50%';
    notification.style.transform = 'translateX(-50%)';
    notification.style.backgroundColor = type === 'info' ? 'rgba(0, 120, 255, 0.9)' : 'rgba(255, 0, 0, 0.9)';
    notification.style.color = 'white';
    notification.style.padding = '10px 20px';
    notification.style.borderRadius = '5px';
    notification.style.zIndex = '1000';
    notification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
    
    // Add to body
    document.body.appendChild(notification);
    
    // Remove after delay
    setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.5s ease';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 500);
    }, 3000);
}

// Call the main initialization function when the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    if (typeof Cesium !== 'undefined') {
        initializeGlobeViewer();
    } else {
        console.error("Cesium library not loaded before globe.js execution!");
        const container = document.getElementById('cesiumContainer');
        if(container) container.innerHTML = `<p style="color:red; padding: 20px;">Error: Cesium library not loaded properly.</p>`;
    }
});-e 
```
-e 
### ./js/homeContentLoader.js

```js
// js/homeContentLoader.js

/**
 * Loads and renders homepage content from homepage.json including image and content
 */
async function loadHomeContent() {
    try {
        const response = await fetch('/api/data/homepage');
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        let htmlContent = '';
        
        // 1. Add content parsed from Markdown first.
        if (typeof marked !== 'undefined') {
            htmlContent += marked.parse(data.content || '');
        } else {
            console.warn('marked.js not loaded, using plain text fallback');
            htmlContent += (data.content || '').replace(/\n/g, '<br>');
        }

        // 2. Add the image after the text content.
        if (data.image && data.image.trim() !== '') {
            htmlContent += `<img src="img/${data.image}" class="profile-pic" alt="Homepage Image">`;
        }
        
        insertHomeContent(htmlContent);
        
    } catch (error) {
        console.error('Error loading homepage content:', error);
        // Show a fallback message
        const fallbackContent = `<h1>Welcome</h1><p>Welcome to my portfolio website. Please check back later for updated content.</p>`;
        insertHomeContent(fallbackContent);
    }
}

/**
 * Inserts the parsed content into the homepage, replacing existing content
 * @param {string} htmlContent - The HTML content to insert
 */
function insertHomeContent(htmlContent) {
    const container = document.getElementById('homeContent');
    
    if (container) {
        container.innerHTML = htmlContent;
        console.log('Homepage content loaded successfully');
    } else {
        console.error('Container with ID "homeContent" not found for homepage content.');
    }
}

// Auto-load homepage content when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Only load on homepage (index.html or root path)
    const path = window.location.pathname;
    const isHomepage = path === '/' || path === '/index.html' || path.endsWith('/index.html');
    
    if (isHomepage) {
        loadHomeContent();
    }
});

// Export for manual usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { loadHomeContent, insertHomeContent };
}-e 
```
-e 
### ./js/photography.js

```js
// photography.js - Combined Globe and Map View Controller

/**
 * Photography page controller with toggle functionality
 * Manages both globe and map views in a single interface
 */

// Global state
let globeInitialized = false;
let mapInitialized = false;
let currentView = 'globe'; // Start with globe view
let isGlobeInit = false; // Additional flag for globe initialization status
let isGlobeInitialized = false; // Main flag for lazy initialization

/**
 * Initializes the photography page with toggle functionality
 * Called when DOM is ready
 */
function initPhotography() {
    console.log("Initializing photography page...");
    
    // Set up toggle event listeners
    setupToggleListeners();
    
    // Don't initialize globe immediately - do it lazily when first shown
    // Just ensure the globe container is visible since it's the default view
    const globeContainer = document.getElementById('globeContainer');
    const mapContainer = document.getElementById('mapContainer');
    
    if (globeContainer) {
        globeContainer.style.display = 'block';
    }
    if (mapContainer) {
        mapContainer.style.display = 'none';
    }
    
    // Hide map controls initially since globe is active
    const mapControls = document.getElementById('mapControls');
    if (mapControls) {
        mapControls.style.display = 'none';
    }
    
    console.log("Photography page initialized (globe deferred for lazy loading)");
    
    // Since globe is the default view, initialize it after a short delay
    // This gives time for all libraries to load properly
    setTimeout(() => {
        if (currentView === 'globe' && !isGlobeInitialized) {
            console.log("Auto-initializing globe as default view...");
            initGlobeView();
            isGlobeInitialized = true;
        }
    }, 500);
}

/**
 * Sets up event listeners for the view toggle buttons
 */
function setupToggleListeners() {
    const globeToggle = document.getElementById('globeToggle');
    const mapToggle = document.getElementById('mapToggle');
    
    if (globeToggle) {
        globeToggle.addEventListener('click', () => {
            if (currentView !== 'globe') {
                showGlobe();
                toggleActive('globe');
            }
        });
    }
    
    if (mapToggle) {
        mapToggle.addEventListener('click', () => {
            if (currentView !== 'map') {
                showMap();
                toggleActive('map');
            }
        });
    }
    
    console.log("Toggle listeners set up");
}

/**
 * Shows the globe view and hides the map view
 */
function showGlobe() {
    console.log("Switching to globe view...");
    
    let globeContainer = document.getElementById('globeContainer');
    const mapContainer = document.getElementById('mapContainer');
    const mapControls = document.getElementById('mapControls');
    
    // Ensure globe container exists, create if necessary
    if (!globeContainer) {
        console.log("Globe container not found, creating dynamically...");
        globeContainer = document.createElement('div');
        globeContainer.id = 'globeContainer';
        globeContainer.style.height = 'calc(100vh - 120px)';
        globeContainer.style.width = '100%';
        
        // Create cesium container inside
        const cesiumDiv = document.createElement('div');
        cesiumDiv.id = 'cesiumContainer';
        cesiumDiv.style.width = '100%';
        cesiumDiv.style.height = '100%';
        globeContainer.appendChild(cesiumDiv);
        
        // Insert after map controls or at the beginning of body
        const insertAfter = mapControls || document.body.firstChild;
        if (insertAfter && insertAfter.parentNode) {
            insertAfter.parentNode.insertBefore(globeContainer, insertAfter.nextSibling);
        } else {
            document.body.appendChild(globeContainer);
        }
    }
    
    if (globeContainer) {
        globeContainer.style.display = 'block';
    }
    if (mapContainer) {
        mapContainer.style.display = 'none';
    }
    if (mapControls) {
        mapControls.style.display = 'none';
    }
    
    // Lazy initialize globe only when first shown
    if (!isGlobeInitialized) {
        console.log("Lazy initializing globe for first time...");
        initGlobeView();
        isGlobeInitialized = true;
    }
    
    currentView = 'globe';
    console.log("Switched to globe view");
}

/**
 * Shows the map view and hides the globe view
 */
function showMap() {
    console.log("Switching to map view...");
    
    const globeContainer = document.getElementById('globeContainer');
    const mapContainer = document.getElementById('mapContainer');
    const mapControls = document.getElementById('mapControls');
    
    if (globeContainer) {
        globeContainer.style.display = 'none';
    }
    if (mapContainer) {
        mapContainer.style.display = 'block';
    }
    if (mapControls) {
        mapControls.style.display = 'flex';
    }
    
    // Initialize map if not already done
    if (!mapInitialized) {
        initMapView();
    } else {
        // If map exists, refresh it to handle container size changes
        setTimeout(() => {
            if (typeof map !== 'undefined' && map) {
                map.invalidateSize();
            }
        }, 100);
    }
    
    currentView = 'map';
    console.log("Switched to map view");
}

/**
 * Toggles the active state of toggle buttons
 * @param {string} view - Either 'globe' or 'map'
 */
function toggleActive(view) {
    const globeToggle = document.getElementById('globeToggle');
    const mapToggle = document.getElementById('mapToggle');
    
    // Remove active class from both
    if (globeToggle) globeToggle.classList.remove('active');
    if (mapToggle) mapToggle.classList.remove('active');
    
    // Add active class to selected view
    if (view === 'globe' && globeToggle) {
        globeToggle.classList.add('active');
    } else if (view === 'map' && mapToggle) {
        mapToggle.classList.add('active');
    }
    
    console.log(`Active toggle set to: ${view}`);
}

/**
 * Initializes the globe view in the globe container
 * Lazy loads the globe to avoid performance issues
 */
function initGlobeView() {
    if (isGlobeInit || isGlobeInitialized) {
        console.log("Globe already initialized");
        return;
    }
    
    console.log("Initializing globe view...");
    
    // Check if Cesium is available
    if (typeof Cesium === 'undefined') {
        console.error("Cesium library not loaded");
        showGlobeError("Cesium library not loaded. Please refresh the page.");
        return;
    }
    
    // Ensure globeContainer exists
    const globeContainer = document.getElementById('globeContainer');
    if (!globeContainer) {
        console.error("Globe container not found");
        showGlobeError("Globe container not found. Please refresh the page.");
        return;
    }
    
    // Ensure cesiumContainer exists in globeContainer
    let cesiumContainer = document.getElementById('cesiumContainer');
    
    if (!cesiumContainer) {
        // Create cesiumContainer inside globeContainer
        const cesiumDiv = document.createElement('div');
        cesiumDiv.id = 'cesiumContainer';
        cesiumDiv.style.width = '100%';
        cesiumDiv.style.height = '100%';
        globeContainer.appendChild(cesiumDiv);
        console.log("Created cesiumContainer in globeContainer");
    }
    
    // Check if globe initialization function exists
    if (typeof initializeGlobeViewer === 'function') {
        // Initialize the globe viewer
        initializeGlobeViewer()
            .then(() => {
                isGlobeInit = true;
                globeInitialized = true;
                console.log("Globe view initialized successfully");
            })
            .catch(error => {
                console.error("Failed to initialize globe view:", error);
                showGlobeError(`Failed to initialize globe: ${error.message}`);
            });
    } else {
        console.error("Globe initialization function not found");
        showGlobeError("Globe initialization function not found. Please ensure globe.js is loaded.");
    }
}

/**
 * Shows an error message in the globe container
 * @param {string} message - Error message to display
 */
function showGlobeError(message) {
    const globeContainer = document.getElementById('globeContainer');
    if (globeContainer) {
        globeContainer.innerHTML = `
            <div style="padding: 20px; text-align: center; color: #dc3545;">
                <h3>Globe Initialization Error</h3>
                <p>${message}</p>
                <button onclick="location.reload()" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                    Reload Page
                </button>
            </div>
        `;
    }
}

/**
 * Initializes the map view in the map container
 * Lazy loads the map to avoid performance issues
 */
function initMapView() {
    if (mapInitialized) {
        console.log("Map already initialized");
        return;
    }
    
    console.log("Initializing map view...");
    
    // Check if Leaflet is available
    if (typeof L === 'undefined') {
        console.error("Leaflet library not loaded");
        return;
    }
    
    // The map should initialize automatically from worldmap.js
    // We just need to mark it as initialized and ensure it's properly sized
    setTimeout(() => {
        if (typeof map !== 'undefined' && map) {
            map.invalidateSize();
            mapInitialized = true;
            console.log("Map view initialized successfully");
        } else {
            console.error("Map object not found - ensure worldmap.js is loaded");
        }
    }, 500);
}

// Initialize photography page when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    // Only initialize if we're on the photography page
    if (document.getElementById('viewToggle')) {
        console.log("Photography page detected, initializing...");
        // Add a small delay to ensure all scripts are loaded
        setTimeout(() => {
            initPhotography();
        }, 100);
    } else {
        console.log("Not a photography page, skipping photography.js initialization");
    }
});

// Export functions for external use if needed
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        initPhotography,
        showGlobe,
        showMap,
        toggleActive
    };
}-e 
```
-e 
### ./js/photoswipe-test.js

```js
// Simple script to test PhotoSwipe library loading
document.addEventListener('DOMContentLoaded', function() {
  console.log("PhotoSwipe test script loaded");
  console.log("PhotoSwipe present:", typeof PhotoSwipe);
  console.log("PhotoSwipeLightbox present:", typeof PhotoSwipeLightbox);
  
  // Check if the library objects have the expected properties
  if (typeof PhotoSwipe \!== 'undefined') {
    console.log("PhotoSwipe properties:", {
      name: PhotoSwipe.name,
      isFunction: typeof PhotoSwipe === 'function',
      prototype: PhotoSwipe.prototype ? Object.keys(PhotoSwipe.prototype).slice(0, 5) : 'No prototype'
    });
  }
  
  if (typeof PhotoSwipeLightbox \!== 'undefined') {
    console.log("PhotoSwipeLightbox properties:", {
      name: PhotoSwipeLightbox.name,
      isFunction: typeof PhotoSwipeLightbox === 'function',
      prototype: PhotoSwipeLightbox.prototype ? Object.keys(PhotoSwipeLightbox.prototype).slice(0, 5) : 'No prototype'
    });
  }
});
-e 
```
-e 
### ./js/project-detail.js

```js
// js/project-detail.js

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const projectId = urlParams.get('id');

    if (!projectId) {
        displayError("Project ID missing from URL.");
        return;
    }
    loadProjectDetails(projectId);
});

async function loadProjectDetails(projectId) {
    try {
        const response = await fetch('/api/data/projects');
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const projects = await response.json();

        // Ensure projects is an array before searching
        if (!Array.isArray(projects)) throw new Error("Invalid project data format.");

        const projectData = projects.find(p => p.id === projectId);

        if (projectData) {
            displayProjectDetails(projectData);
        } else {
            displayError(`Project with ID "${projectId}" not found.`);
        }
    } catch (error) {
        console.error('Error loading project details:', error);
        displayError(`Failed to load project data. ${error.message}`);
    }
}

function displayProjectDetails(project) {
    // Set page title
    document.title = `${project.title || 'Project Detail'} - Finn Wilson`;

    // Set heading
    const titleElement = document.getElementById('projectTitle');
    if (titleElement) titleElement.textContent = project.title || 'Untitled Project';

    // Set meta info
    const statusElement = document.getElementById('projectStatus');
    if (statusElement) statusElement.textContent = project.status || 'N/A';

    const linksElement = document.getElementById('projectLinks');
    if (linksElement && project.links) {
        linksElement.innerHTML = ''; // Clear existing
        Object.entries(project.links).forEach(([key, url]) => {
            if (url && url !== '#') { // Only show valid links
                const link = document.createElement('a');
                link.href = url;
                // Capitalize key for display
                link.textContent = `[${key.charAt(0).toUpperCase() + key.slice(1)}]`;
                link.target = url.startsWith('http') ? '_blank' : '_self'; // Open external links in new tab
                link.rel = 'noopener noreferrer';
                link.style.marginRight = '10px';
                linksElement.appendChild(link);
            }
        });
    }

    // Set banner image
    const bannerImg = document.getElementById('projectBannerImage');
    if (bannerImg && project.image) {
        // Use the image path directly from the project data
        bannerImg.src = project.image;
        bannerImg.alt = project.title + " Banner";
        bannerImg.style.display = 'block';
    } else if (bannerImg) {
        bannerImg.style.display = 'none'; // Hide if no image
    }

    // Convert Markdown and inject
    const bodyElement = document.getElementById('projectBody');
    if (bodyElement) {
        try {
            // Configure marked for better rendering
            marked.setOptions({ 
                breaks: true,
                gfm: true
            });
            
            const htmlContent = marked.parse(project.detailMarkdown || '');
            bodyElement.innerHTML = htmlContent;
        } catch (e) {
            console.error("Error parsing Markdown:", e);
            bodyElement.innerHTML = "<p style='color: red;'>Error displaying project content.</p>";
        }
    }
}

function displayError(message) {
    const titleElement = document.getElementById('projectTitle');
    if (titleElement) titleElement.textContent = 'Error';
    
    const bodyElement = document.getElementById('projectBody');
    if (bodyElement) bodyElement.innerHTML = `<p style="color: red;">${message}</p>`;
    
    console.error(message);
}-e 
```
-e 
### ./js/projects.js

```js
// js/projects.js

/**
 * Load and display projects from the API
 */
async function loadProjects() {
    try {
        const response = await fetch('/api/data/projects');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const projects = await response.json();
        renderProjects(projects);
    } catch (error) {
        console.error('Error loading projects:', error);
        const container = document.getElementById('projectsContainer');
        if (container) {
            container.innerHTML = '<p>Error loading projects. Please try again later.</p>';
        }
    }
}

/**
 * Render projects in the container
 * @param {Array} projects - Array of project objects
 */
function renderProjects(projects) {
    const container = document.getElementById('projectsContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Sort projects by order field
    const sortedProjects = projects.sort((a, b) => (a.order || 0) - (b.order || 0));
    
    sortedProjects.forEach(project => {
        const projectCard = createProjectCard(project);
        container.appendChild(projectCard);
    });
    
    // Add click handlers to project images
    addProjectClickHandlers();
}

/**
 * Create a project card element
 * @param {Object} project - Project object
 * @returns {HTMLElement} Project card element
 */
function createProjectCard(project) {
    const card = document.createElement('div');
    card.className = 'project-card';
    card.id = project.id;
    
    // Create skills list HTML
    const skillsHtml = project.skills ? 
        project.skills.map(skill => `<li>${skill}</li>`).join('') : '';
    
    // Create links HTML
    const linksHtml = project.links ? 
        Object.entries(project.links)
            .filter(([key, url]) => url && url !== '#')
            .map(([key, url]) => {
                const linkText = key.charAt(0).toUpperCase() + key.slice(1);
                return `<a href="${url}">[${linkText}]</a>`;
            }).join(' ') : '';
    
    card.innerHTML = `
        <div class="project-image-container">
            <img class="project-image" 
                 src="${project.image || 'img/placeholder.jpg'}" 
                 alt="${project.title}"
                 data-id="${project.id}">
        </div>
        <div class="project-content">
            <h3 class="project-title" data-id="${project.id}">${project.title}</h3>
            <p class="project-summary">${project.summary || ''}</p>
            ${project.role ? `<p class="project-role"><strong>My Role:</strong> ${project.role}</p>` : ''}
            ${skillsHtml ? `
                <div class="project-skills">
                    <h4>Key Skills/Tools:</h4>
                    <ul>${skillsHtml}</ul>
                </div>
            ` : ''}
            ${linksHtml ? `<div class="project-links">${linksHtml}</div>` : ''}
            ${project.status ? `<p class="project-status">Status: ${project.status}</p>` : ''}
        </div>
    `;
    
    return card;
}

/**
 * Add click handlers to project images and titles
 */
function addProjectClickHandlers() {
    // Add click handlers to images
    document.querySelectorAll('.project-image').forEach(img => {
        img.style.cursor = 'pointer';
        img.addEventListener('click', () => {
            const projectId = img.dataset.id;
            window.location.href = `project-detail.html?id=${projectId}`;
        });
    });
    
    // Add click handlers to titles
    document.querySelectorAll('.project-title').forEach(title => {
        title.style.cursor = 'pointer';
        title.addEventListener('click', () => {
            const projectId = title.dataset.id;
            window.location.href = `project-detail.html?id=${projectId}`;
        });
    });
}

// Load projects when the page loads
document.addEventListener('DOMContentLoaded', loadProjects);-e 
```
-e 
### ./js/research.js

```js
document.addEventListener('DOMContentLoaded', () => {
    console.log("Research page loaded, attempting to load dynamic content...");
    loadDynamicResearchContent();
});

async function loadDynamicResearchContent() {
    try {
        console.log("Fetching research data from structured endpoints...");
        
        // Load all research sections concurrently using Promise.all
        const [journalData, thesisData, conferenceData, patentData] = await Promise.all([
            fetchResearchSection('journal'),
            fetchResearchSection('thesis'),
            fetchResearchSection('conference'),
            fetchResearchSection('patent')
        ]);
        
        // Render each section with the retrieved data
        renderJournalEntries(journalData);
        renderThesis(thesisData);
        renderConferenceEntries(conferenceData);
        renderPatentEntries(patentData);
        
    } catch (error) {
        console.error('Error loading dynamic research content:', error);
        // Display error message to user
        const body = document.querySelector('main.container') || document.body;
        const errorDiv = document.createElement('div');
        errorDiv.textContent = `Failed to load research content: ${error.message}`;
        errorDiv.style.color = 'red';
        errorDiv.style.border = '1px solid red';
        errorDiv.style.padding = '10px';
        errorDiv.style.margin = '10px 0';
        if(body.firstChild) body.insertBefore(errorDiv, body.firstChild); else body.appendChild(errorDiv);
    }
}

// Helper function to fetch a specific research section
async function fetchResearchSection(section) {
    try {
        const response = await fetch(`/api/data/research/${section}`);
        if (!response.ok) {
            let errorMsg = `Failed to fetch ${section} data: ${response.status}`;
            try { const errData = await response.json(); errorMsg += ` - ${errData.error || 'Unknown'}`; } catch(e){}
            throw new Error(errorMsg);
        }
        return await response.json();
    } catch (error) {
        console.error(`Error fetching ${section} section:`, error);
        throw error; // Re-throw to be handled by the main function
    }
}

// Render functions for each section

function renderJournalEntries(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.warn("No journal article data available or invalid format");
        return;
    }
    
    const container = document.getElementById('journal-articles');
    if (!container) return;
    
    // Clear any existing content
    container.innerHTML = '<h2>Journal Articles</h2>';
    
    data.forEach(entry => {
        // Create the entry container
        const entryDiv = document.createElement('div');
        entryDiv.className = 'research-entry';
        if (entry.id) entryDiv.id = entry.id;
        
        // Create and add the title
        const title = document.createElement('h3');
        title.className = 'entry-title';
        title.textContent = entry.title;
        entryDiv.appendChild(title);
        
        // Create and add the authors
        const authors = document.createElement('p');
        authors.className = 'entry-authors';
        // Parse Markdown for authors (to handle bold formatting for your name)
        authors.innerHTML = marked.parse(entry.authors || '');
        entryDiv.appendChild(authors);
        
        // Create and add the venue
        const venue = document.createElement('p');
        venue.className = 'entry-venue';
        venue.textContent = entry.venue;
        entryDiv.appendChild(venue);
        
        // Create and add the date
        const date = document.createElement('p');
        date.className = 'entry-date';
        date.textContent = entry.date || '';
        entryDiv.appendChild(date);
        
        // Create and add the abstract
        const abstract = document.createElement('div');
        abstract.className = 'entry-abstract';
        abstract.innerHTML = marked.parse(entry.abstract || '');
        entryDiv.appendChild(abstract);
        
        // Create and add the links
        const links = document.createElement('div');
        links.className = 'entry-links';
        
        if (entry.links && typeof entry.links === 'object') {
            Object.entries(entry.links).forEach(([type, url]) => {
                if (url) {
                    const link = document.createElement('a');
                    link.href = url;
                    link.textContent = `[${type.charAt(0).toUpperCase() + type.slice(1)}]`;
                    links.appendChild(link);
                    // Add a space after the link
                    links.appendChild(document.createTextNode(' '));
                }
            });
        }
        
        entryDiv.appendChild(links);
        
        // Add the complete entry to the container
        container.appendChild(entryDiv);
    });
}

function renderThesis(data) {
    if (typeof data !== 'object' || data === null) {
        console.warn("No thesis data available or invalid format");
        return;
    }
    
    const container = document.getElementById('thesis');
    if (!container) return;
    
    // Clear any existing content
    container.innerHTML = '<h2>Thesis</h2>';
    
    // Create the entry container
    const entryDiv = document.createElement('div');
    entryDiv.className = 'research-entry';
    entryDiv.id = 'honours-thesis';
    
    // Create and add the title
    const title = document.createElement('h3');
    title.className = 'entry-title';
    title.textContent = data.title || 'Thesis Title';
    entryDiv.appendChild(title);
    
    // Create and add the authors
    const authors = document.createElement('p');
    authors.className = 'entry-authors';
    authors.innerHTML = marked.parse(data.authors || '**Finn Wilson**');
    entryDiv.appendChild(authors);
    
    // Create and add the venue
    const venue = document.createElement('p');
    venue.className = 'entry-venue';
    venue.textContent = data.venue || '';
    entryDiv.appendChild(venue);
    
    // Create and add the date
    const date = document.createElement('p');
    date.className = 'entry-date';
    date.textContent = data.date || '';
    entryDiv.appendChild(date);
    
    // Create and add the abstract
    const abstract = document.createElement('div');
    abstract.className = 'entry-abstract';
    abstract.innerHTML = marked.parse(data.abstract || '');
    entryDiv.appendChild(abstract);
    
    // Create and add the links
    const links = document.createElement('div');
    links.className = 'entry-links';
    
    if (data.links && typeof data.links === 'object') {
        Object.entries(data.links).forEach(([type, url]) => {
            if (url) {
                const link = document.createElement('a');
                link.href = url;
                
                // Format the link text based on the type
                let linkText;
                if (type.startsWith('project_')) {
                    linkText = `[Related Project: ${type.substring(8).charAt(0).toUpperCase() + type.substring(9)}]`;
                } else {
                    linkText = `[${type.charAt(0).toUpperCase() + type.slice(1)}]`;
                }
                
                link.textContent = linkText;
                links.appendChild(link);
                // Add a space after the link
                links.appendChild(document.createTextNode(' '));
            }
        });
    }
    
    entryDiv.appendChild(links);
    
    // Add the complete entry to the container
    container.appendChild(entryDiv);
}

function renderConferenceEntries(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.warn("No conference paper data available or invalid format");
        return;
    }
    
    const container = document.getElementById('conference-papers');
    if (!container) return;
    
    // Clear any existing content
    container.innerHTML = '<h2>Conference Papers</h2>';
    
    data.forEach(entry => {
        // Create the entry container
        const entryDiv = document.createElement('div');
        entryDiv.className = 'research-entry';
        if (entry.id) entryDiv.id = entry.id;
        
        // Create and add the title
        const title = document.createElement('h3');
        title.className = 'entry-title';
        title.textContent = entry.title;
        entryDiv.appendChild(title);
        
        // Create and add the authors
        const authors = document.createElement('p');
        authors.className = 'entry-authors';
        authors.innerHTML = marked.parse(entry.authors || '');
        entryDiv.appendChild(authors);
        
        // Create and add the venue
        const venue = document.createElement('p');
        venue.className = 'entry-venue';
        venue.textContent = entry.venue;
        entryDiv.appendChild(venue);
        
        // Create and add the date
        const date = document.createElement('p');
        date.className = 'entry-date';
        date.textContent = entry.date || '';
        entryDiv.appendChild(date);
        
        // Create and add the abstract
        const abstract = document.createElement('div');
        abstract.className = 'entry-abstract';
        abstract.innerHTML = marked.parse(entry.abstract || '');
        entryDiv.appendChild(abstract);
        
        // Create and add the links
        const links = document.createElement('div');
        links.className = 'entry-links';
        
        if (entry.links && typeof entry.links === 'object') {
            Object.entries(entry.links).forEach(([type, url]) => {
                if (url) {
                    const link = document.createElement('a');
                    link.href = url;
                    link.textContent = `[${type.charAt(0).toUpperCase() + type.slice(1)}]`;
                    links.appendChild(link);
                    // Add a space after the link
                    links.appendChild(document.createTextNode(' '));
                }
            });
        }
        
        entryDiv.appendChild(links);
        
        // Add the complete entry to the container
        container.appendChild(entryDiv);
    });
}

function renderPatentEntries(data) {
    if (!Array.isArray(data) || data.length === 0) {
        console.warn("No patent data available or invalid format");
        return;
    }
    
    const container = document.getElementById('patents');
    if (!container) return;
    
    // Clear any existing content
    container.innerHTML = '<h2>Patents</h2>';
    
    data.forEach(entry => {
        // Create the entry container
        const entryDiv = document.createElement('div');
        entryDiv.className = 'research-entry';
        if (entry.id) entryDiv.id = entry.id;
        
        // Create and add the title
        const title = document.createElement('h3');
        title.className = 'entry-title';
        title.textContent = entry.title;
        entryDiv.appendChild(title);
        
        // Create and add the authors
        const authors = document.createElement('p');
        authors.className = 'entry-authors';
        authors.innerHTML = marked.parse(entry.authors || '');
        entryDiv.appendChild(authors);
        
        // Create and add the venue (status for patents)
        const venue = document.createElement('p');
        venue.className = 'entry-venue';
        venue.textContent = entry.venue;
        entryDiv.appendChild(venue);
        
        // Create and add the date
        const date = document.createElement('p');
        date.className = 'entry-date';
        date.textContent = entry.date || '';
        entryDiv.appendChild(date);
        
        // Create and add the abstract
        const abstract = document.createElement('div');
        abstract.className = 'entry-abstract';
        abstract.innerHTML = marked.parse(entry.abstract || '');
        entryDiv.appendChild(abstract);
        
        // Create and add the links
        const links = document.createElement('div');
        links.className = 'entry-links';
        
        if (entry.links && typeof entry.links === 'object') {
            Object.entries(entry.links).forEach(([type, url]) => {
                if (url) {
                    const link = document.createElement('a');
                    link.href = url;
                    link.textContent = `[${type.charAt(0).toUpperCase() + type.slice(1)}]`;
                    links.appendChild(link);
                    // Add a space after the link
                    links.appendChild(document.createTextNode(' '));
                }
            });
        }
        
        entryDiv.appendChild(links);
        
        // Add the complete entry to the container
        container.appendChild(entryDiv);
    });
}-e 
```
-e 
### ./js/script.js

```js
// Mobile navigation toggle and load common elements
document.addEventListener('DOMContentLoaded', function() {
  // Load header
  fetch("includes/header.html")
    .then(response => response.text())
    .then(data => {
      // Replace the header with our loaded header
      const headerElement = document.querySelector('header');
      if (headerElement) {
        headerElement.outerHTML = data;
        
        // Set active nav item based on current page
        const currentPage = window.location.pathname.split('/').pop();
        const navLinks = document.querySelectorAll('#main-nav a');
        
        if (currentPage === '' || currentPage === 'index.html') {
          document.getElementById('nav-home').classList.add('active');
        } else if (currentPage === 'cv.html') {
          document.getElementById('nav-cv').classList.add('active');
        } else if (currentPage === 'research.html') {
          document.getElementById('nav-research').classList.add('active');
        } else if (currentPage === 'projects.html') {
          document.getElementById('nav-projects').classList.add('active');
        } else if (currentPage === 'bookshelf.html') {
          document.getElementById('nav-bookshelf').classList.add('active');
        } else if (currentPage === 'worldmap.html') {
          document.getElementById('nav-photography').classList.add('active');
        }
        
        // Reattach event listener for nav toggle after header is loaded
        const navToggle = document.getElementById('nav-toggle');
        const mainNav = document.getElementById('main-nav');
        if (navToggle) {
          navToggle.addEventListener('click', function() {
            mainNav.classList.toggle('open');
          });
        }
      }
    })
    .catch(error => console.error("Error loading header:", error));

  // Load footer with dynamic contact banner
  loadContactBanner();
});

/**
 * Loads and renders the contact banner dynamically
 */
async function loadContactBanner() {
  try {
    const response = await fetch('/api/data/contactBanner');
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    renderContactBanner(data);
    
  } catch (error) {
    console.error('Error loading contact banner:', error);
    // Load fallback static footer
    loadStaticFooter();
  }
}

/**
 * Renders the contact banner with header text and icons
 * @param {Object} data - Contact banner data with headerText and items
 */
function renderContactBanner(data) {
  const footerElement = document.getElementById("footer");
  if (!footerElement) {
    console.warn("Footer element not found in the page");
    return;
  }
  
  let bannerHTML = '<div class="contact-banner">';
  
  // Add header text if available
  if (data.headerText && data.headerText.trim()) {
    bannerHTML += `<div class="banner-header">${data.headerText}</div>`;
  }
  
  // Add social media icons
  if (data.items && data.items.length > 0) {
    bannerHTML += '<div class="social-icons">';
    
    // Sort items by order
    const sortedItems = [...data.items].sort((a, b) => (a.order || 0) - (b.order || 0));
    
    sortedItems.forEach(item => {
      bannerHTML += `
        <a href="${item.link}" target="_blank" title="${item.label || 'Social Link'}">
          <img src="icons/${item.icon}" alt="${item.label || 'Icon'}" class="social-icon">
        </a>
      `;
    });
    
    bannerHTML += '</div>';
  }
  
  bannerHTML += '</div>';
  
  footerElement.innerHTML = bannerHTML;
}

/**
 * Fallback to load static footer.html if dynamic loading fails
 */
function loadStaticFooter() {
  fetch("footer.html")
    .then(response => response.text())
    .then(data => {
      const footerElement = document.getElementById("footer");
      if (footerElement) {
        footerElement.innerHTML = data;
      }
    })
    .catch(error => console.error("Error loading static footer:", error));
}
-e 
```
-e 
### ./js/vendor/photoswipe.umd.min.js

```js
/*\!
  * PhotoSwipe 5.4.0 - https://photoswipe.com
  * (c) 2023 Dmytro Semenov
  */
\!function(t,e){"object"==typeof exports&&"undefined"\!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"\!=typeof globalThis?globalThis:t||self).PhotoSwipe=e()}(this,(function(){"use strict";const t="undefined"\!=typeof window&&window.navigator&&window.navigator.userAgent?window.navigator.userAgent:"",e=/(Mac OS|iPhone|iPod|iPad)/i.test(t),i=/iPad.*?OS 15/i.test(t);let s=0;const n=t=>window.getComputedStyle?getComputedStyle(t,null):t.currentStyle,o={allowPanToNext:\!0,spacing:.1,loop:\!0,pinchToClose:\!0,closeOnVerticalDrag:\!0,hideAnimationDuration:333,showAnimationDuration:333,zoomAnimationDuration:333,escKey:\!0,arrowKeys:\!0,trapFocus:\!0,returnFocus:\!0,maxWidthToAnimate:4e3,clickToCloseNonZoomable:\!0,imageClickAction:"zoom-or-close",bgClickAction:"close",indexIndicatorSep:" / ",preloaderDelay:2e3,indexIndicatorVisible:\!0,contentErrorMsg:"The image cannot be loaded",errorMsgOpacity:.7},a=t=>{if(t>1)return{x:t,y:1};if(t<1)return{x:1,y:1/t};return{x:1,y:1}},r=()=>[],h=()=>({x:0,y:0});class l{constructor(){this.clearObservers()}add(t){this._methods.push(t)}clearObservers(){this._methods=[]}beforeChange(t){this._methods.forEach((e=>e("beforeChange",t)))}afterChange(t){this._methods.forEach((e=>e("afterChange",t)))}change(t){this._methods.forEach((e=>e("change",t)))}loadComplete(t,e){this._methods.forEach((i=>i("loadComplete",t,e)))}loadError(t,e){this._methods.forEach((i=>i("loadError",t,e)))}openBound(){this._methods.forEach((t=>t("openBound")))}resize(){this._methods.forEach((t=>t("resize")))}imageClickAction(t){this._methods.forEach((e=>e("imageClickAction",t)))}bgClickAction(){this._methods.forEach((t=>t("bgClickAction")))}close(){this._methods.forEach((t=>t("close")))}destroy(){this._methods.forEach((t=>t("destroy")))}}class d{constructor(t={}){this.options={...o},Object.assign(this.options,t),this._prepareOptions(),this.offset=h(),this.initialOffset=h(),this.velocity=h(),this.start=h(),this.movement=h(),this.overtakeFactor=0,this.target=0,this.potentialTarget=0,this.containerRect={},this.contentRect={},this.slidesRect={},this.itemData=null,this.bounds=null,this._containerShift=h(),this._containerRect={},this._contentRect={},this._prevViewportRect={},this.bgOpacity=1,this.currIndex=0,this.prevIndex=0,this.isOpen=\!1,this.isOpenComplete=\!1,this.isDestroying=\!1,this.hasMouse=\!1,this._startResizeTimer=0,this._numItems=0,this.topBar=\!0,this.events=new l,this.animations={},this.mainScroll=new c(this),this.gestures=new u(this),this.opener=new p(this),this.keyboard=new f(this),this.contentLoader=new m(this),this.observers={},this.observers.beforeResize=this._beforeResize.bind(this),this.observers.afterResize=this._afterResize.bind(this),this.observers.resize=this._resize.bind(this)}init(){if(this.isOpen||this.isDestroying)return;let t=o;this.options.adjustBarsOnInit&&(this.topBar=\!0),this.dispatch("init"),this._applyFilters("init"),this._registerElement("ui","onInit"),this._registerElement("bg","onInit"),this._registerElement("container","onInit"),this._registerElement("scrollWrap","onInit"),this.opener.init(),this.content=this.element("content"),this.bgElement=this.element("bg"),this.template=this.element("ui"),this.topBar&&(this.topBarElement=this.element("top-bar")),this.options.appendToEl||(this.options.appendToEl=document.body),this.options.appendToEl.appendChild(this.template),this.container=this.element("container"),this.scrollWrap=this.element("scrollWrap"),window.addEventListener("resize",this.observers.beforeResize),window.addEventListener("orientationchange",this.observers.beforeResize),if("open"===this.options.initialAction){this.open(this.options.index||0)}else{this.isOpen=\!0,this.isOpenComplete=\!0,this.opener.onOpen()}}destroy(){if(this.isDestroying||\!this.isOpen)return;const t=this.getViewportCenterPoint();this.isDestroying=\!0,window.removeEventListener("resize",this.observers.beforeResize),window.removeEventListener("orientationchange",this.observers.beforeResize),this.element("ui").removeEventListener("keydown",this.keyboard._onKeyDown),this.dispatch("destroy",{returnFocus:\!1}),this.mainScroll.resetPosition(),this.animations={},this.emit("destroy"),this.content.innerHTML="",this.contentLoader.destroy(),this.gestures.destroy(),this.template.remove(),this.isOpen=\!1}_applyFilters(t){r().forEach((e=>{e(this,t)}))}dispatch(t,e){const i=this._prepareFiltersData();let s;return this._filters&&(s=this._filters[t])&&s.forEach((t=>{s=t(e,this,i)})),s||e}goTo(t){if(\!this.isOpen)return;this.dispatch("goTo",{index:t}),this._updateItemData(t)}mainScroll(){}_updateItemData(t,e=\!1){this.prevIndex=this.currIndex;const i=this._getItemIndexRange();t>i[1]?t=i[0]:t<i[0]&&(t=i[1]),this.currIndex=t,this.currSlide=this.getSlide(),this.potentialTarget=0,e?this.dispatch("afterChange"):this.dispatch("beforeChange")}next(){this.goTo(this.currIndex+1)}prev(){this.goTo(this.currIndex-1)}zoomTo(){}_prepareOptions(){const t=this.options,e=window.matchMedia("(prefers-reduced-motion), (update: slow)");e.media===e.media&&(e.matches||"update:slow"===e.media)&&(t.showHideAnimationType="none",t.zoomAnimationDuration=0),typeof t.gallery+typeof t.items<1&&(console.error("PhotoSwipe: cannot open() - either gallery or items option are missing or undefined."),console.error("PhotoSwipe: gallery must be a valid DOM element."),console.error("PhotoSwipe: items must be an array.")),"function"\!=typeof t.index&&(t.index=0),t.getItemData&&"function"==typeof t.getItemData||(t.getItemData=t=>t),t.preventPointerEvent=t=>\!1,this.shouldKeepSecondary=()=>{return this.options.loop||this.currIndex\!==this.options.initialIndex}}prepareContent(){}_loadContent(){}_appendContent(){}_setModalHeight(){}open(t){this.init(),this.dispatch("open",{index:t}),this._updateItemData(t),this.dispatch("change"),this.opener.onOpen(),this.prepareContent(),this._loadContent(),this._appendContent(),this.isOpen=\!0,this._registerElement("scroll-wrap","onInit"),this.addEqualizerClassToScrollWrap(),this.dispatch("openComplete"),this.contentLoader.updateLazy(),this.isOpenComplete=\!0,this.container.focus()}close(){if(this.isDestroying||\!this.isOpen)return;this.isOpen=\!1,this.isOpenComplete=\!1,this.isDestroying=\!0,this.dispatch("close"),this.mainScroll.resetPosition(),this.template.remove(),this.contentLoader.destroy(),this.events.clearObservers(),this.gestures.destroy(),this.dispatch("destroy"),this.isDestroying=\!1}getViewportCenterPoint(){return{x:this.viewportSize.x/2,y:this.viewportSize.y/2}}_getItemIndexRange(){return[0,this.getNumItems()-1]}_getVerticalPadding(){return 0}getNumItems(){let t=this.options.dataSource?this.options.dataSource.length:this.options.items?this.options.items.length:0;return t=Math.max(0,t),t}_registerElement(t,e){if(this.options[t]){let i=this.options[t];if(i instanceof Element)this["_"+t]=i;else{if("string"\!=typeof i)return;const s=this.template&&this.template.querySelector(i);s&&(this["_"+t]=s)}}}element(t){return this["_"+t]}addEqualizerClassToScrollWrap(){if(e&&\!i){const t=this.scrollWrap;if(t){const e=n(t);parseInt(e.paddingLeft,10)+parseInt(e.paddingRight,10)>0&&this.scrollWrap?.classList.add("pswp--has-margins")}}}_beforeResize(){if(this._resizeTimeout)clearTimeout(this._resizeTimeout),this._resizeTimeout=null;if(this.isDestroying)return;this.dispatch("beforeResize");const t=window.innerWidth,e=window.innerHeight;if(this.viewportSize&&this.viewportSize.x===t&&this.viewportSize.y===e)return;this._resizeTimeout=setTimeout((()=>{this._resizeTimeout=null,this._resize()}),50),this.viewportSize={x:t,y:e},this._updatePageScrollDirection(),this._updateItemData(\!0),this.dispatch("resize"),this.addEqualizerClassToScrollWrap()}_updatePageScrollDirection(){if(this.options.loop)return;const t=window.pageYOffset;if(this._prevPageScrollY===undefined)return this._prevPageScrollY=t,void(this._prevWidth=window.innerWidth);const e=t-this._prevPageScrollY,i=this._prevWidth-window.innerWidth;if(Math.abs(e)>10){this._prevPageScrollY=t;const i=e<0,s=this.mainScroll.isShifted();s&&i?(this.mainScroll.moveIndexBy(1,\!0,0),e<-100&&this.goTo(this.currIndex-1,\!0)):s||i||e<100||(this.mainScroll.moveIndexBy(-1,\!0,0),this.goTo(this.currIndex+1,\!0))}else this._prevWidth\!==window.innerWidth&&(this._prevWidth=window.innerWidth)}_resize(){this._containerShift=h(),this._containerRect={},this._contentRect={},this._applyFilters("resize"),this._setModalHeight()}_afterResize(){}_applyBgOpacity(t){this.bgElement.style.opacity=t.toString()}_onKeyDown(t){}_getVerticalDragRatio(){return 0}_setModalHeight(){this.scrollWrap.style.height=""}}class c{constructor(t){this.pswp=t,this.x=0,this.slideWidth=0}update(){this.slideWidth=this.pswp.viewportSize.x+this.pswp.options.spacing,this.pswp.container.style.transform=this.isShifted()?"translateX("+this.getCurrShift()+"px)":"",this._updatePrevNextPositions()}isShifted(){return 0\!==this.x}getCurrShift(){return this.x}_updatePrevNextPositions(){if(this.pswp.isOpen){const t=this.pswp.options.loop,e=this.pswp.currSlide?.element?.style;e&&(e.transform=this._getTransform(0)),this.pswp.prevSlide&&this.pswp.prevSlide.element&&(this.pswp.prevSlide.element.style.transform=t?this._getTransform(-this.slideWidth):this._getTransform(this.x-this.slideWidth),this.pswp.prevSlide.element.style.display=t||this.x?"":"none"),this.pswp.nextSlide&&this.pswp.nextSlide.element&&(this.pswp.nextSlide.element.style.transform=t?this._getTransform(this.slideWidth):this._getTransform(this.x+this.slideWidth),this.pswp.nextSlide.element.style.display=t||this.x?"":"none")}}_getTransform(t){return"translate3d("+t+"px,0,0)"}}class u{constructor(t){this.pswp=t,this.limit={minX:0,minY:0,maxX:0,maxY:0},this.positionDiff={},this.startPan=h(),this.startZoom=1,this.startTime=0,this.endTime=0,this.velocity=h(),this.isShiftPressed=\!1,this.isSwiping=\!1,this.isPanning=\!1,this.isZooming=\!1,this.isTappedDown=\!1,this.isMultitouch=\!1,this.pixelRatio=1,this.startPointerPos=h(),this.pointerMoveX=0,this.pointerMoveY=0,this.prevPointerPos=h(),this.potentialTap=\!1,this.tapTimer=null,this.startPointerId=null,this.isDetecting=\!1,this.touchEventEnabled="ontouchstart"in window,this.pointerEventEnabled=\!\!window.PointerEvent,this.dragLockAxis=null,this.pointers=[],this.track=[],this.observers={pointerDown:this._onPointerDown.bind(this),pointerMove:this._onPointerMove.bind(this),pointerUp:this._onPointerUp.bind(this),keydown:this._onKeyDown.bind(this),keyup:this._onKeyUp.bind(this),scroll:this._onScroll.bind(this),wheel:this._onWheel.bind(this)},this.pointerEventEnabled?(this.pswp.events.add(this.pswp.element,"pointerdown",this.observers.pointerDown),this.pswp.events.add(window,"pointermove",this.observers.pointerMove),this.pswp.events.add(window,"pointerup",this.observers.pointerUp),this.pswp.events.add(window,"pointercancel",this.observers.pointerUp)):this.touchEventEnabled?(this.pswp.events.add(this.pswp.element,"touchstart",this.observers.pointerDown),this.pswp.events.add(window,"touchmove",this.observers.pointerMove),this.pswp.events.add(window,"touchend",this.observers.pointerUp),this.pswp.events.add(window,"touchcancel",this.observers.pointerUp)):(this.pswp.events.add(this.pswp.element,"mousedown",this.observers.pointerDown),this.pswp.events.add(window,"mousemove",this.observers.pointerMove),this.pswp.events.add(window,"mouseup",this.observers.pointerUp)),this.pswp.events.add(document,"keydown",this.observers.keydown),this.pswp.events.add(document,"keyup",this.observers.keyup),this.pswp.events.add(window,"scroll",this.observers.scroll),this.pswp.events.add(this.pswp.element,"wheel",this.observers.wheel),this.pswp.template.classList.add("pswp--has-mouse")}destroy(){this.pswp.events.removeAll()}_onKeyDown(t){if("Tab"===t.key&&\!this.pswp.options.trapFocus)return;this.isShiftPressed="Shift"===t.key||t.shiftKey}}_onKeyUp(t){this.isShiftPressed="Shift"===t.key||t.shiftKey}getTouchPoints(t){if(this.pointerEventEnabled)return[t];const e=[];return t.touches&&t.touches.length>0?e.push(...Array.prototype.slice.call(t.touches)):t.changedTouches&&t.changedTouches.length>0&&e.push(...Array.prototype.slice.call(t.changedTouches)),e}_onPointerDown(t){let e;if(t.type.includes("touch")?e=this.getTouchPoints(t):t.button>0?e=[]:e=[t],\!e.length)return;this.isDetecting=\!0;const i=e[0],s=e[1];if(this.pointers=e,this.startPointerId=i.pointerId||this.pointers.length,this.potentialTap=\!0,this.isTappedDown=\!0,this.startTime=Date.now(),this.pswp.dispatch("pointerDown",{originalEvent:t,releasePoint:i}),this.potentialTap&&(clearTimeout(this.tapTimer),this.tapTimer=setTimeout((()=>{this._tapReleased()}),300)),this.pswp.dispatch("firstTouchStart",i),s){this.isMultitouch=\!0,this.zoomStarted=\!0,this.startPointerId=null,this.currPoint={x:i.clientX,y:i.clientY},this.secondPoint={x:s.clientX,y:s.clientY};const t=this.pswp.currSlide;if(t&&t.isZoomable()){this.isZooming=\!0;const e=g(this.currPoint,this.secondPoint);this.startZoomLevel=t.currZoom,this.startZoomPoint=y(this.currPoint,this.secondPoint),this.zoomAnimated&&this.zoomAnimated.stop(),this.isZooming=\!0,t.pan.x-=0,t.pan.y-=0,t.setZoomPoint(0,0,this.startZoomLevel);this.startTime=Date.now(),this.startDistance=e,this.startPointerPos.x=this.currPoint.x,this.startPointerPos.y=this.currPoint.y,this.pswp.animations.stopAll(),this.pswp.dispatch("firstTouchMove",t)}}else{if(this.dragAxis="horizontal",t.preventDefault(),this.pointerEventEnabled&&(this.pointerMoveX=0,this.pointerMoveY=0),this.pswp.animations.stopAll(),\!this.pswp.options.allowPanToNext&&this.pswp.hasMouse&&"mousemove"\!==i.type&&"mousedown"\!==i.type)return;this.startPointerPos.x=i.clientX,this.startPointerPos.y=i.clientY,this.prevPointerPos.x=i.clientX,this.prevPointerPos.y=i.clientY}}_onPointerMove(t){if(\!this.isTappedDown)return;if(t.preventDefault(),\!this.isDetecting)return;const e=this.getTouchPoints(t);if(\!e.length)return;if(this.pointers=e,void 0\!==t.pointerId&&t.pointerId\!==this.startPointerId)return;const i=e[0]||t;(Math.abs(i.clientX-this.startPointerPos.x)>10||Math.abs(i.clientY-this.startPointerPos.y)>10)&&(this.potentialTap=\!1),e[1]?(\!this.zoomStarted&&this.isZooming&&this._handleZoom(t,e),this.pswp.dispatch("imageDragMove",{originalEvent:t})):(this.prevPointerPos.x=this.pointerMoveX||i.clientX,this.prevPointerPos.y=this.pointerMoveY||i.clientY,this.pointerMoveX=i.clientX,this.pointerMoveY=i.clientY,this.isZooming||(this._finishSwipe(t,i),this.pswp.dispatch("imageDragMove",{originalEvent:t})))}_onPointerUp(t){if(\!this.isTappedDown)return;t.preventDefault(),this.isTappedDown=\!1,this.isDetecting=\!1;const e=this.getTouchPoints(t);let i=0;if(e.length>0&&(i=e[0].pointerId||this.pointers.length,i===this.startPointerId&&this.potentialTap)){const t=this.startTime?Date.now()-this.startTime:0;t>350?this.potentialTap=\!1:this._tapReleased()}else void 0===t.pointerId&&this.pointers.length&&(this.potentialTap=\!1);if(this.potentialTap)return;let s=\!1;this.pointers=e,this.isZooming&&0===e.length&&(this.isZooming=\!1,s=\!0),this.pswp.dispatch("pointerUp",{originalEvent:t,releasePoint:e[0]||t,pointerType:t.type,releaseSpeed:s?0:void 0})}_tapReleased(){this.potentialTap&&(this.potentialTap=\!1)}_onWheel(t){this.pswp.dispatch("wheel",{originalEvent:t})}_onScroll(){this.pswp.dispatch("scroll")}_finishSwipe(t,e){}destroy(){this.pointerEventEnabled?this.pswp.events.remove(this.pswp.template,"pointerdown",this.observers.pointerDown):this.touchEventEnabled?this.pswp.events.remove(this.pswp.template,"touchstart",this.observers.pointerDown):this.pswp.events.remove(this.pswp.template,"mousedown",this.observers.pointerDown),this.pswp.events.remove(document,"keydown",this.observers.keydown),this.pswp.events.remove(document,"keyup",this.observers.keyup),this.pswp.events.remove(window,"scroll",this.observers.scroll),this.pswp.events.remove(this.pswp.element,"wheel",this.observers.wheel)}}class m{constructor(t){this.pswp=t,this.limit=3,this.items=[],this.loading=[],this.resetLazy=()=>{this.loading.length=0},this.lazyLoad=this._lazyLoad.bind(this)}loadSlide(t){return this.getSlideData(t,\!1)}getSlideData(t,e=\!0){let i,s=this.pswp.options.dataSource;if(\!s)return null;const n=t>=0?s[t]:null;if(\!n)return{html:`<div class="pswp__error-msg"><a href="" target="_blank">${this.pswp.options.contentErrorMsg}</a></div>`};const o=this._getDefaultItemData(n);return i=n.html||n.src?"inline"===n.type?{html:n.html}:{srcset:n.srcset||n.src,src:n.src,srcset:n.srcset,msrc:n.msrc,width:n.w||n.width,height:n.h||n.height,initialZoomLevel:n.initialZoomLevel,secondaryZoomLevel:n.secondaryZoomLevel,maxZoomLevel:n.maxZoomLevel}:{html:n.html||`<div class="pswp__error-msg"><a href="${n.src||""}" target="_blank">${this.pswp.options.contentErrorMsg}</a></div>`},{...o,...i}}destroy(){this.items=null,this.loading.length=0}_lazyLoad(){this.loading.filter((t=>-1\!==t)).forEach((t=>{const e=this.items[t],i=e.container.querySelector("img[data-src]");i&&(i.src=i.dataset.src,delete i.dataset.src),e.placeholder?.element.remove(),e.placeholder=null,e.onLoaded()}))}addLazy(t){this.loading[t]=t,this.loading.length>this.limit&&setTimeout(this.resetLazy,100)}updateLazy(t=0){this.loading.includes(t)&&this._lazyLoad()}_getDefaultItemData(t){return{src:t.src,w:t.w||t.width||0,h:t.h||t.height||0,msrc:t.msrc,alt:t.alt||"",srcset:t.srcset,srcElementProp:t.srcElementProp,fileName:t.fileName}}}function g(t,e){const i=e.x-t.x,s=e.y-t.y;return Math.sqrt(i*i+s*s)}function p(t){return g({x:0,y:0},t)}function y(t,e){return{x:.5*(t.x+e.x),y:.5*(t.y+e.y)}}class f{constructor(t){this.pswp=t,this._wasFocused=\!1,this._isNativeFocusElement=t=>"INPUT"===t.tagName||"TEXTAREA"===t.tagName||"SELECT"===t.tagName||"BUTTON"===t.tagName,this._focusableElements=[],this._updateFocusableElements=this._updateFocusableElements.bind(this),this.pswp.on("openComplete",this._updateFocusableElements),this.pswp.on("destroy",this.onDestroy.bind(this)),this.pswp.on("close",this.onClose.bind(this)),this._onKeyDown=this._onKeyDown.bind(this),this.pswp.element.addEventListener("keydown",this._onKeyDown)}onDestroy(){this.pswp.element.removeEventListener("keydown",this._onKeyDown),clearTimeout(this._focusTimer)}onClose(){if(\!this._wasFocused||\!this.pswp.options.returnFocus)return;let t=this._lastFocusedElement||this.pswp.options.appendToEl;if(\!t)return;if(t.focus){this._focusTimer=setTimeout((()=>{t.focus({preventScroll:\!0}),this._focusTimer=null}),500)}}_onKeyDown(t){\!t.target.closest(".pswp__container")&&this._isNativeFocusElement(t.target)||(t.keyCode||t.which)\!==9||this._wasFocused||(this._wasFocused=\!0,this._lastFocusedElement=document.activeElement)}_updateFocusableElements(){this._focusableElements=Array.from(this.pswp.element.querySelectorAll('button, input[type="button"], input[type="file"],input[type="submit"],input[type="text"],input[type="password"],textarea,select,a[href]'))}}class v{constructor(t){this.pswp=t,window.matchMedia("screen and (prefers-reduced-motion: reduce)").matches&&(t.options.zoomAnimationDuration=0,t.options.hideAnimationDuration=0,t.options.showAnimationDuration=0,t.options.initialAnimation=\!1,t.options.zoomAnimation=\!1,t.options.fadeAnimation=\!1),this.onToggle=this.onToggle.bind(this),this.onUntoggle=this.onUntoggle.bind(this),this.onAnimationEnd=this.onAnimationEnd.bind(this),t.on("initialLayout",this.onInitialLayout.bind(this)),t.on("openComplete",this.onOpenComplete.bind(this)),t.on("close",this.onClose.bind(this)),t.on("toggle",this.onToggle),t.on("untoggle",this.onUntoggle),t.on("animationEnd",this.onAnimationEnd),this.isOpen=\!1,this.isOpening=\!1,this.isClosing=\!1,this.isZooming=\!1,this.bgOpacity=1,this.animateTimer=0}onInitialLayout(){}onToggle(){this.isAnimating||this.isOpen||(this.pswp.dispatch("firstTap"),this.isOpen?this.isZooming?this.pswp.dispatch("afterToggle"):this.close():this.open())}onUntoggle(){this.isClosing&&this.pswp.dispatch("cancelClose")}onOpenComplete(){}onClose(){this.close()}open(){this.pswp.dispatch("closingAnimationEnd"),this.isOpen=\!0,this.pswp.dispatch("opening"),this.pswp.element.classList.add("pswp--open"),this.isOpening=\!0,this.pswp.dispatch("afterInit"),this._setCloseButtonTitle("Close (Esc)"),setTimeout((()=>{this.pswp.element.setAttribute("aria-hidden","false")}),16),this.pswp.dispatch("afterOpen")}close(){this.pswp.element.setAttribute("aria-hidden","true"),this.isOpen=\!1,this.isOpening=\!1,this.isClosing=\!1,this.pswp.close()}onAnimationEnd(){}destroy(){}_setCloseButtonTitle(t){const e=document.querySelector(".pswp__button--close");e&&(e.title=t)}onCloseAnimationEndCallback(){}onCloseAnimationEnd(){this.pswp.dispatch("closingAnimationEnd"),this.pswp.element.setAttribute("aria-hidden","true"),this.pswp.element.classList.remove("pswp--closed-fs")}}return class{constructor(t,e){if(this.slideSelector="img[data-src],img[data-srcset],a[href]:not([aria-disabled=true]),a[data-href]",this._itemData=[],this.defaultOptions={allowPanToNext:\!0,spacing:.1,loop:\!0,pinchToClose:\!0,closeOnVerticalDrag:\!0,hideAnimationDuration:333,showAnimationDuration:333,zoomAnimationDuration:333,escKey:\!0,arrowKeys:\!0,trapFocus:\!0,returnFocus:\!0,maxWidthToAnimate:4e3,clickToCloseNonZoomable:\!0,imageClickAction:"zoom-or-close",bgClickAction:"close",indexIndicatorSep:" / ",preloaderDelay:2e3,bgOpacity:.8,initialZoomLevel:"fit",secondaryZoomLevel:2.5,maxZoomLevel:3,imageHitAreaClass:"pswp__img--clickable",appendToEl:void 0,preload:[1,2],errorMsg:"The image cannot be loaded",fadeEffect:\!0,differenceSlideTransition:\!1,transition:"fade",wheelToZoom:\!1,initialAnimation:\!0,initialZoomInOut:\!0,pinchMode:"both",zoomMode:"both",imageAnimationDuration:333,childSelector:".pswp-gallery__item",allowMouseDrag:\!0,padding:{top:0,bottom:0,left:0,right:0},selectorsRoot:void 0,parentSelector:"a,.pswp-gallery__item"},this.options={click:"mousedown",move:"mousemove",up:"mouseup contextmenu"},"string"==typeof t?(this.options={...this.defaultOptions,...e||{}},this.onThumbnailClick=this.onThumbnailClick.bind(this),this.selector=t,this.gallery=document.querySelector(t),this.gallery&&this.initSingleGallery(this.gallery)):(this.gallery=t,this.options={...this.defaultOptions,...e||{}},this.init(t))}init(t){const e=t.closest(this.options.parentSelector);this.gallery=t,this._uid=t.dataset.pswpId||(t.dataset.pswpId=++s),this._itemData=this.buildItems(t),t.dataset.pswpOptions&&this.setOptions(JSON.parse(t.dataset.pswpOptions))}setOptions(t){t&&Object.assign(this.options,t)}initSingleGallery(t){t.addEventListener("click",this.onThumbnailClick.bind(this))}initChrome(t){this.pswpElement=t,this.createUi(t)}buildItems(t){const e=this._itemData,i=t.querySelectorAll(this.options.childSelector);let s=Array.from(i),n=t.getElementsByTagName("a");return s.forEach((t=>{if(t.dataset.pswpSrc){const{width:i,height:s}=t.dataset;e.push({element:t,msrc:t.dataset.pswpSrc,src:t.dataset.pswpSrc,alt:t.dataset.pswpAlt||"",w:parseInt(i)||0,h:parseInt(s)||0,thumbSrc:t.dataset.pswpThumbSrc})}else{if(\!(t.tagName&&"A"===t.tagName))return\!1;Object.keys(n).forEach((s=>{if(t===n[s]){const i=n[s].querySelector("img"),n=t.dataset.pswpSrc||t.href;if(n){const{width:s,height:o}=t.dataset,a=parseInt(s),r=parseInt(o),h=\!isNaN(a)&&\!isNaN(r)&&a>0&&r>0,l=i?.src||t.dataset.pswpThumbSrc;e.push({element:t,msrc:l,src:n,alt:t.dataset.pswpAlt||i?.alt||"",w:h?a:0,h:h?r:0,thumbSrc:l})}}}))}})),e}createUi(t){if(\!t)return\!1;this.gallery.dispatchEvent(new CustomEvent("pswpUiBeforeCreate",{detail:{pswp:this}})),this.createTemplate(t),this.createTopbar(),this.gallery.dispatchEvent(new CustomEvent("pswpUiAfterCreate",{detail:{pswp:this}}))}createTemplate(t){t.innerHTML=`
        <div class="pswp__bg"></div>
        <div class="pswp__scroll-wrap">
            <div class="pswp__container">
                <div class="pswp__item"></div>
                <div class="pswp__item"></div>
                <div class="pswp__item"></div>
            </div>
            <div class="pswp__ui pswp__ui--hidden">
                <div class="pswp__top-bar">
                    <div class="pswp__counter"></div>
                    <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                    <button class="pswp__button pswp__button--share" title="Share"></button>
                    <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                    <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                    <div class="pswp__preloader">
                        <div class="pswp__preloader__icn">
                            <div class="pswp__preloader__cut">
                                <div class="pswp__preloader__donut"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                    <div class="pswp__share-tooltip"></div>
                </div>
                <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
                <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>
                <div class="pswp__caption">
                    <div class="pswp__caption__center"></div>
                </div>
            </div>
        </div>`}createTopbar(){this.thumbs}onThumbnailClick(t){const e=t.target.closest(this.options.parentSelector);if(\!e&&t.target.closest("a"))return;if(e){e.dispatchEvent(new CustomEvent("pswpItemClick",{detail:{pswp:this}}));const t=this._itemData.find((t=>t.element===e));if(t){const i=this._itemData.indexOf(t);this._openPhotoSwipe({index:i}),t.element.classList.contains("pswp-gallery-item--active")||e.dispatchEvent(new CustomEvent("pswpItemClicked",{detail:{pswp:this}}))}}t.preventDefault()}_openPhotoSwipe(t){const{index:e=0}=t;let{pswpModule:i}=this.options;if(\!i)throw new Error("PhotoSwipe module was not provided");this.pswp=new i(this.createPswpOptions(e)),this.pswp.options.mainClass+="pswp--custom-icon-colors",this.pswp.containerClass="pswp-gallery",this.pswp.init?this.pswp.init():this.pswp.open(e)}createPswpOptions(t){const{gallery:e,...i}=this.options;return{dataSource:this._itemData,index:t,getItemData:t=>this._itemData[t],showAnimationType:e.showAnimationType,...i}}}}));
-e 
```
-e 
### ./js/worldmap.js

```js
// worldmap.js

// Global variables for data management
let allPhotos = [];      // Master list of all photos loaded
let filteredPhotos = []; // Array holding currently visible photos
let uniqueTags = new Set(); // To store all unique tags
let availableTrips = []; // Will be populated later for potential future usage

// DOM Element References
const filterDateStart = document.getElementById('filterDateStart');
const filterDateEnd = document.getElementById('filterDateEnd');
const filterTagsInput = document.getElementById('filterTagsInput');
const filterCountrySelect = document.getElementById('filterCountrySelect');
const tagSuggestions = document.getElementById('tagSuggestions');
const applyFiltersButton = document.getElementById('applyFiltersButton');
const clearFiltersButton = document.getElementById('clearFiltersButton');

// These elements were part of the previous UI that included grouping controls
// Adding fallbacks to prevent errors since the related UI section was removed
const tripSelector = document.getElementById('tripSelector') || document.createElement('select');
const locationList = document.getElementById('locationList') || document.createElement('div');

// Marker definitions and utilities
const ZOOM_THRESHOLD = 5; // Zoom level threshold for switching between icon types
let allMapMarkers = []; // Array to store all markers for later updates

// Simple icon for low zoom levels
const simpleIcon = L.divIcon({
    html: '<div class="simple-map-pin"></div>',
    className: 'simple-marker',
    iconSize: [14, 14],
    iconAnchor: [7, 7]
});

// Function to create a photo icon with the given thumbnail
function createPhotoIcon(thumbnailUrl) {
    return L.divIcon({
        html: '<img src="img/' + thumbnailUrl + '" class="photo-pin" />',
        className: 'photo-marker',
        iconSize: [50, 50],
        iconAnchor: [25, 25]
    });
}

// initialize the map
console.log("Initializing map...");
var map = L.map('map', {
  worldCopyJump: false
}).setView([40, 60], 2); // Adjusted to better display Russia
console.log("Map initialized:", map ? "Success" : "Failed");

console.log("Adding tile layer...");
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18,
  attribution: '&copy; openstreetmap contributors',
  noWrap: true // Prevent horizontal tiling
}).addTo(map);
console.log("Tile layer added");

// Set max bounds to prevent panning beyond world edges
map.setMaxBounds([[-90, -180], [90, 180]]);
console.log("Map bounds set");

// create marker cluster group with custom cluster icon
console.log("Creating marker cluster group...");
var markers = L.markerClusterGroup({
  iconCreateFunction: function(cluster) {
    // Check current zoom level
    const currentZoom = map.getZoom();
    const shouldShowPhotoIcons = currentZoom >= ZOOM_THRESHOLD;
    
    // If we're below the zoom threshold, use a simple cluster icon
    if (!shouldShowPhotoIcons) {
      const count = cluster.getChildCount();
      return L.divIcon({
        html: '<div class="simple-cluster">' + count + '</div>',
        className: 'simple-cluster-icon',
        iconSize: [30, 30]
      });
    }
    
    // Otherwise, build our photo stack cluster
    var markersArray = cluster.getAllChildMarkers();
    // sort markers by ranking (descending)
    markersArray.sort(function(a, b) {
      return (b.options.photoRanking || 0) - (a.options.photoRanking || 0);
    });
    // build a stack of up to three images
    var stackHtml = '<div class="cluster-stack">';
    for (var i = 0; i < Math.min(3, markersArray.length); i++) {
      var marker = markersArray[i];
      var photoUrl = marker.options.photoUrl;
      stackHtml += '<img src="img/' + photoUrl + '" class="cluster-photo cluster-photo-' + i + '" />';
    }
    stackHtml += '</div>';
    return L.divIcon({
      html: stackHtml,
      className: 'custom-cluster-icon',
      iconSize: [50, 50]
    });
  }
  // Letting zoomToBoundsOnClick use its default value (true) to restore cluster zooming
});
console.log("Marker cluster group created:", markers ? "Success" : "Failed");

// load country boundaries geojson for clickable borders
console.log("Fetching country boundaries...");
fetch('data/countries.geojson')
  .then(function(res) {
    console.log("Country data fetch response:", res.status, res.statusText);
    if (!res.ok) {
      throw new Error(`HTTP error: ${res.status} ${res.statusText}`);
    }
    return res.json();
  })
  .then(function(countryData) {
    console.log("Successfully loaded country boundaries");
    try {
      console.log("Adding country boundaries to map...");
      const countriesLayer = L.geoJSON(countryData, {
        style: { color: '#3377cc', weight: 1, fillOpacity: 0.1 },
        onEachFeature: function(feature, layer) {
          layer.on('click', function() {
            map.fitBounds(layer.getBounds());
          });
        }
      });
      countriesLayer.addTo(map);
      console.log("Country boundaries added to map");
    } catch (error) {
      console.error("Error adding country boundaries to map:", error);
    }
  })
  .catch(error => {
    console.error("Error loading country data:", error);
  });

// Load trips data for the trip selector
fetch('/api/data/trips')
  .then(function(res) { return res.json(); })
  .then(function(tripsData) {
    if (Array.isArray(tripsData)) {
      availableTrips = tripsData;
      console.log("Loaded trips data:", availableTrips.length);
    } else {
      console.error("Invalid trips data format received");
      availableTrips = [];
    }
  })
  .catch(error => {
    console.error("Error loading trips data:", error);
    availableTrips = [];
  });

// Load images json and add markers with custom icons
console.log("Fetching image data...");
fetch('/api/data/images')
  .then(function(res) {
    console.log("Image data fetch response:", res.status, res.statusText);
    if (!res.ok) {
      throw new Error(`HTTP error: ${res.status} ${res.statusText}`);
    }
    return res.json();
  })
  .then(function(images) {
    console.log("Successfully parsed images JSON data");
    
    if (!Array.isArray(images)) {
      console.error("Invalid image data received, not an array:", images);
      images = []; // Default to empty if format is wrong
    }
    
    console.log(`Received ${images.length} images`);
    
    // Debug: Check the first few images
    if (images.length > 0) {
      console.log("First image sample:", images[0]);
    }
    
    allPhotos = images; // Store master list
    filteredPhotos = [...allPhotos]; // Initially, all photos are filtered in
    
    // Count images with coordinates
    const imagesWithCoords = images.filter(img => img.lat !== undefined && img.lng !== undefined);
    console.log(`Images with coordinates: ${imagesWithCoords.length}/${images.length}`);

    // Populate unique tags
    uniqueTags.clear(); // Clear previous tags if reloading
    let tagCount = 0;
    allPhotos.forEach(img => {
      if (Array.isArray(img.tags)) {
        img.tags.forEach(tag => {
          if (tag && typeof tag === 'string') { // Ensure tag is valid
            uniqueTags.add(tag.toLowerCase().trim());
            tagCount++;
          }
        });
      }
    });
    console.log(`Unique Tags Found: ${uniqueTags.size} (from ${tagCount} total tags)`);
    
    // Populate country dropdown
    const uniqueCountries = new Set();
    allPhotos.forEach(img => {
        if (img.country && typeof img.country === 'string' && img.country.trim() !== '') {
            uniqueCountries.add(img.country.trim());
        }
    });
    const sortedCountries = [...uniqueCountries].sort();
    console.log(`Unique Countries Found: ${sortedCountries.length}`);
    populateCountryFilter(sortedCountries);
    
    // No need to prepare photoswipe data - GLightbox will be initialized on-demand

    // Initial map population using the filtered list
    console.log("Calling updateMapMarkers for initial population...");
    updateMapMarkers(); // New function to handle marker updates
  })
  .catch(error => {
    console.error("Error loading image data:", error);
    // Handle error display
  });

// No longer need to track individual markers, using cluster group instead

// Simple function to clear markers for refresh
function clearMarkers() {
  // Clear cluster group
  if (markers) {
    try {
      map.removeLayer(markers);
    } catch (e) {
      console.warn("Could not remove markers layer (might not be on map yet):", e.message);
    }
    markers.clearLayers();
  }
  
  // Reset the allMapMarkers array (important for zoom handler)
  allMapMarkers = [];
  
  // Future: Clear polylines if added later
  // clearTripPolylines();
}

// Simplified function to update the map based on filters
function updateMapMarkers() {
  console.log("=== Updating map markers based on filters... ===");

  // Apply Filters (using filteredPhotos array)
  applyFilters(); // This function will update the filteredPhotos array
  
  // Render active filters based on current input values
  renderActiveFilters();
  
  console.log(`Result of applyFilters: filteredPhotos contains ${filteredPhotos.length} items.`);
  if (filteredPhotos.length > 0) {
    console.log("First filtered photo:", filteredPhotos[0]);
  }

  // Clear previous markers
  clearMarkers();
  
  // Add filtered markers to the cluster group
  addMarkersToClusterGroup(filteredPhotos);
  
  // Ensure markers are added to map
  if (markers && markers.getLayers().length > 0) {
    console.log(`Adding marker cluster group (${markers.getLayers().length} markers) to map`);
    map.addLayer(markers);
    
    // Force a map refresh
    setTimeout(() => {
      map.invalidateSize();
    }, 100);
  }
  
  console.log("=== Map update completed ===");
}

// Filter photos based on date, tags, and country criteria
function applyFilters() {
  const startDate = filterDateStart.value; // YYYY-MM-DD
  const endDate = filterDateEnd.value;
  const tagsInput = filterTagsInput.value.toLowerCase();
  const selectedTags = tagsInput.split(',')
                        .map(t => t.trim())
                        .filter(t => t !== '');
  const selectedCountry = filterCountrySelect.value;

  console.log("Applying filters - Dates:", startDate, "-", endDate, 
              "Tags:", selectedTags, 
              "Country:", selectedCountry || "All");
  console.log("Total photos before filtering:", allPhotos.length);

  filteredPhotos = allPhotos.filter(photo => {
    // Enhanced date matching logic to handle partial dates
    let dateMatch = true;
    if (photo.date && typeof photo.date === 'string' && photo.date.match(/^\d{4}(-\d{2}(-\d{2})?)?$/)) {
      // Photo has a valid date (YYYY, YYYY-MM, or YYYY-MM-DD)
      
      // Check start date constraint
      if (startDate) {
        // If photo date is partial (YYYY or YYYY-MM), extend it for comparison
        const photoStartCompare = photo.date.padEnd(10, photo.date.length === 4 ? '-01-01' : '-01');
        
        if (photoStartCompare < startDate) {
          dateMatch = false;
        }
      }
      
      // Check end date constraint
      if (endDate && dateMatch) {
        // If photo date is partial, extend it to end of year/month for comparison
        let photoEndCompare = photo.date;
        if (photo.date.length === 4) {
          // Year only, extend to end of year (YYYY-12-31)
          photoEndCompare = `${photo.date}-12-31`;
        } else if (photo.date.length === 7) {
          // Year-month, extend to end of month (YYYY-MM-last_day)
          const year = parseInt(photo.date.substring(0, 4));
          const month = parseInt(photo.date.substring(5, 7));
          const lastDay = new Date(year, month, 0).getDate(); // Last day of the month
          photoEndCompare = `${photo.date}-${lastDay.toString().padStart(2, '0')}`;
        }
        
        if (photoEndCompare > endDate) {
          dateMatch = false;
        }
      }
    } else if (startDate || endDate) {
      // If filtering by date but photo has no valid date, exclude it
      dateMatch = false;
    }
    console.log(` -> Date Check: Start='${startDate}', End='${endDate}', PhotoDate='${photo.date}', Match=${dateMatch}`);

    let tagsMatch = true;
    if (selectedTags.length > 0) {
      if (!Array.isArray(photo.tags) || photo.tags.length === 0) {
        tagsMatch = false; // Photo has no tags, cannot match
      } else {
        // Check if ALL selected tags are present in the photo's tags
        tagsMatch = selectedTags.every(filterTag =>
          photo.tags.some(photoTag => 
            photoTag.toLowerCase().trim() === filterTag)
        );
      }
    }
    console.log(` -> Tag Check: Selected='${JSON.stringify(selectedTags)}', PhotoTags='${JSON.stringify(photo.tags)}', Match=${tagsMatch}`);

    // Country matching
    let countryMatch = true;
    if (selectedCountry !== "") {
      if (!photo.country || photo.country.toLowerCase().trim() !== selectedCountry.toLowerCase()) {
        countryMatch = false;
      }
    }
    console.log(` -> Country Check: Selected='${selectedCountry}', PhotoCountry='${photo.country}', Match=${countryMatch}`);

    const result = dateMatch && tagsMatch && countryMatch;
    console.log(` -> Overall Match: ${result}`);
    return result;
  });
  
  console.log("Filtered photos count:", filteredPhotos.length);
}

// Add markers to the cluster group based on provided photos
function addMarkersToClusterGroup(photosToShow) {
  console.log(`--- Running addMarkersToClusterGroup with ${photosToShow.length} photos ---`);
  if (!markers) { 
    console.error("ERROR: Cluster group 'markers' is not defined!"); 
    return; 
  }
  
  if (!photosToShow || photosToShow.length === 0) {
    console.warn("No photos to show, skipping marker creation");
    return;
  }
  
  allMapMarkers = []; // Reset the list of active markers
  const currentZoom = map.getZoom(); // Check zoom level for initial icons
  console.log("Current zoom level:", currentZoom);

  photosToShow.forEach((img, index) => {
    console.log(`Processing photo ${index + 1}: ${img.title || 'Untitled'}`);
    
    if (img.lat === undefined || img.lng === undefined) {
      console.warn(`  Skipping photo ${img.title || 'Untitled'} due to missing coordinates.`);
      return; // Skip photos without coords
    }
    
    console.log(`  Coordinates: [${img.lat}, ${img.lng}]`);
    
    // Determine initial icon
    const usePhotoIcon = currentZoom >= ZOOM_THRESHOLD;
    console.log(`  Icon type: ${usePhotoIcon ? 'Photo' : 'Simple'}`);
    
    try {
      // Determine initial icon
      const initialIcon = usePhotoIcon ? 
        createPhotoIcon(img.thumbnail) : simpleIcon;

      // Find the original index in allPhotos to link to photoswipeData
      const originalIndex = allPhotos.findIndex(p => p === img); // Find object reference match
      if (originalIndex === -1) {
          console.warn("Could not find original index for photo:", img.title);
          return; // Skip if we can't link it
      }

      const marker = L.marker([img.lat, img.lng], {
        icon: initialIcon,
        photoUrl: img.thumbnail, // Needed for icon switching & clustering
        photoRanking: img.ranking || 0,
        isPhotoIcon: usePhotoIcon,
        photoIndex: originalIndex, // Store original index in marker options
        photoTitle: img.title,
        photoDate: img.date,
        photoDescription: img.description
      });
      
      // Single click handler for all markers, with different behavior based on icon type
      marker.on('click', function(e) {
        // Stop event propagation to prevent cluster zoom behavior
        L.DomEvent.stopPropagation(e);
        
        const targetMarker = e.target;
        
        if (!targetMarker.options.isPhotoIcon) {
            // Simple icon - zoom in first, then open GLightbox after zoom completes
            console.log("Simple icon clicked, zooming in first...");
            map.flyTo(e.latlng, ZOOM_THRESHOLD, {
                duration: 0.5 // Shorter zoom duration
            }).once('moveend', function() {
                console.log("Zoom complete, now opening GLightbox...");
                openGLightboxForMarker(targetMarker);
            });
        } else {
            // Already photo icon, just open GLightbox directly
            console.log("Photo icon clicked, opening GLightbox directly...");
            openGLightboxForMarker(targetMarker);
        }
      });
      
      /* Comment out popup binding - using PhotoSwipe instead
      // Create Popup Content Dynamically
      var popupContent = `<strong>${img.title || 'Untitled'}</strong><br>` +
                        `<em>${img.date || ''}</em><br>` +
                        (img.thumbnail ? `<img src="img/${img.thumbnail}" alt="${img.title || ''}" style="max-width:100%; height:auto;"><br>` : '') +
                        (img.description || '');
      marker.bindPopup(popupContent);
      */

      // Add marker to cluster layer
      markers.addLayer(marker);
      
      allMapMarkers.push(marker); // Add to global list for zoom handling
      console.log(`  Marker created and added for ${img.title || 'Untitled'}`);
    } catch (markerError) {
      console.error(`  ERROR creating or adding marker for ${img.title || 'Untitled'}:`, markerError);
    }
  });
  
  console.log(`--- Finished adding ${allMapMarkers.length} markers ---`);
  // Check if markers were actually added to the cluster group
  try {
    console.log(`Marker layer count in cluster: ${markers.getLayers().length}`);
    // Note: We're not adding the cluster group to the map here anymore
    // That's now handled in updateMapMarkers()
  } catch (error) {
    console.error("Error checking marker count in cluster:", error);
  }
}

// Function to implement search filtering for country/trip lists
function addListSearchFilter(inputId, itemSelector) {
  const input = document.getElementById(inputId);
  // Ensure the container for items exists for querySelectorAll
  const listContainer = document.getElementById('locationList');
  if (!input || !listContainer) {
    console.warn(`Search input ${inputId} or item container not found for list filter.`);
    return;
  }

  input.addEventListener('input', () => {
    const filter = input.value.toLowerCase().trim();
    // Select items relative to the overall list container
    const items = listContainer.querySelectorAll(itemSelector);
    console.log(`Filtering ${items.length} items with filter '${filter}'`); // Debug
    items.forEach(item => {
      const text = item.textContent.toLowerCase();
      if (text.includes(filter)) {
        item.style.display = ''; // Show item
      } else {
        item.style.display = 'none'; // Hide item
      }
    });
  });
}

// Display photos grouped by country
function displayGroupedByCountry(countries, countryCounts) {
  console.log("Displaying grouped by country");
  console.log('Countries found in filtered data:', countries);
  if (!locationList) return;
  
  // Add search input and container for list items
  locationList.innerHTML = `
    <input type="text" id="countrySearchInput" placeholder="Search countries..." style="width: 95%; margin-bottom: 5px;">
    <div id="countryListItems"></div>`;
  
  const listItemsContainer = document.getElementById('countryListItems');
  
  // If no countries found
  if (countries.length === 0) {
    listItemsContainer.innerHTML = '<p>No countries found in current filtered photos.</p>';
    return;
  }
  
  // Populate country list
  countries.forEach(country => {
    const count = countryCounts.get(country);
    const item = document.createElement('div');
    item.className = 'location-list-item country-item';
    item.textContent = `${country} (${count})`;
    item.dataset.country = country;
    item.style.cursor = 'pointer';
    item.style.padding = '3px';
    item.addEventListener('click', () => showMarkersForCountry(country));
    listItemsContainer.appendChild(item);
  });
  
  // Add search filter
  addListSearchFilter('countrySearchInput', '#countryListItems .country-item');
  
  // Initially show all filtered photos
  addMarkersToClusterGroup(filteredPhotos);
}

// Display photos grouped by trip
function displayGroupedByTrip(tripIds) {
  console.log("Displaying grouped by trip");
  if (!locationList || !tripSelector) return;
  
  // Add search input and container for list items
  locationList.innerHTML = `
    <input type="text" id="tripSearchInput" placeholder="Search trips..." style="width: 95%; margin-bottom: 5px;">
    <div id="tripListItems"></div>`;
  
  // Reset trip selector
  tripSelector.innerHTML = '<option value="">-- All Filtered Trips --</option>';
  
  const listItemsContainer = document.getElementById('tripListItems');
  
  // Ensure global 'availableTrips' array is loaded
  if (!Array.isArray(availableTrips) || availableTrips.length === 0) {
    console.warn("Global 'availableTrips' array not loaded or empty.");
    listItemsContainer.innerHTML = '<p>No trip data available.</p>';
    return;
  }
  
  // If no trips found
  if (tripIds.size === 0) {
    listItemsContainer.innerHTML = '<p>No trips found in current filtered photos.</p>';
    return;
  }
  
  // Populate trip list and selector
  availableTrips.forEach(trip => {
    if (tripIds.has(trip.id)) {
      // Add to dropdown
      const option = document.createElement('option');
      option.value = trip.id;
      option.textContent = `${trip.name} (${trip.dateRange || ''})`;
      tripSelector.appendChild(option);
      
      // Add to list
      const item = document.createElement('div');
      item.className = 'location-list-item trip-item';
      item.textContent = `${trip.name} (${trip.dateRange || ''})`;
      item.dataset.tripId = trip.id;
      item.style.cursor = 'pointer';
      item.style.padding = '3px';
      item.addEventListener('click', () => showMarkersForTrip(trip.id));
      listItemsContainer.appendChild(item);
    }
  });
  
  // Add search filter
  addListSearchFilter('tripSearchInput', '#tripListItems .trip-item');
  
  // Add change listener to dropdown
  tripSelector.onchange = () => showMarkersForTrip(tripSelector.value);
  
  // Initially show all filtered trips combined
  showMarkersForTrip('');
}

// Populate trip selector dropdown
function populateTripSelector(photosToShow) {
  if (!tripSelector) return;
  
  tripSelector.innerHTML = '<option value="">-- Select Trip --</option>'; // Reset
  const tripIds = new Set();
  
  photosToShow.forEach(p => { 
    if (p.tripId) tripIds.add(p.tripId); 
  });

  // Find trip names from the global 'availableTrips' array
  availableTrips.forEach(trip => {
    if (tripIds.has(trip.id)) { // Only add trips that are in the filtered photos
      const option = document.createElement('option');
      option.value = trip.id;
      option.textContent = `${trip.name} (${trip.dateRange || ''})`;
      tripSelector.appendChild(option);
    }
  });
}

// Add zoom event listener to switch icons based on zoom level
console.log("Adding zoom event listener...");
map.on('zoomend', function() {
  const currentZoom = map.getZoom();
  console.log(`--- ZoomEnd Event Fired: New Zoom = ${currentZoom}, Threshold = ${ZOOM_THRESHOLD} ---`);
  console.log(`Processing ${allMapMarkers.length} markers.`);
  
  // In our diagnostic mode without clustering, we'll check allMapMarkers directly
  allMapMarkers.forEach((marker, index) => {
    if (!marker.options) { console.warn(`Marker ${index} has no options!`); return; } // Safety check

    const needsPhotoIcon = currentZoom >= ZOOM_THRESHOLD;
    const currentlyIsPhotoIcon = marker.options.isPhotoIcon;
    const photoUrl = marker.options.photoUrl; // Get the needed URL

    // console.log(`Marker ${index}: needsPhoto=${needsPhotoIcon}, isPhoto=${currentlyIsPhotoIcon}, photoUrl=${photoUrl}`); // Optional verbose log

    // Only switch icon if needed
    if (needsPhotoIcon && !currentlyIsPhotoIcon) {
        console.log(`Marker ${index}: Switching TO photo icon. URL: ${photoUrl}`);
        if (!photoUrl) {
             console.warn(`Marker ${index}: Cannot switch to photo icon, photoUrl missing!`);
             return; // Skip if no URL
        }
        try {
             marker.setIcon(createPhotoIcon(photoUrl));
             marker.options.isPhotoIcon = true;
             console.log(`Marker ${index}: Switched to photo icon OK.`);
        } catch (e) {
             console.error(`Marker ${index}: ERROR setting photo icon:`, e);
        }
    } else if (!needsPhotoIcon && currentlyIsPhotoIcon) {
        console.log(`Marker ${index}: Switching TO simple icon.`);
        try {
             marker.setIcon(simpleIcon);
             marker.options.isPhotoIcon = false;
             console.log(`Marker ${index}: Switched to simple icon OK.`);
        } catch (e) {
             console.error(`Marker ${index}: ERROR setting simple icon:`, e);
        }
    }
  });
  console.log("--- ZoomEnd Event Finished ---");
});
console.log("Zoom event listener added");

// Tag autocomplete functionality
if (filterTagsInput && tagSuggestions) {
    filterTagsInput.addEventListener('input', () => {
        const inputText = filterTagsInput.value.toLowerCase();
        // Get the last tag being typed (after the last comma)
        const parts = inputText.split(',');
        const currentTag = parts[parts.length - 1].trim().toLowerCase();

        tagSuggestions.innerHTML = ''; // Clear old suggestions

        if (currentTag === '') {
            tagSuggestions.style.display = 'none';
            return;
        }

        const suggestions = [];
        uniqueTags.forEach(tag => {
            if (tag.startsWith(currentTag)) {
                suggestions.push(tag);
            }
        });

        if (suggestions.length > 0) {
            suggestions.slice(0, 10).forEach(tag => { // Limit suggestions
                const div = document.createElement('div');
                div.textContent = tag;
                div.addEventListener('click', () => {
                    // Replace the last part being typed with the selected tag
                    parts[parts.length - 1] = tag;
                    filterTagsInput.value = parts.map(p=>p.trim()).join(', ') + ', '; // Add comma/space for next tag
                    tagSuggestions.innerHTML = '';
                    tagSuggestions.style.display = 'none';
                    filterTagsInput.focus();
                });
                tagSuggestions.appendChild(div);
            });
            tagSuggestions.style.display = 'block';
        } else {
            tagSuggestions.style.display = 'none';
        }
    });

    // Hide suggestions when input loses focus (with a small delay)
    filterTagsInput.addEventListener('blur', () => {
        setTimeout(() => { tagSuggestions.style.display = 'none'; }, 150); // Delay allows click on suggestion
    });
}

// Event handlers for view and filter controls - Simplified
// Note: groupingRadios have been removed in a previous update, so this code is no longer needed

// Validate date input format (YYYY, YYYY-MM, or YYYY-MM-DD)
function validateDateInput(input) {
    const value = input.value.trim();
    
    // Empty value is valid (no filter)
    if (!value) return true;
    
    // Check against the three valid formats
    const yearRegex = /^\d{4}$/;  // YYYY
    const yearMonthRegex = /^\d{4}-\d{2}$/;  // YYYY-MM
    const fullDateRegex = /^\d{4}-\d{2}-\d{2}$/;  // YYYY-MM-DD
    
    if (yearRegex.test(value) || yearMonthRegex.test(value) || fullDateRegex.test(value)) {
        input.style.border = '1px solid #ccc'; // Reset border if valid
        return true;
    } else {
        // Invalid format - highlight the input
        input.style.border = '1px solid red';
        return false;
    }
}

// Add validation to date inputs
if (filterDateStart) {
    filterDateStart.addEventListener('blur', () => validateDateInput(filterDateStart));
}
if (filterDateEnd) {
    filterDateEnd.addEventListener('blur', () => validateDateInput(filterDateEnd));
}

// Filter buttons connected to update function
if (applyFiltersButton) {
    applyFiltersButton.addEventListener('click', () => {
        // Validate both date inputs before updating
        const startValid = validateDateInput(filterDateStart);
        const endValid = validateDateInput(filterDateEnd);
        
        if (startValid && endValid) {
            updateMapMarkers(); // Only update if date formats are valid
        } else {
            alert('Please enter dates in YYYY, YYYY-MM, or YYYY-MM-DD format.');
        }
    });
}

if (clearFiltersButton) {
    clearFiltersButton.addEventListener('click', () => {
        filterDateStart.value = '';
        filterDateEnd.value = '';
        filterTagsInput.value = '';
        filterCountrySelect.value = '';
        // Reset any validation styling
        filterDateStart.style.border = '1px solid #ccc';
        filterDateEnd.style.border = '1px solid #ccc';
        updateMapMarkers(); // Re-apply cleared filters and update active filters display
    });
}

// Helper function to create filter badges
function createFilterBadge(type, value, displayText) {
    const badge = document.createElement('span');
    badge.className = 'filter-badge';
    badge.textContent = displayText || value; // Show specific text if provided

    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-filter';
    removeBtn.textContent = '×'; // Multiplication sign for 'x'
    removeBtn.dataset.filterType = type;
    if (value) { // Only add value dataset if needed (like for tags)
        removeBtn.dataset.filterValue = value;
    }

    badge.appendChild(removeBtn);
    return badge;
}

// Helper function to format date display based on the format
function getFormattedDateLabel(dateStr) {
    if (!dateStr) return '';
    
    // For year only (YYYY)
    if (dateStr.match(/^\d{4}$/)) {
        return `Year: ${dateStr}`;
    }
    // For year-month (YYYY-MM)
    else if (dateStr.match(/^\d{4}-\d{2}$/)) {
        const year = dateStr.substring(0, 4);
        const month = dateStr.substring(5, 7);
        // Convert numeric month to name
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const monthName = monthNames[parseInt(month) - 1];
        return `${monthName} ${year}`;
    }
    // For full date (YYYY-MM-DD)
    else if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
        // Format as a more readable date
        const year = dateStr.substring(0, 4);
        const month = dateStr.substring(5, 7);
        const day = dateStr.substring(8, 10);
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const monthName = monthNames[parseInt(month) - 1];
        return `${monthName} ${parseInt(day)}, ${year}`;
    }
    
    // Fallback for any other format
    return dateStr;
}

// Render active filters as badges
function renderActiveFilters() {
    const listContainer = document.getElementById('activeFiltersList');
    if (!listContainer) return;
    listContainer.innerHTML = ''; // Clear current badges

    const startDate = document.getElementById('filterDateStart').value.trim();
    const endDate = document.getElementById('filterDateEnd').value.trim();
    const tagsInput = document.getElementById('filterTagsInput').value;
    const selectedCountry = document.getElementById('filterCountrySelect').value;
    const selectedTags = tagsInput.split(',')
                              .map(t => t.trim())
                              .filter(t => t !== '');
    let hasFilters = false;

    // Date Start Badge - simplified text
    if (startDate) {
        listContainer.appendChild(createFilterBadge('dateStart', startDate, startDate));
        hasFilters = true;
    }
    
    // Date End Badge - simplified text
    if (endDate) {
        listContainer.appendChild(createFilterBadge('dateEnd', endDate, endDate));
        hasFilters = true;
    }
    
    // Tag Badges - simplified text
    selectedTags.forEach(tag => {
        if(tag) { // Ensure tag is not empty after trimming etc.
            listContainer.appendChild(createFilterBadge('tag', tag, tag));
            hasFilters = true;
        }
    });

    // Country Badge
    if (selectedCountry) {
        listContainer.appendChild(createFilterBadge('country', selectedCountry, selectedCountry));
        hasFilters = true;
    }

    // "None" message if no filters applied
    if (!hasFilters) {
        const noneSpan = document.createElement('span');
        noneSpan.className = 'no-filters';
        noneSpan.textContent = 'None';
        listContainer.appendChild(noneSpan);
    }
}

// Add event listener for removing filters
const activeFiltersList = document.getElementById('activeFiltersList');
if (activeFiltersList) {
    activeFiltersList.addEventListener('click', (event) => {
        if (event.target.classList.contains('remove-filter')) {
            const button = event.target;
            const type = button.dataset.filterType;
            const value = button.dataset.filterValue; // Only present for tags

            console.log(`Removing filter - Type: ${type}, Value: ${value}`);

            if (type === 'dateStart') {
                document.getElementById('filterDateStart').value = '';
            } else if (type === 'dateEnd') {
                document.getElementById('filterDateEnd').value = '';
            } else if (type === 'tag' && value) {
                const tagsInput = document.getElementById('filterTagsInput');
                let currentTags = tagsInput.value.split(',')
                                     .map(t => t.trim())
                                     .filter(t => t !== '');
                // Filter out the tag to be removed (case-insensitive compare)
                currentTags = currentTags.filter(tag => tag.toLowerCase() !== value.toLowerCase());
                tagsInput.value = currentTags.join(', '); // Join back
            } else if (type === 'country') {
                document.getElementById('filterCountrySelect').value = '';
            }

            // Re-apply filters and update map/badges
            updateMapMarkers();
        }
    });
}

// Show markers for a specific country
function showMarkersForCountry(countryName) {
    selectedCountry = countryName; // Set selected country
    console.log(`Showing markers for country: ${countryName}`);
    console.log('Filtering photos for country:', countryName);
    clearMapDisplay(); // Clear previous markers/clusters/lists etc.

    const countryPhotos = filteredPhotos.filter(p => p.country === countryName);
    console.log('Photos found for this country:', countryPhotos);
    console.log('Filtered photos for this country:', JSON.stringify(countryPhotos));
    if (countryPhotos.length === 0) {
        console.log("No photos found for this country in the current filter.");
        map.setView([20,0], 2); // Reset view
        return;
    }

    const bounds = L.latLngBounds();
    const currentZoom = map.getZoom();

    countryPhotos.forEach(img => {
        if (img.lat === undefined || img.lng === undefined) {
            console.log(`Missing coordinates for photo: ${img.title || 'Untitled'}`);
            return;
        }
        
        console.log(` Attempting to add marker for ${img.title || 'Untitled'} at [${img.lat}, ${img.lng}]`);
        
        try {
            const icon = currentZoom >= ZOOM_THRESHOLD ? 
                createPhotoIcon(img.thumbnail) : simpleIcon;
            
            const isPhotoIcon = currentZoom >= ZOOM_THRESHOLD;
            const marker = L.marker([img.lat, img.lng], { 
                icon: icon, 
                photoUrl: img.thumbnail,
                photoRanking: img.ranking || 0,
                isPhotoIcon: isPhotoIcon,
                photoTitle: img.title,
                photoDate: img.date,
                photoDescription: img.description
            });
            
            // Single click handler for all markers, with different behavior based on icon type
            marker.on('click', function(e) {
                // Stop event propagation to prevent cluster zoom behavior
                L.DomEvent.stopPropagation(e);
                
                const targetMarker = e.target;
                
                if (!targetMarker.options.isPhotoIcon) {
                    // Simple icon - zoom in first, then open GLightbox after zoom completes
                    console.log("Simple icon clicked in country view, zooming in first...");
                    map.flyTo(e.latlng, ZOOM_THRESHOLD, {
                        duration: 0.5 // Shorter zoom duration
                    }).once('moveend', function() {
                        console.log("Zoom complete, now opening GLightbox from country view...");
                        openGLightboxForMarker(targetMarker);
                    });
                } else {
                    // Already photo icon, just open GLightbox directly
                    console.log("Photo icon clicked in country view, opening GLightbox directly...");
                    openGLightboxForMarker(targetMarker);
                }
            });
            
            // No popup binding - using PhotoSwipe for images
            
            marker.addTo(map); // Add directly to map
            currentlyDisplayedMarkers.push(marker); // Track it
            bounds.extend([img.lat, img.lng]);
            console.log(` Successfully added marker for ${img.title || 'Untitled'}`);
        } catch (error) {
            console.error(`Error adding marker for ${img.title || 'Untitled'}:`, error);
        }
    });

    console.log('Calculated bounds:', bounds, 'Is valid:', bounds.isValid());
    if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [100, 100], maxZoom: 10 }); // Increased padding and zoom to fit markers
    }
    
    // Update active filters to show selected country
    renderActiveFilters();
}


// Show markers for a specific trip or all trips
function showMarkersForTrip(tripId) {
    selectedCountry = null; // Clear selected country when showing trips
    console.log(`Showing markers for trip: ${tripId || 'ALL (filtered)'}`); 
    clearMapDisplay(); // Clear previous state

    let tripPhotos;
    if (tripId === "") {
        // Show all photos that belong to ANY trip in the filtered set
        const uniqueTripIds = new Set();
        filteredPhotos.forEach(p => { if (p.tripId) uniqueTripIds.add(p.tripId); });
        tripPhotos = filteredPhotos.filter(p => uniqueTripIds.has(p.tripId));
        // Re-populate selector to ensure it reflects the currently active trips
        populateTripSelector(tripPhotos);
        document.getElementById('tripSelector').value = ""; // Ensure dropdown shows default
    } else {
        // Show photos for a SPECIFIC trip
        tripPhotos = filteredPhotos.filter(p => p.tripId === tripId);
        // Ensure dropdown reflects selection if list item was clicked
        document.getElementById('tripSelector').value = tripId;
    }

    if (tripPhotos.length === 0) {
        console.log("No photos found for this trip selection in the current filter.");
        map.setView([20,0], 2); // Reset view
        return;
    }

    const bounds = L.latLngBounds();
    const currentZoom = map.getZoom();

    // Sort photos by date within the trip (optional)
    tripPhotos.sort((a, b) => (a.date || '').localeCompare(b.date || ''));

    tripPhotos.forEach(img => {
        if (img.lat === undefined || img.lng === undefined) return;
        
        const isPhotoIcon = currentZoom >= ZOOM_THRESHOLD;
        const icon = isPhotoIcon ? createPhotoIcon(img.thumbnail) : simpleIcon;
        
        const marker = L.marker([img.lat, img.lng], { 
            icon: icon, 
            photoUrl: img.thumbnail,
            photoRanking: img.ranking || 0,
            isPhotoIcon: isPhotoIcon,
            photoTitle: img.title,
            photoDate: img.date,
            photoDescription: img.description
        });
        
        // Single click handler for all markers, with different behavior based on icon type
        marker.on('click', function(e) {
            // Stop event propagation to prevent cluster zoom behavior
            L.DomEvent.stopPropagation(e);
            
            const targetMarker = e.target;
            
            if (!targetMarker.options.isPhotoIcon) {
                // Simple icon - zoom in first, then open GLightbox after zoom completes
                console.log("Simple icon clicked in trip view, zooming in first...");
                map.flyTo(e.latlng, ZOOM_THRESHOLD, {
                    duration: 0.5 // Shorter zoom duration
                }).once('moveend', function() {
                    console.log("Zoom complete, now opening GLightbox from trip view...");
                    openGLightboxForMarker(targetMarker);
                });
            } else {
                // Already photo icon, just open GLightbox directly
                console.log("Photo icon clicked in trip view, opening GLightbox directly...");
                openGLightboxForMarker(targetMarker);
            }
        });
        
        // No popup binding - using PhotoSwipe for images
        
        marker.addTo(map);
        currentlyDisplayedMarkers.push(marker);
        bounds.extend([img.lat, img.lng]);
    });

    // Future: Draw trip polyline
    // drawTripPolyline(tripId, tripPhotos);

    if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [100, 100], maxZoom: 12 }); // Increased padding for better visibility
    }
    
    // Update active filters to show selected trip
    renderActiveFilters();
}

// Function to populate the country filter dropdown
function populateCountryFilter(countries) {
    const select = document.getElementById('filterCountrySelect');
    if (!select) return;
    
    // Clear existing options (keep the first "All Countries" option)
    while (select.options.length > 1) {
        select.remove(1);
    }
    
    // Add new options
    countries.forEach(country => {
        const option = document.createElement('option');
        option.value = country;
        option.textContent = country;
        select.appendChild(option);
    });
    
    console.log(`Populated country dropdown with ${countries.length} countries`);
}

// Add country filter change handler
if (filterCountrySelect) {
    filterCountrySelect.addEventListener('change', () => {
        // Optional: Auto-apply when country changes
        // Uncomment if you want immediate filtering on country change
        // updateMapMarkers();
    });
}

// Helper function to open GLightbox for a marker
function openGLightboxForMarker(markerInstance) {
  const clickedPhotoIndex = markerInstance.options.photoIndex;
  
  console.log(`--- Preparing GLightbox ---`);
  console.log(`Clicked Photo Index: ${clickedPhotoIndex}`);
  
  // Ensure GLightbox library is loaded
  if (typeof GLightbox === 'undefined') {
    console.error("GLightbox is not loaded!");
    alert("Error: Photo gallery library failed to load.");
    return;
  }
  
  // Get the data for the clicked photo from the master array
  if (clickedPhotoIndex === undefined || clickedPhotoIndex < 0 || clickedPhotoIndex >= allPhotos.length) {
    console.error("Invalid photo index:", clickedPhotoIndex);
    alert("Error retrieving photo data.");
    return;
  }
  
  const clickedPhotoData = allPhotos[clickedPhotoIndex];
  
  // Use the buildAndOpenLightbox helper function with 'trip' as the default context
  buildAndOpenLightbox(clickedPhotoData, 'trip');
}

// Helper function to build and open a contextual lightbox
function buildAndOpenLightbox(clickedPhoto, initialContext = 'trip') {
  let currentContext = initialContext;
  let galleryPhotos = [];
  let contextDescription = ""; // Description for the gallery title/UI
  
  // Function to filter and sort photos for a given context
  function getContextPhotos(contextType) {
    let photosInContext = [];
    let contextValue = null;
    contextDescription = "";
    
    if (contextType === 'trip') {
      contextValue = clickedPhoto.tripId;
      if (contextValue) { // If photo has a tripId
        photosInContext = allPhotos.filter(p => p.tripId === contextValue);
        const tripInfo = availableTrips.find(t => t.id === contextValue);
        contextDescription = `Trip: ${tripInfo ? tripInfo.name : contextValue}`;
      } else {
        // Fallback to country if no tripId
        console.log("No tripId found, falling back to country context.");
        return getContextPhotos('country'); // Recursive call for fallback
      }
    } else { // contextType === 'country'
      contextValue = clickedPhoto.country;
      if (contextValue) { // If photo has a country
        photosInContext = allPhotos.filter(p => p.country === contextValue);
        contextDescription = `Country: ${contextValue}`;
      } else {
        // If no country either, just show the single photo
        console.log("No country or trip found, showing single photo.");
        photosInContext = [clickedPhoto];
        contextDescription = "Single Photo";
      }
    }
    
    // Sort by date
    photosInContext.sort((a, b) => (a.date || '').localeCompare(b.date || ''));
    return photosInContext;
  }
  
  // Get initial photos based on default context
  galleryPhotos = getContextPhotos(currentContext);
  
  // If fallback resulted in single photo and initial context was trip, set context to country
  if (galleryPhotos.length === 1 && galleryPhotos[0] === clickedPhoto && initialContext === 'trip' && clickedPhoto.country) {
    currentContext = 'country';
    galleryPhotos = getContextPhotos(currentContext);
  }
  
  // Map to GLightbox format
  const galleryElements = galleryPhotos.map(p => {
    const fullImageUrl = `img/${p.imageFull || p.thumbnail}`;
    let description = `<strong>${p.title || 'Untitled'}</strong>`;
    
    if (p.date) description += ` (${p.date})`;
    
    // Add the *other* context info
    if (currentContext === 'trip' && p.country) {
      description += `<br><em>Country: ${p.country}</em>`;
    }
    
    if (currentContext === 'country' && p.tripId) {
      const tripInfo = availableTrips.find(t => t.id === p.tripId);
      if (tripInfo) description += `<br><em>Trip: ${tripInfo.name}</em>`;
    }
    
    if (p.description) description += `<br>${p.description}`;
    
    return {
      'href': fullImageUrl,
      'type': 'image',
      'title': p.title || 'Untitled',
      'description': description,
      'alt': p.description || (p.title || 'Untitled'),
      // Store original photo object reference for potential toggle later
      'photoData': p
    };
  });
  
  if (galleryElements.length === 0) {
    console.error("No photos found for the context:", currentContext);
    alert("No photos found in this context.");
    return;
  }
  
  // Find the index of the originally clicked photo in the new gallery list
  const startIndex = galleryElements.findIndex(el => el.photoData === clickedPhoto); // Compare object reference
  
  if (startIndex === -1) {
    console.error("Clicked photo not found in its own context gallery! This shouldn't happen.");
    return;
  }
  
  // Initialize GLightbox
  const lightboxOptions = {
    elements: galleryElements,
    startAt: startIndex,
    loop: true, // Loop within the context
    touchNavigation: true,
    keyboardNavigation: true,
    openEffect: 'zoom',
    closeEffect: 'fade'
  };
  
  console.log(`Initializing GLightbox (${contextDescription}) with ${galleryElements.length} elements, starting at ${startIndex}`);
  
  try {
    const lightbox = GLightbox(lightboxOptions);
    lightbox.open();
    console.log("GLightbox open() called successfully");
    
    // Show a temporary notification about the context
    showNotification(`Showing photos from ${contextDescription}`, 'info');
  } catch (initError) {
    console.error("ERROR initializing or opening GLightbox:", initError);
    alert(`Gallery Error: ${initError.message}`);
  }
}

// Helper function to show a temporary notification
function showNotification(message, type = 'info') {
  // Create notification element
  const notification = document.createElement('div');
  notification.className = `map-notification ${type}`;
  notification.textContent = message;
  notification.style.position = 'fixed';
  notification.style.bottom = '20px';
  notification.style.left = '50%';
  notification.style.transform = 'translateX(-50%)';
  notification.style.backgroundColor = type === 'info' ? 'rgba(0, 120, 255, 0.9)' : 'rgba(255, 0, 0, 0.9)';
  notification.style.color = 'white';
  notification.style.padding = '10px 20px';
  notification.style.borderRadius = '5px';
  notification.style.zIndex = '1000';
  notification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
  
  // Add to body
  document.body.appendChild(notification);
  
  // Remove after delay
  setTimeout(() => {
    notification.style.opacity = '0';
    notification.style.transition = 'opacity 0.5s ease';
    setTimeout(() => {
      document.body.removeChild(notification);
    }, 500);
  }, 3000);
}

// Wait for DOM to be fully loaded before initializing
document.addEventListener('DOMContentLoaded', function() {
  console.log("DOM fully loaded, ensuring map is initialized...");
  
  setTimeout(() => {
    // Force map to recalculate its container size
    if (map) {
      console.log("Refreshing map view...");
      map.invalidateSize();
      console.log("Map refreshed");
    }
  }, 500);
});
-e 
```
-e 
### ./photography.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Finn Wilson - Photography</title>
  
  <!-- Leaflet CSS for Map View -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  
  <!-- Cesium CSS for Globe View -->
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  
  <!-- GLightbox CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox/dist/css/glightbox.min.css" />
  
  <!-- Site Styles -->
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/worldmap.css" />
  <link rel="stylesheet" href="css/photography.css" />
</head>
<body>
  <!-- Include header -->
  <div id="header-placeholder"></div>
  <script>
    fetch('includes/header.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('header-placeholder').innerHTML = html;
        // Highlight the current page in navigation
        document.getElementById('nav-photography').classList.add('active');
      });
  </script>
  
  <!-- View Toggle Button -->
  <div id="viewToggle" class="toggle-button">
    <span id="globeToggle" class="active">Globe</span> | <span id="mapToggle">Map</span>
  </div>
  
  <!-- Map Controls (shown only for map view) -->
  <div id="mapControls" style="padding: 10px; background: #f8f8f8; border-bottom: 1px solid #ccc; display: none; flex-wrap: wrap; gap: 20px;">
    <!-- Filter Section -->
    <div id="filterSection">
      <h3>Filter Photos</h3>
      <div>
        <label for="filterDateStart">From:</label>
        <input type="text" id="filterDateStart" placeholder="YYYY-MM-DD" style="margin-right: 5px;">
        <label for="filterDateEnd">To:</label>
        <input type="text" id="filterDateEnd" placeholder="YYYY-MM-DD">
      </div>
      <div style="position: relative;">
        <label for="filterTagsInput">Tags:</label>
        <input type="text" id="filterTagsInput" placeholder="e.g., landscape, paris">
        <div id="tagSuggestions" class="autocomplete-suggestions"></div>
      </div>
      
      <div style="margin-top: 5px;">
        <label for="filterCountrySelect">Country:</label>
        <select id="filterCountrySelect">
          <option value="">-- All Countries --</option>
          <!-- Country options added by JS -->
        </select>
      </div>
      <div>
        <button id="applyFiltersButton">Apply Filters</button>
        <button id="clearFiltersButton">Clear Filters</button>
      </div>
      
      <!-- Active Filters Display -->
      <div id="activeFilters" style="width: 100%; margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
        <span>Active Filters: </span>
        <span id="activeFiltersList">
          <!-- Active filter badges will be added here by JS -->
          <span class="no-filters" style="font-style: italic; color: #888;">None</span>
        </span>
      </div>
    </div>
  </div>
  
  <!-- Globe Container -->
  <div id="globeContainer" style="height: calc(100vh - 120px);">
    <!-- Cesium container will be created dynamically inside globeContainer -->
    <div id="cesiumContainer" style="width: 100%; height: 100%;"></div>
  </div>
  
  <!-- Map Container -->
  <div id="mapContainer" style="display: none; height: calc(100vh - 120px);">
    <div id="map" style="height: 100%; width: 100%;"></div>
  </div>
  
  <!-- Footer -->
  <footer id="footer"></footer>

  <!-- JavaScript Libraries -->
  <!-- Leaflet for Map -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  
  <!-- Cesium for Globe -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js"></script>
  
  <!-- GLightbox for Image Gallery -->
  <script src="https://cdn.jsdelivr.net/npm/glightbox/dist/js/glightbox.min.js"></script>
  
  <!-- Site Scripts -->
  <script src="js/script.js"></script>
  <script src="js/globe.js"></script>
  <script src="js/worldmap.js"></script>
  <script src="js/photography.js"></script>
</body>
</html>-e 
```
-e 
### ./project-detail.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Project Detail - Finn Wilson</title> <!-- Title will be updated by JS -->
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/project-detail.css" /> <!-- Will create next -->
</head>
<body>
  <header></header>

  <main class="container">
    <article class="project-detail-content">
      <h1 id="projectTitle">Loading Project...</h1>
      <div class="project-meta">
         <p><strong>Status:</strong> <span id="projectStatus"></span></p>
         <p><strong>Links:</strong> <span id="projectLinks"></span></p>
      </div>
      <img src="" alt="Project Banner" id="projectBannerImage" class="project-banner-image" style="display: none;"> <!-- Hide initially -->

      <div id="projectBody" class="project-body-content">
        <!-- Markdown content will be injected here as HTML -->
      </div>

      <div class="back-link">
        <a href="projects.html">← Back to All Projects</a>
      </div>
    </article>
  </main>

  <footer id="footer"></footer>

  <!-- Include Marked.js library -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Include your custom script for this page -->
  <script src="js/project-detail.js"></script>
  <!-- Base script for header/footer loading etc. -->
  <script src="js/script.js"></script>
</body>
</html>-e 
```
-e 
### ./projects.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Finn Wilson - Projects</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/projects.css" />
</head>
<body>
  <header></header>
  <main class="container">
    <h1>Projects</h1>
    
    <div id="projectsContainer" class="projects-grid">
      <!-- Projects will be loaded dynamically -->
    </div>
  </main>
  <footer id="footer"></footer>
  <script src="js/script.js"></script>
  <script src="js/projects.js"></script>
</body>
</html>-e 
```
-e 
### ./research.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Finn Wilson - Research</title>
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/research.css" />
</head>
<body>
  <header></header>
  <main class="container">
    <h1>Research & Publications</h1>
    
    <section id="journal-articles">
      <h2>Journal Articles</h2>
      <!-- Journal entries will be dynamically populated by JavaScript -->
    </section>

    <section id="thesis">
      <h2>Thesis</h2>
      <!-- Thesis entry will be dynamically populated by JavaScript -->
    </section>

    <section id="conference-papers">
      <h2>Conference Papers</h2>
      <!-- Conference entries will be dynamically populated by JavaScript -->
    </section>

    <section id="patents">
      <h2>Patents</h2>
      <!-- Patent entries will be dynamically populated by JavaScript -->
    </section>
  </main>
  <footer id="footer"></footer>
  <script src="js/script.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="js/research.js" defer></script>
</body>
</html>-e 
```
-e 
### ./server.js

```js
// Load environment variables from .env file
require('dotenv').config();

// 1. Import Express and required packages
const express = require('express');
const path = require('path'); // Import the 'path' module to handle file paths
const fs = require('fs').promises; // Use promises version for cleaner async handling
const fsSync = require('fs'); // Standard fs for synchronous operations
const session = require('express-session');
const FileStore = require('session-file-store')(session); // Store sessions in files
const MemoryStore = require('memorystore')(session);
const bcrypt = require('bcryptjs');
const multer = require('multer'); // For handling multipart/form-data (file uploads)
const pointInPolygon = require('point-in-polygon'); // For determining country from coordinates
const heicConvert = require('heic-convert'); // For converting HEIC images to JPEG
const sharp = require('sharp'); // For image processing

// Configure persistent storage paths
const persistPath = process.env.PERSIST_PATH || __dirname;  // Fallback for local dev
const dataPath = path.join(persistPath, 'data');  // For JSON files
const imgPath = path.join(persistPath, 'img');    // For full images
const thumbsPath = path.join(persistPath, 'thumbs');  // For thumbnails

// --- Load Country GeoJSON Data at Startup ---
let countryFeatures = []; // Store loaded country features
const geojsonPath = path.join(dataPath, 'countries.geojson');

async function loadGeoJsonData() {
    console.log(`Loading country boundaries from: ${geojsonPath}`);
    try {
        const fileContent = await fs.readFile(geojsonPath, 'utf8');
        const geojsonData = JSON.parse(fileContent);
        if (geojsonData && geojsonData.features && Array.isArray(geojsonData.features)) {
            // Pre-process features slightly for easier lookup
            countryFeatures = geojsonData.features.map(feature => {
                // The country name property is 'name' in our GeoJSON file
                const countryName = feature.properties.name;
                return {
                    name: countryName || 'Unknown', // Store the name
                    geometry: feature.geometry // Store the geometry
                };
            }).filter(f => f.geometry); // Keep only features with geometry

            console.log(`Successfully loaded ${countryFeatures.length} country features.`);
        } else {
            console.error("Invalid GeoJSON format: 'features' array not found.");
            countryFeatures = [];
        }
    } catch (error) {
        console.error("Error loading or parsing country GeoJSON:", error);
        countryFeatures = []; // Ensure it's empty on error
    }
}

// Helper function to find country for coordinates
function findCountryForCoordinates(lng, lat) {
    if (countryFeatures.length === 0) return null; // No boundary data loaded
    const point = [lng, lat];

    for (const feature of countryFeatures) {
        if (!feature.geometry) continue; // Skip features without geometry

        try { // Add try/catch for potential bad geometry data
            if (feature.geometry.type === 'Polygon') {
                // Check point against the outer ring (and potentially holes later if needed)
                if (pointInPolygon(point, feature.geometry.coordinates[0])) {
                    console.log(`Point [${lng}, ${lat}] found in ${feature.name} (Polygon)`);
                    return feature.name;
                }
            } else if (feature.geometry.type === 'MultiPolygon') {
                // Check point against each polygon in the MultiPolygon
                const found = feature.geometry.coordinates.some(polygonCoords =>
                    pointInPolygon(point, polygonCoords[0]) // Check outer ring of each polygon
                );
                if (found) {
                    console.log(`Point [${lng}, ${lat}] found in ${feature.name} (MultiPolygon)`);
                    return feature.name;
                }
            }
        } catch (geomError) {
            console.warn(`Error processing geometry for feature ${feature.name || 'Unknown'}:`, geomError);
            // Continue checking other features
        }
    }
    console.log(`Point [${lng}, ${lat}] not found in any country polygon.`);
    return null; // Not found in any polygon
}

// Call loadGeoJsonData once during server startup
loadGeoJsonData();

// 2. Create an Express application instance
const app = express();

// Trust Render's proxy
app.set('trust proxy', 1);  // Trusts 1 proxy hop (Render's default)

// IMPORTANT: Replace with the actual hash generated for the "finnwilson" password
const ADMIN_PASSWORD_HASH = process.env.ADMIN_PASSWORD_HASH || '$2b$10$IhEVxRBIRWx3AW89DUpOU...UFHS/h6aDadCACmnYPfw3ye4oGoCa';
const ADMIN_USERNAME = 'admin'; // Optional username

// Middleware to parse JSON bodies
app.use(express.json({ limit: '10mb' })); // Allow larger payload for potential markdown content

// Session configuration
let sessionStore;
if (process.env.NODE_ENV === 'production') {
  sessionStore = new MemoryStore({ checkPeriod: 86400000 });  // For Render: In-memory, prunes expired
} else {
  sessionStore = new FileStore({ path: './.sessions', logFn: function(){} });  // For local: Keeps your original
}

app.use(session({
  store: sessionStore,
  secret: process.env.SESSION_SECRET || 'dev-fallback-secret-change-me', // Long random string for session security
  resave: false,  // Don't resave unchanged sessions (efficient)
  saveUninitialized: false, // Don't create session until something stored
  rolling: true,  // Renew cookie on every request to prevent expiry mid-action
  cookie: {
      secure: process.env.NODE_ENV === 'production',  // HTTPS on Render, HTTP local
      httpOnly: true, // Prevent client-side JS access to cookie
      sameSite: 'lax',  // Balances security/cross-request issues (better than default 'strict')
      maxAge: 1000 * 60 * 60 * 24 * 7  // 7 days—adjust if too long/short
  }
}));

// 3. Define the port the server will listen on
// Use process.env.PORT for compatibility with hosting providers,
// or default to 3000 for local development.
const PORT = process.env.PORT || 3000;

// 4. Serve Static Files
// This tells Express that if a request comes in for a file (like .css, .js, .html, .jpg),
// it should look for that file relative to the project's root directory.
// The directory where server.js lives is considered the root by default with __dirname.
app.use(express.static(path.join(__dirname))); // Serves files from the root project directory

// Optional: Serve specific directories if needed (usually app.use(express.static(__dirname)) is enough)
// app.use('/css', express.static(path.join(__dirname, 'css')));
// app.use('/js', express.static(path.join(__dirname, 'js')));
app.use('/img', express.static(imgPath)); // Explicitly serve the image directory
app.use('/icons', express.static(path.join(__dirname, 'icons'))); // Explicitly serve the icons directory
// app.use('/data', express.static(path.join(__dirname, 'data')));

// 5. Optional: Default Route (Good Practice)
// If someone requests the root '/' and express.static didn't find an index.html automatically,
// this explicitly serves your index.html file.
// express.static usually handles index.html automatically, so this might be redundant
// but doesn't hurt.
// app.get('/', (req, res) => {
//   res.sendFile(path.join(__dirname, 'index.html'));
// });

// --- Multer Configuration for Image Uploads ---
const imageStorage = multer.diskStorage({
    destination: function (req, file, cb) {
        // Ensure the 'img/' directory exists relative to server.js
        const uploadPath = imgPath;
        
        // Create directory if it doesn't exist (sync for simplicity)
        try {
            if (!fsSync.existsSync(uploadPath)) {
                fsSync.mkdirSync(uploadPath, { recursive: true });
                console.log(`Created upload directory: ${uploadPath}`);
            }
        } catch (err) {
            console.error(`Error ensuring upload directory exists: ${err.message}`);
        }
        
        cb(null, uploadPath); // Save files to the 'img' directory
    },
    filename: function (req, file, cb) {
        // Create a unique filename to avoid overwrites
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        const extension = path.extname(file.originalname); // Get original extension
        const safeOriginalName = file.originalname.replace(/[^a-zA-Z0-9._-]/g, '_'); // Sanitize original name
        cb(null, `upload-${uniqueSuffix}${extension}`);
    }
});

// File Filter to accept only images
const imageFileFilter = (req, file, cb) => {
    // Accept standard image types AND HEIC/HEIF
    if (file.mimetype.startsWith('image/jpeg') ||
        file.mimetype.startsWith('image/png') ||
        file.mimetype.startsWith('image/gif') ||
        file.mimetype.startsWith('image/webp') ||
        file.mimetype.startsWith('image/heic') || // HEIC support
        file.mimetype.startsWith('image/heif') || // HEIF support
        file.mimetype.startsWith('image/')) {
        cb(null, true); // Accept file
    } else {
        console.warn(`Upload rejected: Invalid mimetype ${file.mimetype}`);
        cb(new Error('Invalid file type. Only images (JPG, PNG, GIF, WebP, HEIC, HEIF) are allowed.'), false); // Reject file
    }
};

// Create Multer instance with configuration
const upload = multer({
     storage: imageStorage,
     fileFilter: imageFileFilter,
     limits: { fileSize: 1024 * 1024 * 30 } // Limit file size to 30MB
});
// --- End Multer Configuration ---

// Request logging middleware (temporary for debugging)
app.use((req, res, next) => {
  console.log(`Request: ${req.method} ${req.path} - Authenticated: ${!!req.session?.isAuthenticated}`);
  next();
});

// Middleware function to check if user is authenticated
function requireAuth(req, res, next) {
    if (req.session && req.session.isAuthenticated) {
        // User is authenticated, proceed to the next middleware or route handler
        return next();
    } else {
        // User is not authenticated, send an unauthorized error
        console.warn('Unauthorized access attempt denied.');
        res.status(401).json({ error: 'Unauthorized. Please log in.' });
    }
}

// API Endpoint for Login
app.post('/api/login', async (req, res) => {
    const { username = 'admin', password } = req.body;  // Default if not sent
    console.log(`Login attempt: user='${username}'`);
    
    // Basic validation
    if (!password) {
        return res.status(400).json({ success: false, error: 'Password is required.' });
    }
    
    try {
        if (await bcrypt.compare(password, ADMIN_PASSWORD_HASH)) {
            // Regenerate session ID on login for security
            req.session.regenerate(err => {
                if (err) {
                    console.error("Session regeneration error:", err);
                    return res.status(500).json({ success: false, error: 'Login failed (session error).' });
                }
                // Store authentication status in session
                req.session.isAuthenticated = true;
                req.session.username = username;
                
                // Force session save
                req.session.save((err) => {
                    if (err) {
                        console.error('Session save error:', err);
                        return res.status(500).json({ success: false, error: 'Login failed (session save error).' });
                    }
                    console.log('Login successful for user:', username);
                    res.status(200).json({ success: true });
                });
            });
        } else {
            console.log('Invalid password attempt');
            res.status(401).json({ success: false, error: 'Invalid password' });
        }
    } catch (err) {
        console.error('Login error:', err);
        res.status(500).json({ success: false, error: 'Server error' });
    }
});

// API Endpoint for Logout
app.post('/api/logout', (req, res) => {
    console.log('Logout attempt...');
    if (req.session) {
        req.session.destroy(err => {
            if (err) {
                console.error("Error destroying session:", err);
                return res.status(500).json({ success: false, message: 'Logout failed.' });
            }
            // Clears the cookie set by express-session
            res.clearCookie('connect.sid'); // Use the default cookie name or your configured name
            console.log('Logout successful.');
            res.json({ success: true, message: 'Logged out successfully.' });
        });
    } else {
        console.log('Logout successful (no session existed).');
        res.json({ success: true, message: 'Logged out successfully.' }); // Or handle as needed
    }
});

// Optional: Add an endpoint to check auth status for frontend use
app.get('/api/auth/status', (req, res) => {
    if (req.session && req.session.isAuthenticated) {
        res.json({ isAuthenticated: true, username: req.session.username });
    } else {
        res.json({ isAuthenticated: false });
    }
});

// API Endpoint to get Books data
app.get('/api/data/books', async (req, res) => {
  const filePath = path.join(dataPath, 'books.json');
  console.log(`GET /api/data/books - Reading: ${filePath}`); // Server log
  try {
    const fileContent = await fs.readFile(filePath, 'utf8');
    const jsonData = JSON.parse(fileContent);
    
    // Validate that we have an array
    if (!Array.isArray(jsonData)) {
      throw new Error('Invalid format: Expected array of books.');
    }
    
    console.log(`Successfully read books data (${jsonData.length} books)`);
    res.json(jsonData); // Send parsed JSON data
  } catch (error) {
    console.error(`Error reading or parsing ${filePath}:`, error);
    if (error.code === 'ENOENT') {
      res.status(404).json({ 
        success: false, 
        error: `Data file not found: ${path.basename(filePath)}` 
      });
    } else if (error instanceof SyntaxError || error.message.includes('Invalid format')) {
      res.status(500).json({ 
        success: false, 
        error: `Failed to parse data file. Invalid JSON format in ${path.basename(filePath)}.` 
      });
    } else {
      res.status(500).json({ 
        success: false, 
        error: `Internal server error while processing books data.` 
      });
    }
  }
});

// API Endpoint to get Images data
app.get('/api/data/images', async (req, res) => {
  const filePath = path.join(dataPath, 'images.json');
  console.log(`GET /api/data/images - Reading: ${filePath}`);
  try {
    const fileContent = await fs.readFile(filePath, 'utf8');
    const jsonData = JSON.parse(fileContent);
    
    // Ensure every photo has a sortIndex
    const photos = jsonData;
    photos.forEach((p, i) => {
      if (typeof p.sortIndex !== 'number') p.sortIndex = i;
    });
    
    res.json(photos);
  } catch (error) {
    console.error(`Error reading or parsing ${filePath}:`, error);
    if (error.code === 'ENOENT') {
      res.status(404).json({ error: 'Images data file not found.' });
    } else if (error instanceof SyntaxError) {
      res.status(500).json({ error: 'Failed to parse images data file. Invalid JSON.'});
    } else {
      res.status(500).json({ error: 'Failed to retrieve images data.' });
    }
  }
});

// API Endpoint to get Projects data
app.get('/api/data/projects', async (req, res) => {
  const filePath = path.join(dataPath, 'projects.json');
  console.log(`GET /api/data/projects - Reading: ${filePath}`);
  try {
    const fileContent = await fs.readFile(filePath, 'utf8');
    const jsonData = JSON.parse(fileContent);
    res.json(jsonData);
  } catch (error) {
    console.error(`Error reading or parsing ${filePath}:`, error);
    if (error.code === 'ENOENT') {
      res.status(404).json({ error: 'Projects data file not found.' });
    } else if (error instanceof SyntaxError) {
      res.status(500).json({ error: 'Failed to parse projects data file. Invalid JSON.'});
    } else {
      res.status(500).json({ error: 'Failed to retrieve projects data.' });
    }
  }
});

// GET Homepage Data
app.get('/api/data/homepage', async (req, res) => {
  const filePath = path.join(dataPath, 'homepage.json');
  console.log(`GET /api/data/homepage - Reading: ${filePath}`);
  try {
    const data = await fs.readFile(filePath, 'utf8');
    const homepageData = JSON.parse(data);
    res.json(homepageData);
  } catch (error) {
    console.error(`Error reading ${filePath}:`, error);
    if (error.code === 'ENOENT') {
      res.status(404).json({ error: 'Homepage file not found.' });
    } else {
      res.status(500).json({ error: 'Failed to retrieve homepage content.' });
    }
  }
});

// GET Contact Banner Data
app.get('/api/data/contactBanner', async (req, res) => {
  const filePath = path.join(dataPath, 'contactBanner.json');
  console.log(`GET /api/data/contactBanner - Reading: ${filePath}`);
  try {
    const fileContent = await fs.readFile(filePath, 'utf8');
    const jsonData = JSON.parse(fileContent);
    
    // Handle both old array format and new object format for backward compatibility
    if (Array.isArray(jsonData)) {
      // Convert old array format to new object format
      res.json({ headerText: '', items: jsonData });
    } else if (typeof jsonData === 'object' && jsonData !== null) {
      // Validate new object format
      if (!jsonData.hasOwnProperty('headerText') || !Array.isArray(jsonData.items)) {
        throw new Error('Invalid format: Expected object with headerText string and items array.');
      }
      res.json(jsonData);
    } else {
      throw new Error('Invalid format: Expected object with headerText and items array.');
    }
  } catch (error) {
    console.error(`Error reading or parsing ${filePath}:`, error);
    if (error.code === 'ENOENT') {
      res.status(404).json({ error: 'Contact banner data file not found.' });
    } else if (error instanceof SyntaxError || error.message.includes('Expected')) {
      res.status(500).json({ error: 'Failed to parse contact banner data file. Invalid JSON format.'});
    } else {
      res.status(500).json({ error: 'Failed to retrieve contact banner data.' });
    }
  }
});

// POST Homepage Data
app.post('/api/save/homepage', requireAuth, async (req, res) => {
  const filePath = path.join(dataPath, 'homepage.json');
  const backupFilePath = filePath + '.bak';
  console.log(`POST /api/save/homepage - Saving to: ${filePath}`);
  
  if (!req.body.content || typeof req.body.content !== 'string') {
    return res.status(400).json({ error: 'Invalid data format. Expected object with content string.' });
  }
  
  try {
    // Read existing data to preserve image field
    let existingData = { content: '', image: '' };
    try {
      const existingFile = await fs.readFile(filePath, 'utf8');
      existingData = JSON.parse(existingFile);
    } catch (readError) {
      console.log('No existing homepage.json found, creating new one');
    }
    
    // Backup logic
    try { 
      await fs.copyFile(filePath, backupFilePath); 
      console.log(`Backup created: ${backupFilePath}`); 
    } catch (backupError) { 
      if (backupError.code !== 'ENOENT') 
        console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
    }
    
    // Update content while preserving image
    const updatedData = {
      content: req.body.content,
      image: req.body.image || existingData.image || ''
    };
    
    await fs.writeFile(filePath, JSON.stringify(updatedData, null, 2), 'utf8');
    res.status(200).json({ message: 'Homepage content saved successfully.' });
  } catch (error) {
    console.error(`Error writing ${filePath}:`, error);
    res.status(500).json({ error: 'Failed to save homepage content.' });
  }
});

// API Endpoint to SAVE Books data
app.post('/api/save/books', requireAuth, async (req, res) => {
  const filePath = path.join(dataPath, 'books.json');
  const backupFilePath = filePath + '.bak'; // Backup file path
  console.log(`POST /api/save/books - Saving to: ${filePath}`);

  // Basic Array Validation
  const books = req.body;
  if (!Array.isArray(books)) {
    return res.status(400).json({ 
      success: false, 
      error: 'Invalid data format. Expected an array of books.' 
    });
  }

  // Item Validation
  console.log(`Validating ${books.length} books...`);
  for (let i = 0; i < books.length; i++) {
    const book = books[i];
    // Check if book is an object
    if (!book || typeof book !== 'object' || Array.isArray(book)) {
      return res.status(400).json({ 
        success: false, 
        error: `Invalid item format at index ${i}. Expected an object.` 
      });
    }
    
    // Required fields validation
    if (!book.title || typeof book.title !== 'string' || book.title.trim() === '') {
      return res.status(400).json({ 
        success: false, 
        error: `Missing or invalid 'title' at index ${i}.` 
      });
    }
    if (!book.author || typeof book.author !== 'string' || book.author.trim() === '') {
      return res.status(400).json({ 
        success: false, 
        error: `Missing or invalid 'author' at index ${i}.` 
      });
    }
    
    // Optional fields validation (with defaults if missing)
    if (book.rating !== undefined && (typeof book.rating !== 'number' || book.rating < 1 || book.rating > 5)) {
      return res.status(400).json({ 
        success: false, 
        error: `Invalid 'rating' at index ${i}. Expected a number between 1 and 5.` 
      });
    }
  }
  console.log("Book validation passed successfully");

  try {
    // Backup existing file before overwriting
    try {
       await fs.copyFile(filePath, backupFilePath);
       console.log(`Backup created: ${backupFilePath}`);
    } catch (backupError) {
       // If backup fails (e.g., first time saving), log warning but continue
       if (backupError.code !== 'ENOENT') { // Ignore if original doesn't exist yet
           console.warn(`Warning: Could not create backup for ${filePath}:`, backupError);
       }
    }

    // Convert received data back to JSON string
    const jsonString = JSON.stringify(books, null, 2); // Pretty print

    // Write the new data to the file
    await fs.writeFile(filePath, jsonString, 'utf8');
    console.log(`Successfully wrote ${books.length} books to ${path.basename(filePath)}`);

    // Send success response
    res.status(200).json({ 
      success: true, 
      message: 'Books data saved successfully.' 
    });

  } catch (error) {
    console.error(`Error writing ${filePath}:`, error);
    res.status(500).json({ 
      success: false, 
      error: `Failed to save books data: ${error.message}` 
    });
  }
});

// API Endpoint to SAVE Images data
app.post('/api/save/images', requireAuth, async (req, res) => {
   const filePath = path.join(dataPath, 'images.json');
   const backupFilePath = filePath + '.bak';
   console.log(`POST /api/save/images - Saving to: ${filePath}`);
   if (!Array.isArray(req.body)) {
     return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
   }
   
   // --- Add Reverse Geocoding Step ---
   const images = req.body; // Assume validation passed
   console.log(`POST ${filePath} - Received ${images.length} images.`);
   
   let updatedCount = 0;
   for (const image of images) {
       const lat = parseFloat(image.lat);
       const lng = parseFloat(image.lng);
       // Check if country is missing/empty AND coords are valid
       if ((!image.country || image.country.trim() === '') && !isNaN(lat) && !isNaN(lng)) {
           const foundCountry = findCountryForCoordinates(lng, lat);
           if (foundCountry && foundCountry !== 'Unknown') {
               console.log(`Assigning country "${foundCountry}" to image "${image.title || 'Untitled'}".`);
               image.country = foundCountry; // Update the image object directly
               updatedCount++;
           }
       }
   }
   if (updatedCount > 0) console.log(`Automatically assigned country to ${updatedCount} images.`);
   // --- End Reverse Geocoding Step ---
   
   try {
     // Backup logic
     try { 
       await fs.copyFile(filePath, backupFilePath); 
       console.log(`Backup created: ${backupFilePath}`); 
     } catch (backupError) { 
       if (backupError.code !== 'ENOENT') 
         console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
     }

     const jsonString = JSON.stringify(images, null, 2);
     await fs.writeFile(filePath, jsonString, 'utf8');
     
     // Include info about country detection in the response
     res.status(200).json({ 
       message: 'Images data saved successfully.',
       countriesAssigned: updatedCount > 0 ? `Automatically detected countries for ${updatedCount} images.` : null
     });
   } catch (error) {
     console.error(`Error writing ${filePath}:`, error);
     res.status(500).json({ error: 'Failed to save images data.' });
   }
});

// API Endpoint to SAVE Projects data
app.post('/api/save/projects', requireAuth, async (req, res) => {
   const filePath = path.join(dataPath, 'projects.json');
   const backupFilePath = filePath + '.bak';
   console.log(`POST /api/save/projects - Saving to: ${filePath}`);
   if (!Array.isArray(req.body)) {
     return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
   }
   try {
     try { await fs.copyFile(filePath, backupFilePath); console.log(`Backup created: ${backupFilePath}`); }
     catch (backupError) { if (backupError.code !== 'ENOENT') console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); }

     const jsonString = JSON.stringify(req.body, null, 2);
     await fs.writeFile(filePath, jsonString, 'utf8');
     
     // Update CV skills cache after saving projects
     await updateCvSkillsCache();
     
     res.status(200).json({ message: 'Projects data saved successfully.' });
   } catch (error) {
     console.error(`Error writing ${filePath}:`, error);
     res.status(500).json({ error: 'Failed to save projects data.' });
   }
});

/**
 * POST /api/projects/reorder
 * Reorders projects based on provided indices
 * @param {Array} req.body - Array of {id, idx} pairs
 * @returns {204} No content on success
 */
app.post('/api/projects/reorder', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'projects.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/projects/reorder - Reordering projects`);
    
    try {
        const payload = req.body; // [{id: 'project-id', idx: 0}, ...]
        
        if (!Array.isArray(payload)) {
            return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
        }
        
        // Create backup
        try {
            await fs.copyFile(filePath, backupFilePath);
            console.log(`Backup created: ${backupFilePath}`);
        } catch (backupError) {
            if (backupError.code !== 'ENOENT') {
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError);
            }
        }
        
        // Load current projects
        const fileContent = await fs.readFile(filePath, 'utf8');
        const projects = JSON.parse(fileContent);
        
        // Create mapping from id to new index
        const posMap = new Map(payload.map(item => [item.id, item.idx]));
        
        // Sort projects: mentioned ones first by idx, others maintain relative order
        projects.sort((a, b) => {
            const idA = a.id;
            const idB = b.id;
            const inA = posMap.has(idA);
            const inB = posMap.has(idB);
            
            if (inA && inB) return posMap.get(idA) - posMap.get(idB);
            if (inA) return -1;
            if (inB) return 1;
            return (a.order || 0) - (b.order || 0); // maintain existing order
        });
        
        // Re-index order field
        projects.forEach((project, index) => {
            project.order = index;
        });
        
        // Save updated projects
        await fs.writeFile(filePath, JSON.stringify(projects, null, 2), 'utf8');
        
        console.log(`Reordered ${payload.length} projects`); // TODO: Remove after debugging
        
        res.sendStatus(204); // No content
    } catch (error) {
        console.error('Error reordering projects:', error);
        res.status(500).json({ error: 'Failed to reorder projects.' });
    }
});

// SAVE Contact Banner Data (Authenticated)
app.post('/api/save/contactBanner', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'contactBanner.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/contactBanner - Saving to: ${filePath}`);
    
    // Validate new object format with headerText and items
    if (typeof req.body !== 'object' || req.body === null || 
        typeof req.body.headerText !== 'string' || 
        !Array.isArray(req.body.items)) {
        return res.status(400).json({ error: 'Invalid data format. Expected object with headerText string and items array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        res.status(200).json({ message: 'Contact banner data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save contact banner data.' });
    }
});

// === Skill Derivation Functions ===

/**
 * Derives skills from projects.json.
 * @param {Array} projects - Array of project objects
 * @returns {Object} skill to project IDs map
 */
function deriveSkillsFromProjects(projects) {
    const skillMap = {};
    
    if (!Array.isArray(projects)) {
        console.warn('deriveSkillsFromProjects: Invalid projects input, expected array');
        return skillMap;
    }
    
    projects.forEach(project => {
        if (project.id && project.skills) {
            // Handle both array and comma-separated string formats
            let skillsArray = [];
            if (Array.isArray(project.skills)) {
                skillsArray = project.skills;
            } else if (typeof project.skills === 'string') {
                skillsArray = project.skills.split(',').map(s => s.trim()).filter(s => s);
            }
            
            skillsArray.forEach(skill => {
                if (!skillMap[skill]) {
                    skillMap[skill] = [];
                }
                if (!skillMap[skill].includes(project.id)) {
                    skillMap[skill].push(project.id);
                }
            });
        }
    });
    
    console.log(`Derived ${Object.keys(skillMap).length} unique skills from projects`); // TODO: Remove after debugging
    return skillMap;
}

/**
 * Updates cv_skills.json cache with derived skills from projects.
 * Merges manual skills with derived ones (manual takes precedence).
 * @returns {Promise<void>}
 */
async function updateCvSkillsCache() {
    const cvSkillsPath = path.join(dataPath, 'cv_skills.json');
    const projectsPath = path.join(dataPath, 'projects.json');
    const workPath = path.join(dataPath, 'cv_work.json');
    const researchPath = path.join(dataPath, 'cv_research.json');
    
    try {
        // Load existing cv_skills, projects, work, and research
        let cvSkills = {};
        let projects = [];
        let workData = [];
        let researchData = [];
        
        try {
            const cvSkillsContent = await fs.readFile(cvSkillsPath, 'utf8');
            cvSkills = JSON.parse(cvSkillsContent);
        } catch (error) {
            console.log('cv_skills.json not found or invalid, creating new structure');
            cvSkills = {
                programming: [],
                software: [],
                technical: [],
                uncategorized: [],
                allSkillsCache: []
            };
        }
        
        try {
            const projectsContent = await fs.readFile(projectsPath, 'utf8');
            projects = JSON.parse(projectsContent);
        } catch (error) {
            console.log('projects.json not found or invalid');
        }
        
        try {
            const workContent = await fs.readFile(workPath, 'utf8');
            workData = JSON.parse(workContent);
        } catch (error) {
            console.log('cv_work.json not found or invalid');
        }
        
        try {
            const researchContent = await fs.readFile(researchPath, 'utf8');
            researchData = JSON.parse(researchContent);
        } catch (error) {
            console.log('cv_research.json not found or invalid');
        }
        
        // Derive skills from projects
        const derivedSkillMap = deriveSkillsFromProjects(projects);
        
        // Ensure all required fields exist
        if (!cvSkills.uncategorized) cvSkills.uncategorized = [];
        if (!cvSkills.allSkillsCache) cvSkills.allSkillsCache = [];
        
        // Get all manual skills
        const manualSkills = new Set();
        let duplicateCount = 0;
        
        // Add projects field to existing manual skills
        ['programming', 'software', 'technical'].forEach(category => {
            if (Array.isArray(cvSkills[category])) {
                cvSkills[category] = cvSkills[category].map(skill => {
                    if (typeof skill === 'string') {
                        manualSkills.add(skill);
                        return {
                            name: skill,
                            projects: derivedSkillMap[skill] || []
                        };
                    } else if (skill && skill.name) {
                        manualSkills.add(skill.name);
                        // Update projects for existing skill objects
                        skill.projects = derivedSkillMap[skill.name] || [];
                        return skill;
                    }
                    return skill;
                });
            }
        });
        
        // Add new derived skills to uncategorized (avoiding duplicates)
        Object.entries(derivedSkillMap).forEach(([skill, projectIds]) => {
            if (!manualSkills.has(skill)) {
                // Check if already in uncategorized
                const existingIndex = cvSkills.uncategorized.findIndex(s => s.name === skill);
                if (existingIndex === -1) {
                    cvSkills.uncategorized.push({
                        name: skill,
                        projects: projectIds
                    });
                } else {
                    // Update existing uncategorized skill's projects
                    cvSkills.uncategorized[existingIndex].projects = projectIds;
                    duplicateCount++;
                }
            } else {
                duplicateCount++;
            }
        });
        
        // Process work and research skills (add to uncategorized if not already existing)
        const processRoleSkills = (roles, sourceType) => {
            if (Array.isArray(roles)) {
                roles.forEach(role => {
                    if (role.skills && Array.isArray(role.skills)) {
                        role.skills.forEach(skillName => {
                            // Check if skill exists in any category
                            let skillExists = false;
                            ['programming', 'software', 'technical'].forEach(category => {
                                if (cvSkills[category] && cvSkills[category].some(s => s.name === skillName)) {
                                    skillExists = true;
                                }
                            });
                            
                            // If skill doesn't exist anywhere, add to uncategorized
                            if (!skillExists) {
                                const existingIndex = cvSkills.uncategorized.findIndex(s => s.name === skillName);
                                if (existingIndex === -1) {
                                    cvSkills.uncategorized.push({
                                        name: skillName,
                                        projects: [],
                                        source: sourceType
                                    });
                                } else {
                                    // Update source if skill exists
                                    cvSkills.uncategorized[existingIndex].source = sourceType;
                                }
                            }
                        });
                    }
                });
            }
        };
        
        processRoleSkills(workData, 'role');
        processRoleSkills(researchData, 'role');
        
        // Build allSkillsCache - sorted unique array of all skill names
        const allSkills = new Set();
        ['programming', 'software', 'technical'].forEach(category => {
            if (Array.isArray(cvSkills[category])) {
                cvSkills[category].forEach(skill => {
                    if (skill && skill.name) {
                        allSkills.add(skill.name);
                    }
                });
            }
        });
        
        if (Array.isArray(cvSkills.uncategorized)) {
            cvSkills.uncategorized.forEach(skill => {
                if (skill && skill.name) {
                    allSkills.add(skill.name);
                }
            });
        }
        
        cvSkills.allSkillsCache = Array.from(allSkills).sort();
        
        // Save updated cv_skills.json
        await fs.writeFile(cvSkillsPath, JSON.stringify(cvSkills, null, 2), 'utf8');
        
        console.log(`Processed ${allSkills.size} skills, ${duplicateCount} duplicates avoided`); // TODO: Remove after debugging
        
    } catch (error) {
        console.error('Error updating CV skills cache:', error);
    }
}

// === CV API Endpoints ===

// GET CV Education Data
app.get('/api/data/cv/education', async (req, res) => {
    const filePath = path.join(dataPath, 'cv_education.json');
    console.log(`GET /api/data/cv/education - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (!Array.isArray(jsonData)) throw new Error('Invalid format: Expected array.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'CV Education data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected array')) {
            res.status(500).json({ error: 'Failed to parse CV Education data file. Invalid JSON array format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve CV Education data.' });
        }
    }
});

// SAVE CV Education Data (Authenticated)
app.post('/api/save/cv/education', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'cv_education.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/cv/education - Saving to: ${filePath}`);
    if (!Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        res.status(200).json({ message: 'CV Education data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save CV Education data.' });
    }
});

// GET CV Work Data
app.get('/api/data/cv/work', async (req, res) => {
    const filePath = path.join(dataPath, 'cv_work.json');
    console.log(`GET /api/data/cv/work - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (!Array.isArray(jsonData)) throw new Error('Invalid format: Expected array.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'CV Work data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected array')) {
            res.status(500).json({ error: 'Failed to parse CV Work data file. Invalid JSON array format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve CV Work data.' });
        }
    }
});

// SAVE CV Work Data (Authenticated)
app.post('/api/save/cv/work', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'cv_work.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/cv/work - Saving to: ${filePath}`);
    if (!Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        
        // Update skills cache to include work-related skills
        await updateCvSkillsCache();
        
        res.status(200).json({ message: 'CV Work data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save CV Work data.' });
    }
});

// GET CV Research Data
app.get('/api/data/cv/research', async (req, res) => {
    const filePath = path.join(dataPath, 'cv_research.json');
    console.log(`GET /api/data/cv/research - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (!Array.isArray(jsonData)) throw new Error('Invalid format: Expected array.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'CV Research data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected array')) {
            res.status(500).json({ error: 'Failed to parse CV Research data file. Invalid JSON array format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve CV Research data.' });
        }
    }
});

// SAVE CV Research Data (Authenticated)
app.post('/api/save/cv/research', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'cv_research.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/cv/research - Saving to: ${filePath}`);
    if (!Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        
        // Update skills cache to include research-related skills
        await updateCvSkillsCache();
        
        res.status(200).json({ message: 'CV Research data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save CV Research data.' });
    }
});

// GET CV Projects Data
app.get('/api/data/cv/projects', async (req, res) => {
    const filePath = path.join(dataPath, 'cv_projects.json');
    console.log(`GET /api/data/cv/projects - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (!Array.isArray(jsonData)) throw new Error('Invalid format: Expected array.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'CV Projects data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected array')) {
            res.status(500).json({ error: 'Failed to parse CV Projects data file. Invalid JSON array format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve CV Projects data.' });
        }
    }
});

// SAVE CV Projects Data (Authenticated)
app.post('/api/save/cv/projects', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'cv_projects.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/cv/projects - Saving to: ${filePath}`);
    if (!Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        res.status(200).json({ message: 'CV Projects data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save CV Projects data.' });
    }
});

// GET CV Skills Data
app.get('/api/data/cv/skills', async (req, res) => {
    const filePath = path.join(dataPath, 'cv_skills.json');
    console.log(`GET /api/data/cv/skills - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (typeof jsonData !== 'object' || jsonData === null || Array.isArray(jsonData)) 
            throw new Error('Invalid format: Expected object.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'CV Skills data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected object')) {
            res.status(500).json({ error: 'Failed to parse CV Skills data file. Invalid JSON object format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve CV Skills data.' });
        }
    }
});

// SAVE CV Skills Data (Authenticated)
app.post('/api/save/cv/skills', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'cv_skills.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/cv/skills - Saving to: ${filePath}`);
    if (typeof req.body !== 'object' || req.body === null || Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an object.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        
        // Update CV skills cache after manual save
        await updateCvSkillsCache();
        
        res.status(200).json({ message: 'CV Skills data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save CV Skills data.' });
    }
});

// GET CV Achievements Data
app.get('/api/data/cv/achievements', async (req, res) => {
    const filePath = path.join(dataPath, 'cv_achievements.json');
    console.log(`GET /api/data/cv/achievements - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (!Array.isArray(jsonData)) throw new Error('Invalid format: Expected array.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'CV Achievements data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected array')) {
            res.status(500).json({ error: 'Failed to parse CV Achievements data file. Invalid JSON array format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve CV Achievements data.' });
        }
    }
});

// SAVE CV Achievements Data (Authenticated)
app.post('/api/save/cv/achievements', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'cv_achievements.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/cv/achievements - Saving to: ${filePath}`);
    if (!Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        res.status(200).json({ message: 'CV Achievements data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save CV Achievements data.' });
    }
});

// GET CV Positions Data
app.get('/api/data/cv/positions', async (req, res) => {
    const filePath = path.join(dataPath, 'cv_positions.json');
    console.log(`GET /api/data/cv/positions - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (!Array.isArray(jsonData)) throw new Error('Invalid format: Expected array.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'CV Positions data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected array')) {
            res.status(500).json({ error: 'Failed to parse CV Positions data file. Invalid JSON array format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve CV Positions data.' });
        }
    }
});

// SAVE CV Positions Data (Authenticated)
app.post('/api/save/cv/positions', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'cv_positions.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/cv/positions - Saving to: ${filePath}`);
    if (!Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        res.status(200).json({ message: 'CV Positions data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save CV Positions data.' });
    }
});

// GET Endpoint for Page Content
app.get('/api/data/page_content', async (req, res) => {
  const filePath = path.join(dataPath, 'page_content.json');
  console.log(`GET /api/data/page_content - Reading: ${filePath}`);
  try {
    const fileContent = await fs.readFile(filePath, 'utf8');
    const jsonData = JSON.parse(fileContent);
     // Ensure it's an object, not an array etc.
    if (typeof jsonData !== 'object' || jsonData === null || Array.isArray(jsonData)) {
         throw new Error('Invalid page content format: Expected a JSON object.');
    }
    res.json(jsonData);
  } catch (error) {
    console.error(`Error reading or parsing ${filePath}:`, error);
    if (error.code === 'ENOENT') {
      res.status(404).json({ error: 'Page content data file not found.' });
    } else if (error instanceof SyntaxError || error.message.includes('Expected a JSON object')) {
       res.status(500).json({ error: 'Failed to parse page content data file. Invalid JSON object format.'});
    } else {
      res.status(500).json({ error: 'Failed to retrieve page content data.' });
    }
  }
});

// POST Endpoint to SAVE Page Content (Authenticated)
app.post('/api/save/page_content', requireAuth, async (req, res) => {
  const filePath = path.join(dataPath, 'page_content.json');
  const backupFilePath = filePath + '.bak';
  console.log(`POST /api/save/page_content - Saving to: ${filePath}`);

  // Validation: Ensure body is a non-null object
  if (typeof req.body !== 'object' || req.body === null || Array.isArray(req.body)) {
    return res.status(400).json({ error: 'Invalid data format. Expected a JSON object.' });
  }

  try {
    // Optional Backup
    try { await fs.copyFile(filePath, backupFilePath); console.log(`Backup created: ${backupFilePath}`); }
    catch (backupError) { if (backupError.code !== 'ENOENT') console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); }

    const jsonString = JSON.stringify(req.body, null, 2);
    await fs.writeFile(filePath, jsonString, 'utf8');
    res.status(200).json({ message: 'Page content saved successfully.' });
  } catch (error) {
    console.error(`Error writing ${filePath}:`, error);
    res.status(500).json({ error: 'Failed to save page content.' });
  }
});

// === Research API Endpoints ===

// GET Research Journal Data
app.get('/api/data/research/journal', async (req, res) => {
    const filePath = path.join(dataPath, 'research_journal.json');
    console.log(`GET /api/data/research/journal - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        
        // Validate data format
        if (!Array.isArray(jsonData)) {
            throw new Error('Invalid format: Expected array of journal articles.');
        }
        
        console.log(`Successfully read research journal data (${jsonData.length} articles)`);
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ 
                success: false, 
                error: `Data file not found: ${path.basename(filePath)}` 
            });
        } else if (error instanceof SyntaxError || error.message.includes('Invalid format')) {
            res.status(500).json({ 
                success: false, 
                error: `Failed to parse data file. Invalid JSON format in ${path.basename(filePath)}.` 
            });
        } else {
            res.status(500).json({ 
                success: false, 
                error: `Internal server error while processing research journal data.` 
            });
        }
    }
});

// SAVE Research Journal Data (Authenticated)
app.post('/api/save/research/journal', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'research_journal.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/research/journal - Saving to: ${filePath}`);
    
    // Basic array validation
    const journalArticles = req.body;
    if (!Array.isArray(journalArticles)) {
        return res.status(400).json({ 
            success: false, 
            error: 'Invalid data format. Expected an array of journal articles.' 
        });
    }
    
    // Item validation
    console.log(`Validating ${journalArticles.length} journal articles...`);
    for (let i = 0; i < journalArticles.length; i++) {
        const article = journalArticles[i];
        // Check if article is an object
        if (!article || typeof article !== 'object' || Array.isArray(article)) {
            return res.status(400).json({ 
                success: false, 
                error: `Invalid item format at index ${i}. Expected an object.` 
            });
        }
        
        // Required fields validation
        if (!article.id || typeof article.id !== 'string' || article.id.trim() === '') {
            return res.status(400).json({ 
                success: false, 
                error: `Missing or invalid 'id' at index ${i}. Required for anchor linking.` 
            });
        }
        
        if (!article.title || typeof article.title !== 'string' || article.title.trim() === '') {
            return res.status(400).json({ 
                success: false, 
                error: `Missing or invalid 'title' at index ${i}.` 
            });
        }
        
        if (!article.authors || typeof article.authors !== 'string' || article.authors.trim() === '') {
            return res.status(400).json({ 
                success: false, 
                error: `Missing or invalid 'authors' at index ${i}.` 
            });
        }
        
        if (!article.venue || typeof article.venue !== 'string' || article.venue.trim() === '') {
            return res.status(400).json({ 
                success: false, 
                error: `Missing or invalid 'venue' at index ${i}.` 
            });
        }
        
        // Check links is an object if present
        if (article.links !== undefined && (typeof article.links !== 'object' || Array.isArray(article.links) || article.links === null)) {
            return res.status(400).json({ 
                success: false, 
                error: `Invalid 'links' at index ${i}. Expected an object of key-value pairs.` 
            });
        }
    }
    console.log("Journal article validation passed successfully");
    
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(journalArticles, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        console.log(`Successfully wrote ${journalArticles.length} journal articles to ${path.basename(filePath)}`);
        
        res.status(200).json({ 
            success: true, 
            message: 'Research Journal data saved successfully.' 
        });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ 
            success: false, 
            error: `Failed to save Research Journal data: ${error.message}` 
        });
    }
});

// GET Research Thesis Data
app.get('/api/data/research/thesis', async (req, res) => {
    const filePath = path.join(dataPath, 'research_thesis.json');
    console.log(`GET /api/data/research/thesis - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        
        // Validate format
        if (typeof jsonData !== 'object' || jsonData === null || Array.isArray(jsonData)) {
            throw new Error('Invalid format: Expected thesis object.');
        }
        
        console.log("Successfully read thesis data");
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ 
                success: false, 
                error: `Data file not found: ${path.basename(filePath)}` 
            });
        } else if (error instanceof SyntaxError || error.message.includes('Invalid format')) {
            res.status(500).json({ 
                success: false, 
                error: `Failed to parse data file. Invalid JSON format in ${path.basename(filePath)}.` 
            });
        } else {
            res.status(500).json({ 
                success: false, 
                error: `Internal server error while processing thesis data.` 
            });
        }
    }
});

// SAVE Research Thesis Data (Authenticated)
app.post('/api/save/research/thesis', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'research_thesis.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/research/thesis - Saving to: ${filePath}`);
    
    // Object validation
    const thesis = req.body;
    if (typeof thesis !== 'object' || thesis === null || Array.isArray(thesis)) {
        return res.status(400).json({ 
            success: false, 
            error: 'Invalid data format. Expected a thesis object.' 
        });
    }
    
    // Required fields validation
    console.log("Validating thesis data...");
    if (!thesis.title || typeof thesis.title !== 'string' || thesis.title.trim() === '') {
        return res.status(400).json({ 
            success: false, 
            error: `Missing or invalid 'title' in thesis.` 
        });
    }
    
    if (!thesis.authors || typeof thesis.authors !== 'string' || thesis.authors.trim() === '') {
        return res.status(400).json({ 
            success: false, 
            error: `Missing or invalid 'authors' in thesis.` 
        });
    }
    
    if (!thesis.venue || typeof thesis.venue !== 'string' || thesis.venue.trim() === '') {
        return res.status(400).json({ 
            success: false, 
            error: `Missing or invalid 'venue' in thesis.` 
        });
    }
    
    // Check links is an object if present
    if (thesis.links !== undefined && (typeof thesis.links !== 'object' || Array.isArray(thesis.links) || thesis.links === null)) {
        return res.status(400).json({ 
            success: false, 
            error: `Invalid 'links' in thesis. Expected an object of key-value pairs.` 
        });
    }
    
    console.log("Thesis validation passed successfully");
    
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(thesis, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        console.log(`Successfully wrote thesis data to ${path.basename(filePath)}`);
        
        res.status(200).json({ 
            success: true, 
            message: 'Research Thesis data saved successfully.' 
        });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ 
            success: false, 
            error: `Failed to save Research Thesis data: ${error.message}` 
        });
    }
});

// GET Research Conference Data
app.get('/api/data/research/conference', async (req, res) => {
    const filePath = path.join(dataPath, 'research_conference.json');
    console.log(`GET /api/data/research/conference - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (!Array.isArray(jsonData)) throw new Error('Invalid format: Expected array.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'Research Conference data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected array')) {
            res.status(500).json({ error: 'Failed to parse Research Conference data file. Invalid JSON array format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve Research Conference data.' });
        }
    }
});

// SAVE Research Conference Data (Authenticated)
app.post('/api/save/research/conference', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'research_conference.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/research/conference - Saving to: ${filePath}`);
    if (!Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        res.status(200).json({ message: 'Research Conference data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save Research Conference data.' });
    }
});

// GET Research Patent Data
app.get('/api/data/research/patent', async (req, res) => {
    const filePath = path.join(dataPath, 'research_patent.json');
    console.log(`GET /api/data/research/patent - Reading: ${filePath}`);
    try {
        const fileContent = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(fileContent);
        if (!Array.isArray(jsonData)) throw new Error('Invalid format: Expected array.');
        res.json(jsonData);
    } catch (error) {
        console.error(`Error reading or parsing ${filePath}:`, error);
        if (error.code === 'ENOENT') {
            res.status(404).json({ error: 'Research Patent data file not found.' });
        } else if (error instanceof SyntaxError || error.message.includes('Expected array')) {
            res.status(500).json({ error: 'Failed to parse Research Patent data file. Invalid JSON array format.'});
        } else {
            res.status(500).json({ error: 'Failed to retrieve Research Patent data.' });
        }
    }
});

// SAVE Research Patent Data (Authenticated)
app.post('/api/save/research/patent', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'research_patent.json');
    const backupFilePath = filePath + '.bak';
    console.log(`POST /api/save/research/patent - Saving to: ${filePath}`);
    if (!Array.isArray(req.body)) {
        return res.status(400).json({ error: 'Invalid data format. Expected an array.' });
    }
    try {
        // Backup logic
        try { 
            await fs.copyFile(filePath, backupFilePath); 
            console.log(`Backup created: ${backupFilePath}`); 
        } catch (backupError) { 
            if (backupError.code !== 'ENOENT') 
                console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); 
        }
        
        const jsonString = JSON.stringify(req.body, null, 2);
        await fs.writeFile(filePath, jsonString, 'utf8');
        res.status(200).json({ message: 'Research Patent data saved successfully.' });
    } catch (error) {
        console.error(`Error writing ${filePath}:`, error);
        res.status(500).json({ error: 'Failed to save Research Patent data.' });
    }
});

// API Endpoint for Image Upload (Authenticated)
app.post('/api/upload/image', requireAuth, (req, res) => {
    // Use upload.single middleware. It adds req.file and req.body.
    // We need to handle potential multer errors specifically.
    upload.single('uploadedImage')(req, res, async function (err) {
        if (err instanceof multer.MulterError) {
            // A Multer error occurred (e.g., file size limit)
            console.error('Multer error during upload:', err);
            return res.status(400).json({ 
                success: false, 
                error: `File upload error: ${err.message}` 
            });
        } else if (err) {
            // An unknown error occurred or file filter rejected
            console.error('Unknown error during upload:', err);
            // Check if it's our custom filter error
            if (err.message.includes('Invalid file type')) {
                 return res.status(400).json({ 
                    success: false, 
                    error: err.message 
                });
            }
            return res.status(500).json({ 
                success: false, 
                error: 'File upload failed.' 
            });
        }

        // If file upload was successful, req.file contains file info
        if (!req.file) {
            console.warn('Upload endpoint called but no file received.');
            return res.status(400).json({ 
                success: false, 
                error: 'No image file provided.' 
            });
        }

        const originalPath = req.file.path;
        const outputFilename = req.file.filename.replace(/\.[^.]+$/, '.webp');
        const outputPath = path.join(imgPath, outputFilename);
        let processedImageBufferOrPath = originalPath; // Start with original path

        console.log(`Processing uploaded file: ${originalPath}, mimetype: ${req.file.mimetype}`);

        try {
            // --- Check if HEIC/HEIF and convert first ---
            if (req.file.mimetype === 'image/heic' || req.file.mimetype === 'image/heif' || 
                req.file.originalname.toLowerCase().endsWith('.heic') || req.file.originalname.toLowerCase().endsWith('.heif')) {
                console.log("HEIC/HEIF detected, converting...");
                try {
                    const inputBuffer = await fs.readFile(originalPath);
                    processedImageBufferOrPath = await heicConvert({
                        buffer: inputBuffer,
                        format: 'JPEG', // Convert to JPEG first
                        quality: 0.9
                    });
                    console.log("HEIC converted to JPEG buffer successfully.");
                } catch (heicError) {
                    console.error("Error converting HEIC:", heicError);
                    throw new Error("Failed to convert HEIC file.");
                }
            }
            // --- End HEIC Conversion ---

            // --- Process with Sharp (using buffer or path) ---
            console.log("Processing with Sharp...");
            await sharp(processedImageBufferOrPath)
                .resize({ width: 1920, height: 1080, fit: 'inside', withoutEnlargement: true })
                .webp({ quality: 80 })
                .toFile(outputPath);
            console.log('Image processed and saved successfully:', outputPath);
            // --- End Sharp Processing ---

            // --- Delete the original temporary file ---
            try {
                await fs.unlink(originalPath);
                console.log('Original temporary upload deleted:', originalPath);
            } catch (unlinkErr) {
                console.warn('Failed to delete original upload file:', unlinkErr);
            }

            // --- Send Response ---
            res.status(200).json({ 
                success: true, 
                filename: outputFilename 
            });
        } catch (processingError) {
            console.error('Error processing image (HEIC or Sharp):', processingError);
            // Clean up original file if processing fails
            try { 
                await fs.unlink(originalPath); 
            } catch (unlinkErr) { 
                console.warn('Failed to delete original file after processing error:', unlinkErr);
            }
            return res.status(500).json({ 
                success: false, 
                error: `Failed to process image: ${processingError.message}` 
            });
        }
    });
});

// GET Trips Data
app.get('/api/data/trips', async (req, res) => {
    const filePath = path.join(dataPath, 'trips.json');
    console.log(`GET ${filePath}`);
    try {
        const d = await fs.readFile(filePath, 'utf8');
        const j = JSON.parse(d);
        if (!Array.isArray(j)) throw new Error('Invalid format: Expected array.');
        // Optional: Sort trips by date or name before sending
        // j.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
        res.json(j);
    } catch (error) { /* Standard error handling -> 404 / 500 */
         console.error(`Error reading or parsing ${filePath}:`, error);
         // Simplified error sending
         if (error.code === 'ENOENT') { res.status(404).json({ success: false, error: 'Trips data not found.'}); }
         else { res.status(500).json({ success: false, error: 'Failed to retrieve trips data.' }); }
    }
});

// SAVE Trips Data (Authenticated)
app.post('/api/save/trips', requireAuth, async (req, res) => {
    const filePath = path.join(dataPath, 'trips.json');
    const trips = req.body;
    console.log(`POST ${filePath}`);
    if (!Array.isArray(trips)) {
        return res.status(400).json({ success: false, error: 'Invalid data format. Expected an array.' });
    }
    // Basic validation of trip objects
    for (let i = 0; i < trips.length; i++) {
         const trip = trips[i];
         if (!trip || typeof trip !== 'object') return res.status(400).json({ success: false, error: `Invalid item format at index ${i}. Expected an object.` });
         if (!trip.id || typeof trip.id !== 'string' || trip.id.trim() === '') return res.status(400).json({ success: false, error: `Missing or invalid 'id' at index ${i}.` });
         if (!trip.name || typeof trip.name !== 'string' || trip.name.trim() === '') return res.status(400).json({ success: false, error: `Missing or invalid 'name' at index ${i}.` });
         // dateRange is optional maybe? Or check it's a string.
    }

    try {
        // Backup logic here... try/catch around copyFile
        const backupFilePath = filePath + '.bak';
        try { await fs.copyFile(filePath, backupFilePath); console.log(`Backup created: ${backupFilePath}`); }
        catch (backupError) { if (backupError.code !== 'ENOENT') console.warn(`Warning: Could not create backup for ${filePath}:`, backupError); }

        await fs.writeFile(filePath, JSON.stringify(trips, null, 2), 'utf8');
        res.status(200).json({ success: true, message: 'Trips data saved successfully.' });
    } catch (error) { /* Standard error handling -> 500 */
         console.error(`Error writing ${filePath}:`, error);
         res.status(500).json({ success: false, error: 'Failed to save trips data.' });
    }
});

// API Endpoint to reorder images by setting sortIndex
// POST /api/images/reorder
// Accepts array of {slug, idx} pairs and updates sortIndex in the images.json file
// Authentication required
app.post('/api/images/reorder', requireAuth, async (req, res, next) => {
  try {
    const payload = req.body;  // [{slug:'foo.jpg', idx:3}, …]
    const filePath = path.join(dataPath, 'images.json');
    
    if (!Array.isArray(payload)) {
      return res.status(400).json({ error: 'Invalid data format. Expected an array of updates.' });
    }
    
    // Load current photos data
    const fileContent = await fs.readFile(filePath, 'utf8');
    const photos = JSON.parse(fileContent);
    
    // Create a mapping from slug to new index
    const posMap = new Map(payload.map(u => [u.slug, u.idx]));
    
    // Step A – sort the full photos array:
    //   • photos mentioned in posMap first, ordered by idx
    //   • all others keep current sortIndex order
    photos.sort((a, b) => {
      const slugA = (a.imageFull || a.thumbnail);
      const slugB = (b.imageFull || b.thumbnail);
      const inA = posMap.has(slugA);
      const inB = posMap.has(slugB);
      
      if (inA && inB) return posMap.get(slugA) - posMap.get(slugB);
      if (inA) return -1;
      if (inB) return 1;
      return (a.sortIndex || 0) - (b.sortIndex || 0);  // old order for untouched photos
    });
    
    // Step B – global re-index
    photos.forEach((p, i) => { p.sortIndex = i; });
    
    // Step C – write JSON file and send 204
    await fs.writeFile(filePath, JSON.stringify(photos, null, 2));
    
    // Return success with no content
    res.sendStatus(204);
  } catch(e) { 
    console.error('Error during image reordering:', e);
    next(e); 
  }
});

// API Endpoint for image rotation (±90°)
// POST /api/images/:slug/rotate { "dir": "left" | "right" }
// Rotates both the full image and thumbnail in place
// Authentication required
app.post('/api/images/:slug/rotate', requireAuth, async (req, res, next) => {
  try {
    const { dir } = req.body;      // 'left' | 'right'
    const deg = dir === 'left' ? -90 : 90;
    if (!['left','right'].includes(dir)) {
      console.warn(`Invalid rotation direction: ${dir}`);
      return res.status(400).json({ error: 'Invalid rotation direction' });
    }

    const slug = req.params.slug;
    if (!slug || slug.includes('..') || slug.includes('/')) {
      console.warn(`Invalid image slug: ${slug}`);
      return res.status(400).json({ error: 'Invalid image filename' });
    }

    const imageFilePath = path.join(imgPath, slug);
    
    console.log(`Rotating image ${imageFilePath} by ${deg} degrees`);
    
    // Check if file exists
    try {
      await fs.access(imageFilePath);
    } catch (err) {
      console.error(`File not found: ${imageFilePath}`);
      return res.status(404).json({ error: 'Image not found' });
    }

    // Rotate the image
    try {
      const buffer = await sharp(imageFilePath).rotate(deg).toBuffer();
      await fs.writeFile(imageFilePath, buffer);
      console.log(`Successfully rotated ${imageFilePath}`);
    } catch (err) {
      console.error(`Error rotating image: ${err.message}`);
      return res.status(500).json({ error: 'Failed to process image' });
    }

    res.sendStatus(204);
  } catch (e) { next(e); }
});

// API Endpoint to provide the Cesium Ion Token to the frontend securely
app.get('/api/config/cesium-token', (req, res) => {
  const token = process.env.CESIUM_ION_TOKEN;
  if (!token) {
    console.error("FATAL ERROR: CESIUM_ION_TOKEN environment variable is not set!");
    // Don't send detailed error to client
    return res.status(500).json({ error: 'Server configuration error.' });
  }
  // Only send the token, nothing else
  res.json({ token: token });
});

// 6. Start the Server
app.listen(PORT, () => {
  console.log(`Server is running!`);
  console.log(`Static files served from: ${path.join(__dirname)}`);
  console.log(`Access your site at: http://localhost:${PORT}`);
});
-e 
```
-e 
### ./tests/test_skill_linking.py

```py
import pytest
import json
import sys
import os

# Add the parent directory to the path so we can import server logic
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def derive_skills_from_projects(projects):
    """Python implementation of deriveSkillsFromProjects for testing."""
    skill_map = {}
    
    if not isinstance(projects, list):
        return skill_map
    
    for project in projects:
        if 'id' in project and 'skills' in project:
            # Handle both array and comma-separated string formats
            skills_array = []
            if isinstance(project['skills'], list):
                skills_array = project['skills']
            elif isinstance(project['skills'], str):
                skills_array = [s.strip() for s in project['skills'].split(',') if s.strip()]
            
            for skill in skills_array:
                if skill not in skill_map:
                    skill_map[skill] = []
                if project['id'] not in skill_map[skill]:
                    skill_map[skill].append(project['id'])
    
    return skill_map


def update_cv_skills_cache(cv_skills, projects):
    """Python implementation of updateCvSkillsCache logic for testing."""
    # Derive skills from projects
    derived_skill_map = derive_skills_from_projects(projects)
    
    # Ensure all required fields exist
    if 'uncategorized' not in cv_skills:
        cv_skills['uncategorized'] = []
    if 'allSkillsCache' not in cv_skills:
        cv_skills['allSkillsCache'] = []
    
    # Get all manual skills
    manual_skills = set()
    duplicate_count = 0
    
    # Add projects field to existing manual skills
    for category in ['programming', 'software', 'technical']:
        if category in cv_skills and isinstance(cv_skills[category], list):
            updated_skills = []
            for skill in cv_skills[category]:
                if isinstance(skill, str):
                    manual_skills.add(skill)
                    updated_skills.append({
                        'name': skill,
                        'projects': derived_skill_map.get(skill, [])
                    })
                elif isinstance(skill, dict) and 'name' in skill:
                    manual_skills.add(skill['name'])
                    # Update projects for existing skill objects
                    skill['projects'] = derived_skill_map.get(skill['name'], [])
                    updated_skills.append(skill)
                else:
                    updated_skills.append(skill)
            cv_skills[category] = updated_skills
    
    # Add new derived skills to uncategorized (avoiding duplicates)
    for skill, project_ids in derived_skill_map.items():
        if skill not in manual_skills:
            # Check if already in uncategorized
            existing_index = None
            for i, s in enumerate(cv_skills['uncategorized']):
                if isinstance(s, dict) and s.get('name') == skill:
                    existing_index = i
                    break
            
            if existing_index is None:
                cv_skills['uncategorized'].append({
                    'name': skill,
                    'projects': project_ids
                })
            else:
                # Update existing uncategorized skill's projects
                cv_skills['uncategorized'][existing_index]['projects'] = project_ids
                duplicate_count += 1
        else:
            duplicate_count += 1
    
    # Build allSkillsCache - sorted unique array of all skill names
    all_skills = set()
    for category in ['programming', 'software', 'technical']:
        if category in cv_skills and isinstance(cv_skills[category], list):
            for skill in cv_skills[category]:
                if isinstance(skill, dict) and 'name' in skill:
                    all_skills.add(skill['name'])
    
    if 'uncategorized' in cv_skills and isinstance(cv_skills['uncategorized'], list):
        for skill in cv_skills['uncategorized']:
            if isinstance(skill, dict) and 'name' in skill:
                all_skills.add(skill['name'])
    
    cv_skills['allSkillsCache'] = sorted(list(all_skills))
    
    return cv_skills, duplicate_count


class TestSkillLinking:
    """Test suite for skill linking functionality."""
    
    def test_derive_skills(self):
        """Test deriving skills from projects."""
        # Mock projects data
        projects = [
            {
                "id": "uav-deterrence",
                "skills": ["Python", "C++", "ROS"]
            },
            {
                "id": "mine-sampling",
                "skills": ["Python", "MATLAB", "Machine Learning"]
            }
        ]
        
        result = derive_skills_from_projects(projects)
        
        # Assertions
        assert "Python" in result
        assert result["Python"] == ["uav-deterrence", "mine-sampling"]
        assert result["C++"] == ["uav-deterrence"]
        assert result["MATLAB"] == ["mine-sampling"]
        assert result["Machine Learning"] == ["mine-sampling"]
        assert result["ROS"] == ["uav-deterrence"]
    
    def test_derive_skills_string_format(self):
        """Test deriving skills from comma-separated string format."""
        projects = [
            {
                "id": "test-project",
                "skills": "Python, JavaScript, React"
            }
        ]
        
        result = derive_skills_from_projects(projects)
        
        assert result["Python"] == ["test-project"]
        assert result["JavaScript"] == ["test-project"]
        assert result["React"] == ["test-project"]
    
    def test_derive_skills_no_skills(self):
        """Test handling projects without skills field."""
        projects = [
            {
                "id": "no-skills-project",
                "title": "Test Project"
            }
        ]
        
        result = derive_skills_from_projects(projects)
        assert len(result) == 0
    
    def test_derive_skills_invalid_input(self):
        """Test handling invalid input."""
        result = derive_skills_from_projects(None)
        assert result == {}
        
        result = derive_skills_from_projects("not a list")
        assert result == {}
    
    def test_update_cache(self):
        """Test updating CV skills cache."""
        # Mock CV skills
        cv_skills = {
            "programming": ["Python", "C++"],
            "software": ["Git", "ROS"],
            "technical": ["Machine Learning"]
        }
        
        # Mock projects
        projects = [
            {
                "id": "uav-deterrence",
                "skills": ["Python", "C++", "ROS", "New Skill"]
            },
            {
                "id": "mine-sampling", 
                "skills": ["Python", "Machine Learning", "MATLAB"]
            }
        ]
        
        updated_skills, duplicate_count = update_cv_skills_cache(cv_skills, projects)
        
        # Check structure
        assert "uncategorized" in updated_skills
        assert "allSkillsCache" in updated_skills
        
        # Check manual skills were updated with projects
        python_skill = next(s for s in updated_skills["programming"] if s["name"] == "Python")
        assert set(python_skill["projects"]) == {"uav-deterrence", "mine-sampling"}
        
        # Check new skills added to uncategorized
        uncategorized_names = [s["name"] for s in updated_skills["uncategorized"]]
        assert "New Skill" in uncategorized_names
        assert "MATLAB" in uncategorized_names
        
        # Check all skills cache is sorted
        assert updated_skills["allSkillsCache"] == sorted(updated_skills["allSkillsCache"])
        
        # Check no duplicates
        all_skills = []
        for category in ["programming", "software", "technical", "uncategorized"]:
            if category in updated_skills:
                all_skills.extend([s["name"] for s in updated_skills[category] if isinstance(s, dict)])
        
        assert len(all_skills) == len(set(all_skills))
    
    def test_update_cache_no_duplicates(self):
        """Test that duplicates are avoided in cache update."""
        cv_skills = {
            "programming": ["Python"],
            "uncategorized": [{"name": "Test Skill", "projects": []}]
        }
        
        projects = [
            {
                "id": "test-project",
                "skills": ["Python", "Test Skill"]
            }
        ]
        
        updated_skills, duplicate_count = update_cv_skills_cache(cv_skills, projects)
        
        # Python should be updated but not duplicated
        python_skill = next(s for s in updated_skills["programming"] if s["name"] == "Python")
        assert python_skill["projects"] == ["test-project"]
        
        # Test Skill should be updated in uncategorized, not duplicated
        test_skill = next(s for s in updated_skills["uncategorized"] if s["name"] == "Test Skill")
        assert test_skill["projects"] == ["test-project"]
        
        # Check duplicate count
        assert duplicate_count == 2  # Both skills were already present


if __name__ == "__main__":
    pytest.main([__file__, "-v"])-e 
```
-e 
### ./worldmap-admin.html

```html
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>photo upload admin</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="css/style.css" />
    <style>
      body { font-family: sans-serif; padding: 20px; }
      #preview { max-width: 300px; display: block; margin-bottom: 10px; }
      #map { height: 300px; margin-bottom: 10px; }
      input, textarea { display: block; margin-bottom: 10px; width: 300px; }
    </style>
  </head>
  <body>
    <h1>photo upload admin</h1>
    <input type="file" id="imageInput" accept="image/*" />
    <img id="preview" style="display:none;" />
    <input type="text" id="title" placeholder="title" />
    <textarea id="description" placeholder="description"></textarea>
    <input type="text" id="lat" placeholder="latitude" />
    <input type="text" id="lng" placeholder="longitude" />
    <div id="map" style="display:none;"></div>
    <button id="saveBtn">save</button>
    <pre id="output"></pre>

    <!-- include exif-js and leaflet -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
      // helper to convert dms array to decimal degrees
      function dmsToDecimal(dms, ref) {
        var degrees = dms[0];
        var minutes = dms[1];
        var seconds = dms[2];
        var dd = degrees + minutes / 60 + seconds / 3600;
        if (ref === 's' || ref === 'w') dd *= -1;
        return dd;
      }

      var imageInput = document.getElementById('imageInput');
      var preview = document.getElementById('preview');
      var titleInput = document.getElementById('title');
      var descriptionInput = document.getElementById('description');
      var latInput = document.getElementById('lat');
      var lngInput = document.getElementById('lng');
      var mapDiv = document.getElementById('map');
      var saveBtn = document.getElementById('saveBtn');
      var output = document.getElementById('output');
      var leafletMap, marker;

      imageInput.addEventListener('change', function(e) {
        var file = e.target.files[0];
        if (!file) return;

        var reader = new FileReader();
        reader.onload = function(event) {
          preview.src = event.target.result;
          preview.style.display = 'block';
        };
        reader.readAsDataURL(file);

        // extract exif data from the file
        EXIF.getData(file, function() {
          var lat = EXIF.getTag(this, 'GPSLatitude');
          var latRef = EXIF.getTag(this, 'GPSLatitudeRef');
          var lng = EXIF.getTag(this, 'GPSLongitude');
          var lngRef = EXIF.getTag(this, 'GPSLongitudeRef');

          if (lat && lng && latRef && lngRef) {
            var decLat = dmsToDecimal(lat, latRef.toLowerCase());
            var decLng = dmsToDecimal(lng, lngRef.toLowerCase());
            latInput.value = decLat;
            lngInput.value = decLng;
            mapDiv.style.display = 'none';
          } else {
            // no gps data found; show map for manual selection
            mapDiv.style.display = 'block';
            if (!leafletMap) {
              leafletMap = L.map('map').setView([0, 0], 2);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18,
                attribution: '&copy; openstreetmap contributors'
              }).addTo(leafletMap);
              leafletMap.on('click', function(e) {
                var latlng = e.latlng;
                latInput.value = latlng.lat.toFixed(6);
                lngInput.value = latlng.lng.toFixed(6);
                if (marker) {
                  marker.setLatLng(latlng);
                } else {
                  marker = L.marker(latlng).addTo(leafletMap);
                }
              });
            }
          }
        });
      });

      saveBtn.addEventListener('click', function() {
        // gather data and output as json
        var data = {
          title: titleInput.value,
          description: descriptionInput.value,
          lat: parseFloat(latInput.value),
          lng: parseFloat(lngInput.value),
          image: preview.src
        };
        output.textContent = JSON.stringify(data, null, 2);
        alert('data saved (check output below)');
      });
    </script>
  </body>
</html>
-e 
```
-e 
### ./worldmap.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Finn Wilson - Photography</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <!-- GLightbox CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox/dist/css/glightbox.min.css" />
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/worldmap.css" />
  <style>#map { height: calc(100vh - 120px); width: 100%; }</style>
</head>
<body>
  <!-- Include header -->
  <div id="header-placeholder"></div>
  <script>
    fetch('includes/header.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('header-placeholder').innerHTML = html;
        // Highlight the current page in navigation
        document.getElementById('nav-photography').classList.add('active');
      });
  </script>
  
  <!-- Map Controls -->
  <div id="mapControls" style="padding: 10px; background: #f8f8f8; border-bottom: 1px solid #ccc; display: flex; flex-wrap: wrap; gap: 20px;">
    <!-- Filter Section -->
    <div id="filterSection">
      <h3>Filter Photos</h3>
      <div>
        <label for="filterDateStart">From:</label>
        <input type="text" id="filterDateStart" placeholder="YYYY-MM-DD" style="margin-right: 5px;">
        <label for="filterDateEnd">To:</label>
        <input type="text" id="filterDateEnd" placeholder="YYYY-MM-DD">
      </div>
      <div style="position: relative;">
        <label for="filterTagsInput">Tags:</label>
        <input type="text" id="filterTagsInput" placeholder="e.g., landscape, paris">
        <div id="tagSuggestions" class="autocomplete-suggestions"></div>
      </div>
      
      <div style="margin-top: 5px;">
        <label for="filterCountrySelect">Country:</label>
        <select id="filterCountrySelect">
          <option value="">-- All Countries --</option>
          <!-- Country options added by JS -->
        </select>
      </div>
      <div>
        <button id="applyFiltersButton">Apply Filters</button>
        <button id="clearFiltersButton">Clear Filters</button>
      </div>
      
      <!-- Active Filters Display -->
      <div id="activeFilters" style="width: 100%; margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
        <span>Active Filters: </span>
        <span id="activeFiltersList">
          <!-- Active filter badges will be added here by JS -->
          <span class="no-filters" style="font-style: italic; color: #888;">None</span>
        </span>
      </div>
    </div>
    
    <!-- Simplified interface - no view options -->

  </div>
  
  <!-- Map Container -->
  <div id="map"></div>
  
  <!-- Map interface simplified - no location list container -->

  <!-- GLightbox will be initialized via JavaScript -->

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <!-- GLightbox JS -->
  <script src="https://cdn.jsdelivr.net/npm/glightbox/dist/js/glightbox.min.js"></script>
  
  <script src="js/script.js"></script>
  <script src="js/worldmap.js"></script>
</body>
</html>-e 
```
